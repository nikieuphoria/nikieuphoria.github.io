<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git</title>
      <link href="/2025/02/08/git-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
      <url>/2025/02/08/git-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/git.png" alt="11"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内核--Cgroup与namespace</title>
      <link href="/2025/02/08/Linux%20%E5%86%85%E6%A0%B8--Cgroup%E4%B8%8Enamespace/"/>
      <url>/2025/02/08/Linux%20%E5%86%85%E6%A0%B8--Cgroup%E4%B8%8Enamespace/</url>
      
        <content type="html"><![CDATA[<h2 id="容器-cgroup-namespace-rootfs-容器引擎"><a href="#容器-cgroup-namespace-rootfs-容器引擎" class="headerlink" title="容器 &#x3D; cgroup + namespace + rootfs + 容器引擎"></a>容器 &#x3D; cgroup + namespace + rootfs + 容器引擎</h2><p>容器的核心技术是 <strong>Cgroup</strong> + <strong>Namespace</strong></p><ul><li>​Cgroup： 资源控制 </li><li>​namespace： 访问隔离</li><li>​rootfs：文件系统隔离。镜像的本质就是一个rootfs文件</li><li>​容器引擎：生命周期控制</li></ul><p><strong>cgroup（控制组）和namespace（命名空间）</strong> 是 Linux 内核中的两个核心技术，主要用于实现<strong>资源管理</strong>和<strong>环境隔离</strong>，它们是容器技术（如 Docker）的底层基础。</p><hr><h3 id="cgroup（控制组）："><a href="#cgroup（控制组）：" class="headerlink" title="cgroup（控制组）："></a><strong>cgroup（控制组）：</strong></h3><p><strong>核心作用</strong>：<strong>限制、分配和监控进程的资源使用</strong>，比如 CPU、内存、磁盘 I&#x2F;O 等。</p><ul><li><strong>作用：</strong> 通过cgroup，系统管理员可以为一组进程分配资源，并限制它们对系统资源的使用。这对于实现资源隔离和管理是很有用的，特别是在容器化环境中，可以确保容器之间不会相互干扰，同时允许对资源进行有效的分配和控制。</li></ul><h3 id="namespace（命名空间）："><a href="#namespace（命名空间）：" class="headerlink" title="namespace（命名空间）："></a><strong>namespace（命名空间）：</strong></h3><p>命名空间是 Linux 内核提供的一种隔离机制，用于<strong>隔离</strong>容器的进程和文件系统等。</p><ul><li><strong>作用：</strong> 命名空间提供了一种隔离的手段，使得进程可以在一个独立的环境中运行，与其他命名空间中的进程隔离开。常用的命名空间包括 PID（进程 ID）、NET（网络）、UTS（主机名和域名）、IPC（进程间通信）、MNT（挂载点）等。在容器技术中，命名空间是实现容器隔离的基础，使得容器内的进程和资源与主机及其他容器隔离开。</li></ul><hr><h3 id="cgroup-vs-namespace-的区别"><a href="#cgroup-vs-namespace-的区别" class="headerlink" title="cgroup vs namespace 的区别"></a>cgroup vs namespace 的区别</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>cgroup</strong></th><th><strong>namespace</strong></th></tr></thead><tbody><tr><td><strong>核心目标</strong></td><td>限制资源用量（如 CPU、内存）</td><td>隔离资源视图（如进程、网络）</td></tr><tr><td><strong>关注点</strong></td><td><strong>资源控制</strong></td><td><strong>环境隔离</strong></td></tr><tr><td><strong>类比</strong></td><td>给进程分配“资源配额”</td><td>给进程创造一个“独立房间”</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> linux </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SElinux-安全上下文</title>
      <link href="/2025/01/21/SElinux/"/>
      <url>/2025/01/21/SElinux/</url>
      
        <content type="html"><![CDATA[<h2 id="SElinux-Security-Enhanced-Linux-安全增强型-linux"><a href="#SElinux-Security-Enhanced-Linux-安全增强型-linux" class="headerlink" title="SElinux-Security-Enhanced Linux 安全增强型 linux"></a>SElinux-Security-Enhanced Linux 安全增强型 linux</h2><p>Linux系统安全的强制访问控制体系</p><h3 id="三种配置模式"><a href="#三种配置模式" class="headerlink" title="三种配置模式"></a>三种配置模式</h3><ol><li>selinux的配置文件：&#x2F;etc&#x2F;sysconfig&#x2F;selinux</li></ol><table><thead><tr><th>状态</th><th>含义</th></tr></thead><tbody><tr><td>enforcing</td><td>级别为强制</td></tr><tr><td>permissive</td><td>级别为警告</td></tr><tr><td>disable</td><td>关闭</td></tr></tbody></table><ol start="2"><li>模式管理</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看当前工作模式</span></span><br><span class="line">[root@server ~]# getenforce</span><br><span class="line"></span><br><span class="line">[root@server ~]# getenforce</span><br><span class="line">Enforcing</span><br><span class="line"><span class="comment"># 临时关闭进入宽容模式</span></span><br><span class="line">[root@server ~]# setenforce  0  </span><br><span class="line">[root@server ~]# getenforce</span><br><span class="line">Permissive</span><br><span class="line"> <span class="comment"># 临时开启</span></span><br><span class="line">[root@server ~]# setenforce  1 </span><br><span class="line">[root@server ~]# getenforce</span><br><span class="line">Enforcing</span><br><span class="line"></span><br><span class="line"><span class="comment">#永久性关闭</span></span><br><span class="line">[root@server ~]# vim  /etc/selinux/config </span><br><span class="line">SELINUX=disabled    </span><br></pre></td></tr></table></figure><p><code>注意</code>：enforceing与permissive二者可以直接进行切换，但是关闭selinux（disabled）进行切换时要重启reboot</p><h3 id="安全上下文（security-context）"><a href="#安全上下文（security-context）" class="headerlink" title="安全上下文（security context）"></a><strong>安全上下文（security context）</strong></h3><ul><li>所有进程、文件和目录都有自己的安全上下文</li><li>进程是否能够访问文件或目录，就要其安全上下文是否匹配</li></ul><p><strong>安全上下文用冒号分为四个字段：Identify：role：type：</strong></p><ul><li>身份标识（Identify）：相当于账号方面的身份标识，主要有以下三种常见的类型：<ul><li>root：表示root的账号身份；</li><li>system_u：表示程序方面的标识，通常就是进程</li><li>unconfined_u：代表的是一般用户账号相关的身份。</li></ul></li><li>角色（role）：通过角色字段，可知道这个数据是属于程序、文件资源还是代表用户。一般角色有：<ul><li>object_r：代表的是文件或目录等文件资源；</li><li>system_r：代表的是进程。</li></ul></li><li><strong>类型（type）：</strong><ul><li>type：在文件资源上面称为类型。</li><li>domain：在主体程序中则称为域。domain需要与type搭配，则该程序才能够顺利读取文件资源。</li></ul></li><li>最后一个字段是和MLS和MCS相关的东西，代表灵敏度，一般用s0、s1、s2来命名，数字代表灵敏度的分级。数值越大、灵敏度越高。</li></ul><p><strong>查看安全上下文</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -Z</span><br></pre></td></tr></table></figure><p><strong>chcon手动修改文件的SELinux类型</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chcon</span> [-R] [-t <span class="built_in">type</span>] [-u user] [-r role] 文件</span><br><span class="line"><span class="built_in">chcon</span> [-R] --reference=范例文件 文件</span><br><span class="line">选项：</span><br><span class="line">-R：连同该目录下的子目录也同时修改</span><br><span class="line">-t：后面接安全上下文的类型栏位，例如httpd_sys_content_t</span><br><span class="line">-u：后面接身份识别，例如system_u</span><br><span class="line">-r：后面接角色，例如 system_r</span><br><span class="line">-v：若有变化成功，请将变动的结果列出来</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>restorecon让文件恢复正确的SELinux类型</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restorecon [-Rv] 文件目录</span><br><span class="line">选项：</span><br><span class="line">-R：连同子目录一起修改</span><br><span class="line">-v：将过程显示到屏幕</span><br></pre></td></tr></table></figure><p><strong>semanage默认目录的安全上下文查询与修改</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum -y install policycoreutils-python semanage</span><br><span class="line"></span><br><span class="line">semanage 选项 参数  文件</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">login</span><br><span class="line">user</span><br><span class="line">port</span><br><span class="line">interface</span><br><span class="line">fcontext  <span class="comment">#注意：fcontext查询默认安全上下文（重要）</span></span><br><span class="line">translation</span><br><span class="line">boolean</span><br><span class="line">参数：</span><br><span class="line"> -l :查询；</span><br><span class="line"> -a :添加</span><br><span class="line"> -m :修改</span><br><span class="line"> -d :删除</span><br><span class="line"> -t :类型</span><br><span class="line"> -r :角色</span><br><span class="line"> -s :用户</span><br><span class="line"> -f :文件</span><br><span class="line">文件：</span><br><span class="line">文件或目录</span><br><span class="line"></span><br><span class="line">semanage  fcontext  -l |  grep  文件名</span><br><span class="line">semanage  port  -l  |  grep  协议</span><br><span class="line">semanage port -a -t http_port_t  -p  tcp  7777 <span class="comment"># 添加新端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例1 查询一下/etc/  /etc/cron.d默认的SELinux类型是什么</span></span><br><span class="line">[root@chenshiren ~]# semanage  fcontext -l |grep -E <span class="string">&#x27;^/etc|^/etc/cron&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>实验1</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件系统与磁盘管理</title>
      <link href="/2025/01/21/linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
      <url>/2025/01/21/linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><strong>disk -&gt; partition -&gt; PV -&gt; VG -&gt; LV -&gt; fs</strong></p><p><strong>磁盘-&gt;分区-&gt;物理卷-&gt;卷组-&gt;逻辑卷-&gt;文件系统。</strong><br>![[&#x2F;images&#x2F;disk.drawio.png]]</p><h4 id="文件系统-File-System"><a href="#文件系统-File-System" class="headerlink" title="文件系统 File System"></a>文件系统 <strong>File System</strong></h4><ol><li>EXT4：EXT4是Linux默认文件系统</li><li>XFS</li><li><strong>SWAP</strong>：交换文件系统，相当于虚拟内存</li></ol><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>列出文件系统的整体磁盘使用量</p><p>df -h</p><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><p>检查磁盘空间使用量</p><h4 id="lsblk"><a href="#lsblk" class="headerlink" title="lsblk"></a>lsblk</h4><ul><li>列出块设备的信息，包括磁盘和分区。它以树状结构显示</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列出当前系统所有磁盘与磁盘内的分区信息</span></span><br><span class="line">[root@master ~]# lsblk</span><br><span class="line">NAME              MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda                 8:0    0   20G  0 disk</span><br><span class="line">├─sda1              8:1    0    1G  0 part /boot</span><br><span class="line">└─sda2              8:2    0   19G  0 part</span><br><span class="line">  ├─centos-root   253:0    0   17G  0 lvm  /</span><br><span class="line">  └─centos-swap   253:1    0    2G  0 lvm  [SWAP]</span><br><span class="line">sdb                 8:16   0  100G  0 disk</span><br><span class="line">├─datavg-data1_lv 253:2    0   45G  0 lvm</span><br><span class="line">└─datavg-data2_lv 253:3    0  200M  0 lvm</span><br><span class="line">sr0                11:0    1  9.5G  0 rom</span><br><span class="line"></span><br><span class="line"><span class="comment">#sda1：sd代表SCSI磁盘，a代表第一块磁盘，1代表第一个分区</span></span><br><span class="line"><span class="comment">#sdb：sd代表SCSI磁盘，b代表第二块磁盘，1代表第一个分区</span></span><br><span class="line"><span class="comment">#解释：</span></span><br><span class="line">NAME <span class="comment">#设备名称</span></span><br><span class="line">MAJ:MIN <span class="comment">#主设备号:次设备号，内核通过主次设备号识别磁盘</span></span><br><span class="line">RM <span class="comment">#是否为可卸载设备，1可卸载，0不可卸载</span></span><br><span class="line">SIZE <span class="comment">#设备的容量大小</span></span><br><span class="line">RO <span class="comment">#表示设备是否为只读，0非只读设备，1只读设备</span></span><br><span class="line">TYPE <span class="comment">#表示设备类型（disk为磁盘，part为分区，lvm逻辑卷，rom只读）</span></span><br><span class="line">MOUNTPOINT <span class="comment">#设备挂载点（SWAP没有挂载点）</span></span><br><span class="line"></span><br><span class="line">lsblk -f <span class="comment">##列出所有磁盘分区内使用的文件系统类型</span></span><br></pre></td></tr></table></figure><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><ul><li>**分区过程：**添加新硬盘–分区–格式化文件系统–挂载使用</li></ul><h3 id="1-fdisk-磁盘分区"><a href="#1-fdisk-磁盘分区" class="headerlink" title="1.fdisk-磁盘分区"></a>1.fdisk-磁盘分区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br><span class="line">**m <span class="comment">#获取命令帮助 ※**</span></span><br><span class="line">**p <span class="comment">#显示磁盘分区表 ※**</span></span><br><span class="line">**n <span class="comment">#新增加一个分区 ※**</span></span><br><span class="line">q <span class="comment">#不保存分区退出 ※</span></span><br><span class="line">d <span class="comment">#删除一个分区 ※</span></span><br><span class="line">**w <span class="comment">#保存分区退出 ※  记得保存**   </span></span><br><span class="line">a <span class="comment">#设置可引导标记</span></span><br><span class="line">b <span class="comment">#编辑bsd磁盘标签</span></span><br><span class="line">c <span class="comment">#设置DOS操作系统兼容标记</span></span><br><span class="line">l <span class="comment">#显示已知的文件系统类型，82为swap交换分区，83为Linux分区</span></span><br><span class="line">o <span class="comment">#建立空白DOS分区表</span></span><br><span class="line">s <span class="comment">#新建空白SUN磁盘标签</span></span><br><span class="line">t <span class="comment">#改变分区的系统ID</span></span><br><span class="line">u <span class="comment">#改变显示记录单位</span></span><br><span class="line">v <span class="comment">#验证分区表</span></span><br><span class="line">x <span class="comment">#附加功能</span></span><br></pre></td></tr></table></figure><ul><li><p>示例</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# fdisk /dev/sdb   **#*对sdb进行分区***   </span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, <span class="keyword">until</span> you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n  **#增加分区**  </span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (2 primary, 0 extended, 2 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p):  <span class="comment">#**回车选择默认主分区**    </span></span><br><span class="line">Using default response p</span><br><span class="line">Partition number (2,4, default 2): 2   **#输入分区号为2**    </span><br><span class="line">First sector (4097-209715199, default 26624):  **#回车选择默认起始位置**   </span><br><span class="line">Using default value 26624</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (26624-209715199, default 209715199): 409600</span><br><span class="line"><span class="comment">#**输入磁柱结束位置**  </span></span><br><span class="line">Partition 2 of <span class="built_in">type</span> Linux and of size 187 MiB is <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): </span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 107.4 GB, 107374182400 bytes, 209715200 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0xbf03ef25</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048        4096        1024+  83  Linux</span><br><span class="line">/dev/sdb2           26624      409600      191488+  83  Linux</span><br><span class="line">/dev/sdb3            6144       24689        9273   83  Linux</span><br><span class="line"></span><br><span class="line">Partition table entries are not <span class="keyword">in</span> disk order</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w   **#保存分区并退出**    </span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br><span class="line">[root@master ~]# lsblk   **#查看磁盘信息，sdb分区2已经创建**    </span><br><span class="line">NAME              MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda                 8:0    0   20G  0 disk</span><br><span class="line">├─sda1              8:1    0    1G  0 part /boot</span><br><span class="line">└─sda2              8:2    0   19G  0 part</span><br><span class="line">  ├─centos-root   253:0    0   17G  0 lvm  /</span><br><span class="line">  └─centos-swap   253:1    0    2G  0 lvm  [SWAP]</span><br><span class="line">sdb                 8:16   0  100G  0 disk</span><br><span class="line">├─sdb1              8:17   0    1M  0 part</span><br><span class="line">├─sdb2              8:18   0  187M  0 part</span><br><span class="line">├─sdb3              8:19   0  9.1M  0 part</span><br><span class="line">├─datavg-data1_lv 253:2    0   45G  0 lvm</span><br><span class="line">└─datavg-data2_lv 253:3    0  200M  0 lvm</span><br><span class="line">sr0                11:0    1  9.5G  0 rom</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-mkxfs格式化分区为文件系统"><a href="#2-mkxfs格式化分区为文件系统" class="headerlink" title="2.mkxfs格式化分区为文件系统"></a>2.mkxfs<strong>格式化分区为文件系统</strong></h3><ul><li>mkfs命令用于在分区上建立文件系统</li><li>常用文件系统类型：ext4，xfs</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t 文件系统格式 /dev/sdb1</span><br><span class="line">mkfs.文件格式 /dev/sdb1  </span><br></pre></td></tr></table></figure><h3 id="3-mount挂载分区"><a href="#3-mount挂载分区" class="headerlink" title="3.mount挂载分区"></a>3.mount挂载分区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建挂载点目录</span></span><br><span class="line">[root@localhost ~]# <span class="built_in">mkdir</span> /mybak</span><br><span class="line"></span><br><span class="line"><span class="comment">#挂载文件系统</span></span><br><span class="line">[root@localhost ~]# mount /dev/sdb1 /mybak</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看正在使用中的分区信息</span></span><br><span class="line">[root@localhost ~]# <span class="built_in">df</span> -Th</span><br></pre></td></tr></table></figure><h3 id="4-永久挂载"><a href="#4-永久挂载" class="headerlink" title="4.永久挂载"></a>4.永久挂载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">5. **永久挂载：** 更新 /etc/fstab 文件，以确保在系统重新启动时分区会自动挂载</span><br><span class="line"></span><br><span class="line"><span class="comment">#开机自动挂载</span></span><br><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment">#末行 添加  </span></span><br><span class="line">/dev/sdc1 /mnt/sdc_drive ext4 defaults 0 0</span><br><span class="line"><span class="comment">#设备 挂载点 文件类型 defaults 0 0    </span></span><br></pre></td></tr></table></figure><h2 id="SWAP"><a href="#SWAP" class="headerlink" title="SWAP"></a>SWAP</h2><p>在物理内存空间不足时，可以将物理内存中的一些不重要数据拷贝到磁盘的 swap 分区中，从而让出内存空间，并且在需要那些已被拷出数据时再从 swap 分区中拷回到内存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看内存及swap</span></span><br><span class="line">free</span><br><span class="line">free -h</span><br><span class="line">free -m</span><br></pre></td></tr></table></figure><h3 id="增加swap分区"><a href="#增加swap分区" class="headerlink" title="增加swap分区"></a>增加swap分区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">**方法一**</span><br><span class="line"><span class="comment">#创建分区</span></span><br><span class="line">[root@node2 ~]# fdisk /dev/vdb</span><br><span class="line"><span class="comment">#格式化为文件系统</span></span><br><span class="line">[root@node2 ~]# mkswap /dev/vdb3</span><br><span class="line"><span class="comment">#保存设置使其永久生效</span></span><br><span class="line">[root@node2 ~]# vim /etc/fstab</span><br><span class="line">/dev/vdb3 swap swap defaults 0 0</span><br><span class="line"><span class="comment"># 激活SWAP文件</span></span><br><span class="line">swapon -a</span><br><span class="line"><span class="comment">#查看交换分区组成</span></span><br><span class="line">swapon -s</span><br><span class="line">free -h</span><br><span class="line"></span><br><span class="line">**方法二**</span><br><span class="line"><span class="comment"># 在根目录创建分区路径</span></span><br><span class="line">$ <span class="built_in">mkdir</span> -p /swap/</span><br><span class="line"><span class="comment"># 设置分区的大小</span></span><br><span class="line"><span class="comment"># bs=64M是块大小，count=64是块数量，所以swap空间大小是bs*count=4096MB=4GB</span></span><br><span class="line">$ <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/swap/swap0 bs=64M count=64</span><br><span class="line"><span class="comment"># 设置该目录权限</span></span><br><span class="line">$ <span class="built_in">chmod</span> 0600 /swap/swap0</span><br><span class="line"><span class="comment"># 创建SWAP文件</span></span><br><span class="line">$ mkswap /swap/swap0</span><br><span class="line"><span class="comment"># 激活SWAP文件</span></span><br><span class="line">$ swapon /swap/swap0</span><br><span class="line"><span class="comment"># 查看SWAP信息是否正确</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h2><table><thead><tr><th>PV</th><th>物理卷physical volume</th></tr></thead><tbody><tr><td>VG</td><td>卷组Volume Group</td></tr><tr><td>LV</td><td>逻辑卷logical volume</td></tr></tbody></table><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/3afe2fdd-cad2-43f1-8adc-f1d3b699ee5c/94a1f2ee-e740-44cf-bd2c-a6c21df5515a/image.png" alt="image.png"></p><h3 id="pv-物理卷"><a href="#pv-物理卷" class="headerlink" title="pv-物理卷"></a>pv-物理卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pvcreate /dev/sdb1  /dev/sbd2</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看物理卷</span></span><br><span class="line">[root@newrain ~]# pvs</span><br></pre></td></tr></table></figure><h3 id="vg-卷组"><a href="#vg-卷组" class="headerlink" title="vg-卷组"></a>vg-卷组</h3><p>将创建好的物理卷组成卷组</p><p>直接创建卷组(系统会先将分区或磁盘创建为PV再创建卷组）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgcreate vg1 /dev/sdb1</span><br><span class="line"> Volume group <span class="string">&quot;vg1&quot;</span> successfully created</span><br><span class="line">  </span><br><span class="line"> vgcreate -s [PE大小] </span><br><span class="line">  </span><br><span class="line">[root@localhost ~]# vgs</span><br></pre></td></tr></table></figure><h3 id="lv-逻辑卷"><a href="#lv-逻辑卷" class="headerlink" title="lv-逻辑卷"></a>lv-逻辑卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#创建逻辑卷</span></span><br><span class="line">[root@localhost ~]# lvcreate -L 10G -n mylv vg1</span><br><span class="line">Logical volume <span class="string">&quot;mylv&quot;</span> created.</span><br><span class="line"></span><br><span class="line">-L：指定逻辑卷的大小，如 -L 10G 表示 10GB。</span><br><span class="line">-l [PE个数] PE物理拓展块</span><br><span class="line"></span><br><span class="line">查看逻辑卷信息：</span><br><span class="line">lvs       //显示有关逻辑卷的信息</span><br><span class="line">lvscan     //扫描并显示LVM逻辑卷</span><br><span class="line">lvdisplay   //显示LVM逻辑卷属性</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="格式化并挂载使用"><a href="#格式化并挂载使用" class="headerlink" title="格式化并挂载使用"></a><strong>格式化并挂载使用</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#格式化文件系统</span></span><br><span class="line">[root@localhost ~]# mkfs.xfs /dev/vg1/mylv</span><br><span class="line"></span><br><span class="line"><span class="comment">#挂载使用</span></span><br><span class="line">[root@localhost ~]# <span class="built_in">mkdir</span> /mount</span><br><span class="line">[root@localhost ~]# mount /dev/vg1/mylv /mount</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="拓展空间"><a href="#拓展空间" class="headerlink" title="拓展空间"></a>拓展空间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#拓展卷组  </span></span><br><span class="line">[root@localhost ~]# vgextend vg1 /dev/sdb5 </span><br><span class="line"></span><br><span class="line"><span class="comment">#扩容逻辑卷</span></span><br><span class="line">[root@localhost ~]# lvextend -L +9G /dev/vg1/mylv</span><br><span class="line"></span><br><span class="line">扩展文件系统：当逻辑卷扩大以后，也需要对逻辑卷的文件系统进行扩展</span><br><span class="line">扩展文件系统容量：</span><br><span class="line">xfs_growfs <span class="comment">#用于扩容XFS设备</span></span><br><span class="line">resize2fs <span class="comment">#用于扩容EXT3/EXT4设备</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#扩展文件系统</span></span><br><span class="line"> xfs_growfs /dbbak</span><br><span class="line"> resize2fs /dev/myvol/vo</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-文件的访问控制列表facl</title>
      <link href="/2025/01/21/%E6%96%87%E4%BB%B6%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8facl/"/>
      <url>/2025/01/21/%E6%96%87%E4%BB%B6%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8facl/</url>
      
        <content type="html"><![CDATA[<p><code>setfacl</code>工具： 设置和修改文件或目录的访问控制列表（ACLs）的命令行工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setfacl -m option:name[:permission] file</span><br></pre></td></tr></table></figure><ul><li><code>-m</code> 表示修改现有的 ACL 条目。</li><li><code>option</code> 可以是 <code>u</code>（用户）、<code>g</code>（组）、<code>o</code>（其他）、<code>d</code>（默认）、<code>-</code>（掩码，用于限制通过 ACL 授予的权限）。</li><li><code>name</code> 是用户或组的名称。</li><li><code>permission</code> 是逗号分隔的权限列表，可以是 <code>r</code>（读）、<code>w</code>（写）、<code>x</code>（执行）、<code>R</code>（读，但不允许执行）、<code>W</code>（写，但不允许执行）、<code>X</code>（执行，但不允许写）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/01/15/hello-world/"/>
      <url>/2025/01/15/hello-world/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>Welcome to the fountainhead! This is my very first post.</p><p>无论学的是C、Python、Java，还是某种冷门语言，第一件事总是：让语言“说出”它的第一句话。编程界的初心，或许只是一段代码中最纯粹的问候。</p><p>对世界保持好奇心，不断探索新世界！</p>]]></content>
      
      
      <categories>
          
          <category> 关于对世界的好奇心 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ansible</title>
      <link href="/2024/10/30/ansible/"/>
      <url>/2024/10/30/ansible/</url>
      
        <content type="html"><![CDATA[<h1 id="一、安装与配置"><a href="#一、安装与配置" class="headerlink" title="一、安装与配置"></a><span style>一、安装与配置</span></h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#yum安装</span></span><br><span class="line">yum install epel-release -y</span><br><span class="line">yum install ansible –y</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看ansible版本</span></span><br><span class="line">ansible --version</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-管理节点与被管理节点建⽴SSH信任关系"><a href="#2-管理节点与被管理节点建⽴SSH信任关系" class="headerlink" title="2.管理节点与被管理节点建⽴SSH信任关系"></a>2.管理节点与被管理节点建⽴SSH信任关系</h2><pre><code>2.1.生成私钥[root@server ~]# ssh-keygen   2.2.向主机分发私钥[root@server ~]# ssh-copy-id root@192.168.37.122[root@server ~]# ssh-copy-id root@192.168.37.133</code></pre><h2 id="3-ansible配置文件"><a href="#3-ansible配置文件" class="headerlink" title="3. ansible配置文件"></a>3. ansible配置文件</h2><p>修改配置文件，创建主机清单文件 ：写在[]里的是组名，[ ]下面的是组内的主机名<br>[root@server ~]# vim &#x2F;etc&#x2F;ansible&#x2F;hosts<br>[web]<br>192.168.37.122<br>192.168.37.133</p><h1 id="二、核心组件"><a href="#二、核心组件" class="headerlink" title="二、核心组件"></a>二、核心组件</h1><p>主机清单（Inventory）<br>模块（Modules）<br>任务（Tasks）和剧本（Playbooks）<br>角色（Roles）</p><h1 id="三、ansible-doc-命令行模块"><a href="#三、ansible-doc-命令行模块" class="headerlink" title=" 三、ansible-doc 命令行模块"></a><span style> 三、ansible-doc 命令行模块</span></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ansible &lt;ip组&gt; -m &lt;模块&gt; -a &lt;argument参数&gt; [options]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ansible dev,<span class="built_in">test</span>,prod -a <span class="string">&#x27;getenforce&#x27;</span> </span><br></pre></td></tr></table></figure><p>命令的工作目录默认是远程用户的主目录（~），command 模块不会保留shell的环境状态（包括当前工作目录）</p><p> ansible-doc -l  #列出当前系统中ansible的所有模块<br>ansible-doc  -s  模块名   #查看模块的参数<br>ansible-doc  模块名   #查看模块的详细信息包括用法</p><h3 id="1-ping模块"><a href="#1-ping模块" class="headerlink" title="1.ping模块"></a>1.ping模块</h3><p><code>ansible all -m ping</code></p><h3 id="2-command模块"><a href="#2-command模块" class="headerlink" title="2.command模块"></a>2.command模块</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chdir=/etc/sysconfig  ---执行命令前先切换到指定目录</span><br><span class="line">creates=/doc/1.txt：判断指定文件是否存在，如果存在，不执行后面的操作</span><br><span class="line">removes：判断指定文件是否存在，如果存在，执行后面的操作</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>注意，该命令不支持&#x3D;&#x3D;<code>| 管道命令</code>&#x3D;&#x3D;。</li></ul><p><code>ansible all -m command -a ‘removes=/etc/sysconfig/network-scripts/ifcfg-ens33 ip addr ’</code></p><h3 id="3-shell模块"><a href="#3-shell模块" class="headerlink" title="3.shell模块"></a>3.shell模块</h3><p>ansible all -m shell -a ‘echo “niki_ansible” |cat &gt;&gt;1.txt&#96;</p><p>ansible webservers -m shell -a ‘ifconfig | grep ens33’</p><p>ansible webservers -m shell -a ‘ifconfig &gt; &#x2F;opt&#x2F;kx.txt’</p><h3 id="4-file模块"><a href="#4-file模块" class="headerlink" title="4.file模块"></a>4.file模块</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">state　　#状态，有以下选项：</span><br><span class="line"></span><br><span class="line">directory：如果目录不存在，就创建目录</span><br><span class="line">file：文件不存在，不会被创建</span><br><span class="line">touch：文件不存在，创建新文件，如果文件或目录已存在，则更新其最后修改时间</span><br><span class="line">absent：删除目录、文件或者取消链接文件</span><br><span class="line">link：创建软链接，hard：创建硬链接</span><br></pre></td></tr></table></figure><p><code>ansible web -m file -a &#39;path=/data/app state=directory’</code>   创建目录</p><p><code>ansible web -m file -a &#39;path=/data/a state=absent’</code>      删除文件</p><p><code>ansible dbservers -m file -a &#39; group=root mode=644 path=/opt/host_ansible&#39;</code> #修改文件的属主属组权限等</p><h3 id="5-copy模块-将文件复制到远程主机"><a href="#5-copy模块-将文件复制到远程主机" class="headerlink" title="5.copy模块-将文件复制到远程主机"></a>5.copy模块-将文件复制到远程主机</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src　　　　<span class="comment">#被复制到远程主机的本地文件。可以是绝对路径，也可以是相对路径。如果路径是一个目录，则会递归复制，用法类似于&quot;rsync&quot;</span></span><br><span class="line">content　　　<span class="comment">#用于替换&quot;src&quot;，可以直接指定文件的值</span></span><br><span class="line">dest　　　　<span class="comment">#必选项，将源文件复制到的远程主机的绝对路径</span></span><br><span class="line">backup　　　<span class="comment">#当文件内容发生改变后，在覆盖之前把源文件备份，备份文件包含时间信息</span></span><br><span class="line">directory_mode　　　　<span class="comment">#递归设定目录的权限，默认为系统默认权限</span></span><br></pre></td></tr></table></figure><p> <code>ansible web -m copy -a &#39;src=~/hello dest=/data/hello&#39;</code> </p><p><code>ansible web -m copy -a &#39;content=&quot;I am keer\n&quot; dest=/data/name mode=666’</code></p><h3 id="6-fetch-模块-从远程主机获取文件到本地"><a href="#6-fetch-模块-从远程主机获取文件到本地" class="headerlink" title="6.fetch 模块-从远程主机获取文件到本地"></a>6.<strong>fetch 模块-从远程主机获取文件到本地</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dest：用来存放文件的目录</span><br><span class="line">src：在远程拉取的文件，**并且必须是一个file**，不能是目录</span><br></pre></td></tr></table></figure><p><code>ansible web -m fetch -a &#39;src=/data/hello dest=/data&#39;</code>  </p><h3 id="7-yum-apt-模块"><a href="#7-yum-apt-模块" class="headerlink" title="7.yum&#x2F;apt 模块"></a>7.<strong>yum&#x2F;apt 模块</strong></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">name：要管理的包名</span></span><br><span class="line"><span class="string">state：#present---&gt;安装</span> <span class="string">latest---&gt;安装最新的,</span> <span class="string">absent---&gt;</span> <span class="string">卸载软件。</span></span><br></pre></td></tr></table></figure><hr><h3 id="8-service-模块"><a href="#8-service-模块" class="headerlink" title="8. service 模块"></a>8. service 模块</h3><p>　　该模块用于服务程序的管理。<br>　　其主要选项如下：</p><blockquote><p><code>arguments</code> #命令行提供额外的参数<br><code>enabled</code> #设置开机启动。<br><code>name=</code> #服务名称<br><code>runlevel</code> #开机启动的级别，一般不用指定。<br><code>sleep</code> #在重启服务的过程中，是否等待。如在服务关闭以后等待2秒再启动。(定义在剧本中。)<br><code>state</code> #有四种状态，分别为：<code>started</code>—&gt;启动服务， <code>stopped</code>—&gt;停止服务， <code>restarted</code>—&gt;重启服务， <code>reloaded</code>—&gt;重载配置</p></blockquote><p>　　下面是一些例子：<br><strong>① 开启服务并设置自启动</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@server</span> ~]# ansible web -m service -a <span class="string">&#x27;name=nginx state=started enabled=true&#x27;</span> </span><br><span class="line"><span class="number">192.168</span>.<span class="number">37.122</span> | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="keyword">true</span>, </span><br><span class="line">    <span class="string">&quot;enabled&quot;</span>: <span class="keyword">true</span>, </span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;nginx&quot;</span>, </span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;started&quot;</span>, </span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">192.168</span>.<span class="number">37.133</span> | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">&quot;changed&quot;</span>: <span class="keyword">true</span>, </span><br><span class="line">    <span class="string">&quot;enabled&quot;</span>: <span class="keyword">true</span>, </span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;nginx&quot;</span>, </span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;started&quot;</span>, </span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="firewalld-模块"><a href="#firewalld-模块" class="headerlink" title="firewalld 模块"></a>firewalld 模块</h2><p>一个动态防火墙管理工具<br><strong>1. <strong>state</strong>：设置规则的状态。<br>    - <code>enabled</code>：启用规则。<br>    - <code>disabled</code>：禁用规则。<br>2. <strong>permanent</strong>：设置规则是否永久生效。<br>    - <code>yes</code>：规则永久生效，重启后依然有效。<br>    - <code>no</code>：规则临时生效，重启后失效。<br>3. <strong>immediate</strong>：是否立即应用规则变更。<br>    - <code>yes</code>：立即应用规则变更。<br>    - <code>no</code>：规则变更将在下一次 <code>firewalld</code> 重启时生效。<br>4. <strong>service</strong>：指定要允许或拒绝的服务名称，例如 <code>http</code>、<code>https</code>、<code>ssh</code> 等。<br>5. <strong>port</strong>：指定要允许或拒绝的端口，可以是单个端口（如 <code>8080/tcp</code>）或端口范围（如 <code>1024-2048/tcp</code>）。</strong></p><pre><code><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#启动 firewalld 服务**：</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Start</span> <span class="string">firewalld</span> <span class="string">service</span></span><br><span class="line">  <span class="attr">ansible.builtin.firewalld:</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">started</span></span><br><span class="line">    <span class="string">enabled：</span> <span class="literal">yes</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#添加允许规则：</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Open</span> <span class="string">port</span> <span class="number">80</span> <span class="string">in</span> <span class="string">firewalld</span></span><br><span class="line">  <span class="attr">ansible.builtin.firewalld:</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">permanent:</span> <span class="literal">yes</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">enabled</span></span><br><span class="line">    <span class="attr">immediate:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure></code></pre><h2 id="Setup模块"><a href="#Setup模块" class="headerlink" title="Setup模块"></a>Setup模块</h2><p>使用<strong>setup模块</strong>获取被管理主机的所有facts信息，可以使用filter来查看指定的信息。setup模块获取的整个facts信息被包装在一个JSON格式的数据结构中，ansible_facts是最外层的值。我们可以通过以下Ansible Ad-Hoc命令查看facts信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m setup | grep hostname</span><br><span class="line"></span><br><span class="line"> ansible all -m setup -a &#x27;filter=&quot;ansible_nodename&quot;&#x27;   </span><br></pre></td></tr></table></figure><h1 id="四、playbook-剧本"><a href="#四、playbook-剧本" class="headerlink" title="四、playbook-剧本"></a>四、playbook-剧本</h1><h3 id="playbook格式"><a href="#playbook格式" class="headerlink" title="playbook格式"></a>playbook格式</h3><p><strong>playbook 是 ansible 用于配置，部署，和管理被控节点的剧本。</strong><code>类似于脚本</code></p><ol><li><code>-</code>和<code>:</code>后必须<font color="#ff0000">空一格</font></li><li>大小写敏感,使用缩进表示层级关系</li><li>缩进时不允许使用tab键、只允许使用空格</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li><li><strong>任务列表</strong>：每个任务前使用<code>-</code> 表示一个新的任务。</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---   </span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Example</span> <span class="string">playbook</span>  </span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">web：test</span>  <span class="comment"># 指定此 Play 将在哪些主机上运行</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">tasks:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">connect</span> <span class="string">test</span>  </span><br><span class="line">      <span class="attr">ping:</span>    </span><br><span class="line">  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">new</span> <span class="string">file</span>  </span><br><span class="line">      <span class="attr">file:</span> </span><br><span class="line">        <span class="attr">group:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="number">744</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/niki1/file1</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">touch</span> </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">#以上为普通形式，行数较多，但更容易操作。任务的关键字垂直堆叠，更容易区分。</span></span><br><span class="line">    <span class="comment">#以下可以运行但不推荐</span></span><br><span class="line">    <span class="attr">tasks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shorthand</span> <span class="string">form</span></span><br><span class="line">        <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">enabled=true</span> <span class="string">state=started</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure><h3 id="运行剧本"><a href="#运行剧本" class="headerlink" title="运行剧本"></a>运行剧本</h3><p>空运行 <code>ansible-playbook -C pb.yml</code></p><p>直接运行 <code>ansible-playbook pb.yml</code></p><p>语法验证 <strong><code>ansible-playbook --syntax-check pb.yml</code></strong></p><p>指定从某个task开始运行<code>ansible-playbook pb.yml --start-at-task=&#39;xxx&#39;</code>  </p><p><font color="#00b050">| 绿色代表执行成功，系统保持原样</font></p><p><font color="#ffff00">| 黄色代表系统代表系统状态发生改变</font></p><p><font color="#ff0000">| 红色代表执行失败，显示错误输出</font></p><h4 id="ansible-navigator容器中运行剧本"><a href="#ansible-navigator容器中运行剧本" class="headerlink" title="ansible-navigator容器中运行剧本"></a>ansible-navigator容器中运行剧本</h4><p>ansible-navigator 利用容器化的执行环境，用于与 Ansible Playbooks、Roles、Collections 等交互。<br>ansible-navigator run playbook.yml <span style="background:rgba(173, 239, 239, 0.55)">-m stdout</span><br>-<code>-m stdout</code>：这个选项指定输出模式为 <code>stdout</code>，即将执行结果输出到标准输出（终端），而不是使用交互式界面。</p><h3 id="Handler-notify-触发器"><a href="#Handler-notify-触发器" class="headerlink" title="Handler+notify-触发器"></a><strong>Handler+notify-触发器</strong></h3><p>在特定条件下触发；接收到其它任务的通知<code>notify</code>时被触发</p><p>Handlers 最佳的应用场景是用来重启服务,或者触发系统重启操作.除此以外很少用到了.</p><h3 id="Tag-标签"><a href="#Tag-标签" class="headerlink" title="Tag-标签"></a>Tag-标签</h3><p>为tasks或play添加标记，选择性地执行playbook的特定部分。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果命令或脚本的退出码不为零，可以使用如下方式替代</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="string">-name:</span> <span class="string">run</span> <span class="string">this</span> <span class="string">command</span> <span class="string">and</span> <span class="string">ignore</span> <span class="string">the</span> <span class="string">result</span></span><br><span class="line">   <span class="attr">shell:</span> <span class="string">/usr/bin/somecommand</span> <span class="string">||</span> <span class="string">/bin/true</span></span><br><span class="line"><span class="string">转错为正</span> <span class="string">如果命令失败则执行</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="string">或者使用ignore_errors来忽略错误信息</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="string">-name:</span> <span class="string">run</span> <span class="string">this</span> <span class="string">command</span> <span class="string">and</span> <span class="string">ignore</span> <span class="string">the</span> <span class="string">result</span></span><br><span class="line"> <span class="attr">shell:</span> <span class="string">/usr/bin/somecommand</span></span><br><span class="line"> <span class="attr">ignore_errors:</span> <span class="literal">True</span> <span class="string">忽略错误</span></span><br></pre></td></tr></table></figure><h3 id="Variable-变量"><a href="#Variable-变量" class="headerlink" title="Variable-变量"></a><strong>Variable-变量</strong></h3><p>变量名：仅能由字母、数字和下划线组成，且只能以字母开头<br>变量定义：直接定义  key&#x3D;value<br>根据变量的作⽤范围⼤体的将变量分为:</p><pre><code>全局变量剧本变量资产变量内置变量:内置变量⼏乎都是以 ansible_ 为前缀。系统自带事实变量facts：ansible setup模块   </code></pre><p>  ansible all -m setup -a ‘filter&#x3D;”ansible_nodename”‘     #查询主机名</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">.系统自带事实变量facts：ansible</span> <span class="string">setup模块</span>   </span><br><span class="line">  <span class="string">ansible</span> <span class="string">all</span> <span class="string">-m</span> <span class="string">setup</span> <span class="string">-a</span> <span class="string">&#x27;filter=&quot;ansible_nodename&quot;&#x27;</span>     <span class="comment">#查询主机名</span></span><br><span class="line">  </span><br><span class="line"><span class="number">2</span><span class="string">./etc/ansible/hosts(主机清单)中定义变量</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span><span class="string">.在playbook中定义</span></span><br><span class="line">       <span class="attr">vars:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">var1:</span> <span class="string">value1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">var2:</span> <span class="string">value2</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span><span class="string">.在独立的变量YAML文件中定义</span></span><br><span class="line"><span class="string">vim</span> <span class="string">vars.yml</span></span><br><span class="line"><span class="attr">pack:</span> <span class="string">vsftpd</span></span><br><span class="line"><span class="attr">service:</span> <span class="string">vsftpd</span></span><br><span class="line"></span><br><span class="line"><span class="string">引用变量文件</span></span><br><span class="line"><span class="attr">vars_files:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">vars.yml</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>变量调用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">通过&#123;&#123;</span> <span class="string">variable_name</span> <span class="string">&#125;&#125;</span> <span class="string">调用变量</span></span><br><span class="line"><span class="string">通过-e指定</span>  </span><br><span class="line"><span class="string">ansible-playbook</span> <span class="string">test.yml</span> <span class="string">-e</span> <span class="string">&quot;hosts=123&quot;</span></span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#调用变量文件   </span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">vars_log</span> <span class="string">file</span></span><br><span class="line">  <span class="attr">vars_files:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">/niki2/vars.yml</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">new</span> <span class="string">file</span></span><br><span class="line">      <span class="attr">file:</span></span><br><span class="line">         <span class="attr">path:</span> <span class="string">/niki1/&#123;&#123;</span> <span class="string">name1</span> <span class="string">&#125;&#125;_log.txt</span></span><br><span class="line">         <span class="attr">mode:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; mode1 &#125;&#125;</span>&quot;</span></span><br><span class="line">         <span class="attr">state:</span> <span class="string">touch</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Template-模板"><a href="#Template-模板" class="headerlink" title="Template-模板"></a><strong>Template-模板</strong></h3><p>根据模板文件<strong>动态</strong>生成对应的配置文件，命名必须以 <strong>.j2</strong> 结尾（<code>Jinja2</code>：Jinja2是python的一种模板语言）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">install</span> <span class="string">nginx</span>  <span class="comment">#安装nginx，若为centos7需要启用 EPEL 仓库</span></span><br><span class="line">      <span class="attr">yum:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">copy</span> <span class="string">template</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">/etc/ansible/templates/nginx.conf.j2</span> </span><br><span class="line">        <span class="comment">#nginx.conf.j2模板设置worker_processes 的值为   &#123;&#123; ansible_processor_vcpus*2&#125;&#125;;</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/etc/nginx/nginx.conf</span></span><br><span class="line">      <span class="attr">notify:</span> <span class="string">restart</span> <span class="string">service</span></span><br><span class="line">      </span><br><span class="line">     </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">service</span> <span class="string">start</span></span><br><span class="line">      <span class="attr">service:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">started</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">yes</span> <span class="comment">#开机自启</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">handlers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restart</span> <span class="string">service</span></span><br><span class="line">      <span class="attr">service:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure><h3 id="条件测试when与循环迭代-with-items"><a href="#条件测试when与循环迭代-with-items" class="headerlink" title="条件测试when与循环迭代  with_items"></a>条件测试when与循环迭代  with_items</h3><ul><li><p>when语句：在task中使用</p></li><li><p>循环：迭代，需要重复执行的任务；</p><p>  对迭代项的引用，固定变量名为”item”，而后，要在task中使用with_items给定要迭代的元素列表；</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">groups</span></span><br><span class="line">      <span class="attr">group:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; item &#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">with_items:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">group1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">group2</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">group3</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">users</span></span><br><span class="line">      <span class="attr">user:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; item.name &#125;&#125;</span>&quot;</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; item.group &#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">with_items:</span></span><br><span class="line">        <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">&#x27;u1&#x27;</span>,<span class="attr">group:</span> <span class="string">&#x27;group1&#x27;</span>&#125;</span><br><span class="line">        <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">&#x27;u2&#x27;</span>,<span class="attr">group:</span> <span class="string">&#x27;group2&#x27;</span>&#125;</span><br><span class="line">        <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">&#x27;u3&#x27;</span>,<span class="attr">group:</span> <span class="string">&#x27;group3&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="五、roles-角色"><a href="#五、roles-角色" class="headerlink" title="五、roles-角色"></a>五、roles-角色</h1><p>用于<strong>层次性，结构化</strong>地组织playbook<br>roles通过分别将变量(vars)、文件(file)、任务(tasks)、模块(modules)及处理器(handlers)放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中。 </p><h3 id="创建role"><a href="#创建role" class="headerlink" title="创建role"></a>创建role</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible-galaxy init my_role</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="安装roels"><a href="#安装roels" class="headerlink" title="安装roels"></a>安装roels</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">直接从galaxy安装</span></span><br><span class="line">ansible-galaxy install &lt;role_name&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从 requirements.yml 文件安装多个角色</span></span><br><span class="line">vim requirements.yml</span><br><span class="line"></span><br><span class="line">- src: geerlingguy.apache</span><br><span class="line">- src: geerlingguy.mysql</span><br><span class="line">- </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装</span></span><br><span class="line">ansible-galaxy install -r requirements.yml</span><br><span class="line">---</span><br><span class="line"> - name: webservers role</span><br><span class="line">   hosts: webservers</span><br><span class="line">   roles:</span><br><span class="line"> - apache</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="六、collection-集合"><a href="#六、collection-集合" class="headerlink" title="六、collection-集合"></a>六、collection-集合</h1><p>Collection 是一个更高级的封装，包含多个 Roles、模块、插件等，允许用户更全面地共享和分发自动化内容。它可以包含多个功能模块，适用于更复杂的项目。</p><h2 id="如何使用-Ansible-Collections"><a href="#如何使用-Ansible-Collections" class="headerlink" title="如何使用 Ansible Collections"></a>如何使用 Ansible Collections</h2><h3 id="1、安装-Collection"><a href="#1、安装-Collection" class="headerlink" title="1、安装 Collection"></a>1、安装 Collection</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以从 Ansible Galaxy 或其他来源安装 Collection：</span></span><br><span class="line">ansible-galaxy collection install &lt;namespace&gt;.&lt;collection_name&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">也可以从本地目录或通过 requirements.yml 文件安装collection：</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、Playbook-中使用-Collection"><a href="#2、Playbook-中使用-Collection" class="headerlink" title="2、Playbook 中使用 Collection"></a>2、Playbook 中使用 Collection</h3><p>在你的 playbook.yml 文件中，你可以指定要使用的 Collection：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Example</span> <span class="string">Playbook</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">collections:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">my_namespace.my_collection</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Example</span> <span class="string">task</span></span><br><span class="line">      <span class="attr">my_namespace.my_collection.my_module:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br></pre></td></tr></table></figure><h3 id="3、管理-Collection"><a href="#3、管理-Collection" class="headerlink" title="3、管理 Collection"></a>3、管理 Collection</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出已安装的 Collection：</span></span><br><span class="line">ansible-galaxy collection list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">卸载 Collection：</span></span><br><span class="line">ansible-galaxy collection uninstall my_namespace.my_collection</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用-requirements-yml-文件管理-Collection"><a href="#使用-requirements-yml-文件管理-Collection" class="headerlink" title="使用 requirements.yml 文件管理 Collection"></a>使用 requirements.yml 文件管理 Collection</h3><blockquote><p>[!success] Title<br>创建一个 requirements.yml 文件来管理 Collection </p><p>collections模块中name通常为集合名字。<strong>如果直接提供 URL，格式为完整的链接。</strong></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">collections:</span><br><span class="line">  - name: my_namespace.my_collection</span><br><span class="line">    source: https://my.custom.repo/path/to/collection/</span><br><span class="line">    version: 1.0.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然后使用以下命令安装所有 Collection：</span></span><br><span class="line">ansible-galaxy collection install -r requirements.yml </span><br><span class="line"></span><br><span class="line">-r, --requirements</span><br><span class="line">从指定的 requirements 文件中安装 Collections。</span><br><span class="line"></span><br><span class="line">-p, --collections-path</span><br><span class="line">指定安装 Collections 的目录。如果没有指定，默认安装到系统的 Ansible Collections 路径。</span><br></pre></td></tr></table></figure><h1 id="七、ansible-galaxy"><a href="#七、ansible-galaxy" class="headerlink" title="七、ansible galaxy"></a>七、ansible galaxy</h1><p><a href="https://galaxy.ansible.com/ui/search/">https://galaxy.ansible.com/ui/search/</a><br>Ansible Galaxy 是一个在线平台，提供一个广泛的 Ansible 资源库，包括 <strong>角色（roles）</strong>、<strong>集合（collections）</strong> 和其他自动化内容。用户可以通过 Galaxy 搜索、下载和分享这些资源。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装角色</span></span><br><span class="line">ansible-galaxy role install &lt;role_name&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出已安装的角色或集合：</span></span><br><span class="line">ansible-galaxy role list</span><br></pre></td></tr></table></figure><h1 id="八、debug-msg"><a href="#八、debug-msg" class="headerlink" title="八、debug  msg"></a>八、debug  msg</h1><p>在Ansible中，<code>debug</code>模块是一个非常有用的工具，它允许你在执行任务时输出变量的值或执行过程中的信息。这对于调试和理解你的Ansible playbooks的执行流程非常有用。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li><p><strong>基本用法</strong>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Print</span> <span class="string">a</span> <span class="string">debug</span> <span class="string">message</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">&quot;This is a debug message&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>输出变量</strong>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Print</span> <span class="string">the</span> <span class="string">value</span> <span class="string">of</span> <span class="string">a</span> <span class="string">variable</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">&quot;The value of my_var is <span class="template-variable">&#123;&#123; my_var &#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>条件输出</strong>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Print</span> <span class="string">a</span> <span class="string">message</span> <span class="string">if</span> <span class="string">a</span> <span class="string">condition</span> <span class="string">is</span> <span class="string">met</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">msg:</span> <span class="string">&quot;This will only print if the condition is true&quot;</span></span><br><span class="line">  <span class="attr">when:</span> <span class="string">my_condition</span> <span class="string">is</span> <span class="string">defined</span> <span class="string">and</span> <span class="string">my_condition</span></span><br></pre></td></tr></table></figure></li><li><p><strong>输出变量内容</strong>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Print</span> <span class="string">the</span> <span class="string">content</span> <span class="string">of</span> <span class="string">a</span> <span class="string">variable</span></span><br><span class="line">  <span class="attr">debug:</span></span><br><span class="line">    <span class="attr">var:</span> <span class="string">my_var</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><ul><li><strong>在每个任务后添加debug模块</strong>: 这可以帮助你跟踪变量的值和任务的执行状态。</li><li><strong>使用<code>when</code>条件</strong>: 只在特定条件下输出信息，避免不必要的输出。</li><li><strong>使用<code>verbosity</code></strong>: 通过增加verbosity级别，可以输出更多的调试信息。在命令行中使用<code>-v</code>或<code>-vv</code>参数。</li></ul><h1 id="九、ansible-vault"><a href="#九、ansible-vault" class="headerlink" title="九、ansible-vault"></a>九、ansible-vault</h1><p><code>ansible-vault</code> 是一个用于加密和解密敏感数据的工具。它允许你以加密的形式存储敏感信息，如密码、密钥或任何其他敏感数据，以确保这些信息在Playbooks和变量文件中不会被暴露。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 自动化运维工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> 运维 </tag>
            
            <tag> #Automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux用户与组管理</title>
      <link href="/2024/03/30/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%BB%84%E7%AE%A1%E7%90%86/"/>
      <url>/2024/03/30/%E7%94%A8%E6%88%B7%E4%B8%8E%E7%BB%84%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="用户与组管理"><a href="#用户与组管理" class="headerlink" title="用户与组管理"></a>用户与组管理</h2><h3 id="useradd创建用户"><a href="#useradd创建用户" class="headerlink" title="useradd创建用户"></a>useradd创建用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">常用选项：</span><br><span class="line">-u 指定用户UID</span><br><span class="line">-d 指定用户家目录</span><br><span class="line">-c --comment用户描述信息</span><br><span class="line">-g 指定用户gid</span><br><span class="line">-G 指定用户附加组（次要组）</span><br><span class="line">-s --shell指定用户的解释器程序   </span><br><span class="line">⽆权访问系统上的交互式shell：/sbin/noloogin   /bin/false</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建用户指定用户UID、描述信息、附加组</span></span><br><span class="line">[root@localhost ~]# useradd -u 1600 -c yunwei -G <span class="built_in">test</span> xiaozhang</span><br><span class="line">[root@localhost ~]# <span class="built_in">id</span> xiaozhang</span><br><span class="line">uid=1600(xiaozhang) gid=1600(xiaozhang) 组=1600(xiaozhang),1401(<span class="built_in">test</span>)</span><br></pre></td></tr></table></figure><h3 id="groupadd创建组"><a href="#groupadd创建组" class="headerlink" title="groupadd创建组"></a>groupadd创建组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建组</span></span><br><span class="line"> groupadd -g GID   <span class="comment">#指定组的GID</span></span><br><span class="line">[root@localhost ~]# groupadd -g 1555 student</span><br></pre></td></tr></table></figure><h3 id="chgrp改变文件或目录所属组"><a href="#chgrp改变文件或目录所属组" class="headerlink" title="chgrp改变文件或目录所属组"></a>chgrp改变文件或目录所属组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看文件或目录所属组</span></span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line"></span><br><span class="line"><span class="built_in">chgrp</span> [选项] [所属组] 文件/目录</span><br><span class="line">--reference=RFILE  使用参考文件的所属组</span><br><span class="line">-R  递归的更改目录下的所有目录以及文件</span><br><span class="line"></span><br><span class="line"><span class="built_in">chgrp</span> group1 /etc/niki</span><br><span class="line"></span><br><span class="line">sgid：给目录设置了sgid权限，在该目录下创建的文件或者目录的**属组**都与该目录一致</span><br><span class="line"></span><br><span class="line">授权格式：</span><br><span class="line"><span class="built_in">chmod</span> g+s 文件名称</span><br><span class="line">撤销格式：</span><br><span class="line"><span class="built_in">chmod</span> g-s 文件名称</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="chown归属关系管理"><a href="#chown归属关系管理" class="headerlink" title="chown归属关系管理"></a>chown归属关系管理</h3><p>chown（英文全拼：change owner）用于设置文件的所有者和所属组关系</p><ul><li>命令格式：<ul><li>chown [-选项] 所有者:所属组 文档</li><li>chown [-选项] 所有者 文档</li><li>chown [-选项] :所属组 文档</li></ul></li><li>常用选项:<ul><li><code>R</code> 递归地改变指定目录及其子目录和文件的所有者</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改文件所有者与所属组为lisi</span></span><br><span class="line">[root@localhost ~]# <span class="built_in">chown</span> lisi:lisi /hello.txt </span><br></pre></td></tr></table></figure><h3 id="id查看信息"><a href="#id查看信息" class="headerlink" title="id查看信息"></a>id查看信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# <span class="built_in">id</span> user1</span><br><span class="line">uid=1001(user1) gid=1001(user1) 组=1001(user1)</span><br></pre></td></tr></table></figure><h3 id="passwd修改密码"><a href="#passwd修改密码" class="headerlink" title="passwd修改密码"></a>passwd修改密码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置用户密码</span></span><br><span class="line">[root@localhost ~]# passwd user1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 密码 |passwd --stdin user1</span><br></pre></td></tr></table></figure><h3 id="etc-passwd用户信息文件"><a href="#etc-passwd用户信息文件" class="headerlink" title="&#x2F;etc&#x2F;passwd用户信息文件"></a>&#x2F;etc&#x2F;passwd用户信息文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">**[root@localhost ~]# vim /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line"><span class="comment">#每个字段含义解释：用户名:密码占位符:UID:基本组GID:用户描述信息:家目录:解释器程序</span></span><br><span class="line">UID：0 超级用户</span><br><span class="line">UID：1-999 系统伪用户，不能登录系统</span><br><span class="line">UID：1000-65535 普通用户，管理员创建的用户**</span><br></pre></td></tr></table></figure><h3 id="wheel用户组"><a href="#wheel用户组" class="headerlink" title="wheel用户组"></a>wheel用户组</h3><p><a href="https://www.cnblogs.com/linuxshare/p/18609179">linux中的wheel用户 - 爱折腾的大臭臭 - 博客园</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS-16【 网络】Route 53-域名系统</title>
      <link href="/2023/08/17/AWS-16%E3%80%90%20%E7%BD%91%E7%BB%9C%E3%80%91Route%2053-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/08/17/AWS-16%E3%80%90%20%E7%BD%91%E7%BB%9C%E3%80%91Route%2053-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Amazon-Route-53"><a href="#Amazon-Route-53" class="headerlink" title="Amazon Route 53"></a><strong>Amazon Route 53</strong></h1><p><img src="/images/Untitled%20165.png" alt="Untitled"></p><ul><li>“Route 53”是指传统DNS使用的端口号（53）</li></ul><ol><li><strong>域名解析</strong>：Route 53 允许您将域名映射到各种 AWS 资源，如 **Amazon S3 存储桶、Amazon EC2 实例、Elastic Load Balancer（ELB）**等。您可以配置 DNS 记录，将用户输入的域名转换为 IP 地址，从而使用户能够通过域名访问您的资源。</li><li><strong>高可用和可靠性</strong>：Route 53 提供全球分布的 DNS 服务，具有高可用性和可靠性。它将自动将 DNS 记录分发到多个全球边缘位置，以确保用户能够就近访问资源，提高响应速度和可用性。</li><li><strong>负载均衡</strong>：Route 53 可与 Amazon Elastic Load Balancing 集成，实现负载均衡。您可以配置 DNS 记录，将流量分发到不同的负载均衡器，以实现高可用性和性能优化。</li></ol><ul><li>能够检查您的资源的健康状态</li><li><strong>100% SLA保证</strong>：Route 53是唯一一个AWS服务提供100%可用性的服务级别协议（SLA）。</li></ul><h3 id="“Route-53-Active-Passive”"><a href="#“Route-53-Active-Passive”" class="headerlink" title="“Route 53 Active-Passive”"></a>“Route 53 Active-Passive”</h3><p>是一种架构配置，主要用于实现高可用性和故障恢复。</p><p>在 Active-Passive 配置中，我们通常考虑系统中的两种状态：活动状态（Active）和待命状态（Passive）。</p><ul><li><strong>活动状态（Active）：</strong> 这是系统中当前正在提供服务的状态。在一个 “Route 53 Active-Passive” 配置中，活动状态通常指向一个实际提供服务的资源，比如一个服务器、虚拟机实例或应用程序。</li><li><strong>待命状态（Passive）：</strong> 这是系统中备用的、处于待命状态的资源。它不提供实际的服务，而是等待在活动状态不可用时接管服务。待命状态的资源会与活动状态资源保持同步，以确保数据的一致性。</li></ul><h3 id="Route-53故障转移的关键点如下："><a href="#Route-53故障转移的关键点如下：" class="headerlink" title="Route 53故障转移的关键点如下："></a><strong>Route 53故障转移</strong>的关键点如下：</h3><ol start="4"><li><strong>Failover Routing Policy</strong>：Route 53的Failover路由策略允许您配置主&#x2F;备份资源，以便在主资源不可用时自动将流量切换到备份资源。例如，您可以将流量引导到主要AWS区域中的资源，但如果该区域发生故障，Route 53可以将流量切换到另一个备份区域中的资源。</li><li><strong>Health Checks</strong>：您可以设置Route 53的健康检查来监控各个资源的可用性。当主资源不可用时，健康检查可以自动触发Route 53的Failover策略，将流量切换到备份资源。</li><li><strong>Global Accelerator Integration</strong>：Route 53可以与AWS Global Accelerator结合使用，以提供全球级别的流量管理和故障转移。Global Accelerator可以优化全球范围内的流量分发，确保将用户流量快速引导到最近的健康资源。</li><li><strong>Latency-Based Routing</strong>：虽然不直接是故障转移，但根据延迟的路由策略可以确保将用户流量引导到距离最近且延迟最低的资源，从而提高用户体验并减少延迟。</li></ol><h3 id="Routing-Policies-路由策略"><a href="#Routing-Policies-路由策略" class="headerlink" title="Routing Policies-路由策略"></a>Routing Policies-<strong>路由策略</strong></h3><ul><li><p>Defines how Route53 responds to DNS queries</p><p>  定义了如何将 DNS 查询路由到资源</p><p>  以下是展示 Amazon Route 53 不同路由策略及其特点和适用场景的表格：</p><table><thead><tr><th>路由策略</th><th>特点和适用场景</th></tr></thead><tbody><tr><td>简单路由策略（Simple）</td><td>流量路由到一个资源</td></tr><tr><td>权重路由策略（Weighted）</td><td>- 按照权重分配到不同资源</td></tr><tr><td>故障转移路由策略（Failover）</td><td>- 当活动实例<strong>未通过健康检查</strong>时，备用实例将接管并成为活动实例</td></tr><tr><td>基于延迟的路由策略（Latency）</td><td>- 重定向到距离用户最近的资源，适用于要求<strong>低延迟的全球性应用</strong>。</td></tr><tr><td>地理位置路由策略（Geolocation）</td><td>- 基于用户位置进行路由</td></tr><tr><td>多值路由策略（Multivalue）</td><td>- 用于将流量路由到多个资源</td></tr></tbody></table><p>  这个表格展示了 Amazon Route 53 不同的路由策略，以及每个策略的特点和适用场景。希望这能够帮助您更清楚地了解每种路由策略的用途和优势。</p></li></ul><h3 id="Simple-Routing（简单路由）"><a href="#Simple-Routing（简单路由）" class="headerlink" title="Simple Routing（简单路由）:"></a><strong>Simple Routing</strong>（简单路由）:</h3><ul><li>返回单个资源的所有记录</li><li>如果返回了多个相同记录的值，则客户端将随机选择一个</li><li>不能与健康检查相关联</li></ul><h3 id="Weighted-Routing（加权路由）"><a href="#Weighted-Routing（加权路由）" class="headerlink" title="Weighted Routing（加权路由）:"></a><strong>Weighted Routing</strong>（加权路由）:</h3><ul><li>control traffic by weight</li><li>can be associated with Health Checks</li><li>Assign a weight of 0 to a record to stop sending traffic to a resource • If all records have we</li><li><strong>按照权重分配到不同资源</strong></li><li>按权重控制流量</li><li>可以与健康检查相关联</li><li>将记录的权重分配为0，以停止向资源发送流量</li><li>如果所有记录的权重都为0，则不会向该资源发送流量</li></ul><h3 id="Failover-Routing（故障转移路由）"><a href="#Failover-Routing（故障转移路由）" class="headerlink" title="Failover Routing（故障转移路由）:"></a><strong>Failover Routing</strong>（故障转移路由）:</h3><ul><li>When an active instance failed the health check, the standby instance will failover and become active</li></ul><p>当<strong>活动实例未通过健康检查时，备用实例将接管并成为活动实例。</strong></p><h3 id="Latency-based-Routing（基于延迟的路由）"><a href="#Latency-based-Routing（基于延迟的路由）" class="headerlink" title="Latency-based Routing（基于延迟的路由）:"></a><strong>Latency-based Routing</strong>（基于延迟的路由）:</h3><ul><li>Redirect to the resource that has the least latency close to user</li><li>Latency is based on traffic between users and AWS Regions</li><li>Can be associated with Health Checks</li><li>重定向到距离用户最近的资源</li><li>延迟基于用户和AWS区域之间的流量</li><li>可以与健康检查相关联</li></ul><h3 id="Geolocation-Routing（地理位置路由）"><a href="#Geolocation-Routing（地理位置路由）" class="headerlink" title="Geolocation Routing（地理位置路由）:"></a><strong>Geolocation Routing</strong>（地理位置路由）:</h3><ul><li>This routing is based on user location</li><li>Can be associated with Health Checks</li></ul><h3 id="Multi-Value-Answer-Routing（多值回答路由）"><a href="#Multi-Value-Answer-Routing（多值回答路由）" class="headerlink" title="Multi-Value Answer Routing（多值回答路由）:"></a><strong>Multi-Value Answer Routing</strong>（多值回答路由）:</h3><ul><li>Use when routing traffic to multiple resources</li><li>Each resource receives a separate DNS response, and Route 53 responds to DNS queries with multiple IP addresses.</li><li>Can be associated with Health Checks (return only values for healthy resources)</li><li>用于将流量路由到多个资源</li><li>每个资源都会收到单独的 DNS 响应，并且 Route 53 会用多个 IP 地址响应 DNS 查询。</li><li>可以与健康检查相关联（仅返回健康资源的值）</li><li>有助于实现<strong>负载均衡</strong>和<strong>高可用性</strong>。</li></ul><h3 id="Geoproximity-Routing（地理接近路由）"><a href="#Geoproximity-Routing（地理接近路由）" class="headerlink" title="Geoproximity Routing（地理接近路由）:"></a><strong>Geoproximity Routing</strong>（地理接近路由）:</h3><ul><li>Route traffic to your resources based on the geographic location of users and resources</li><li>Ability to shift more traffic to resources based on the defined bias</li></ul><h3 id="Route-53-–-Records记录集"><a href="#Route-53-–-Records记录集" class="headerlink" title="Route 53 – Records记录集"></a><strong>Route 53 – Records</strong>记录集</h3><p>用于将域名映射到特定资源（例如IP地址、其他域名或负载均衡器）的信息</p><ul><li><strong>Domain&#x2F;subdomain Name</strong> – e.g., example.com</li><li><strong>Record Type</strong> – e.g., A or AAAA</li><li><strong>Value</strong> – e.g., 12.34.56.78</li><li><strong>Routing Policy</strong> – how Route 53 responds to queries</li><li><strong>TTL（time to live）</strong> – amount of time the record cached at DNS Resolvers</li></ul><h3 id="Record-Types-记录类型"><a href="#Record-Types-记录类型" class="headerlink" title="Record Types-记录类型"></a><strong>Record Types-记录类型</strong></h3><ul><li><strong>A</strong> – maps a hostname to IPv4</li><li><strong>AAAA</strong> – maps a hostname to IPv6</li><li><strong>CNAME</strong> – maps a hostname to another hostname<ul><li>The target is a domain name which must have an A or AAAA record</li><li>Can’t create a CNAME record for the top node of a DNS namespace (Zone Apex)</li><li>Example: you can’t create for example.com, but you can create for <a href="http://www.example.com/">www.example.com</a></li></ul></li><li><strong>NS</strong> – Name Servers for the Hosted Zone<ul><li>Control how traffic is routed for a domain</li></ul></li></ul><h3 id="hosted-zone-托管区域"><a href="#hosted-zone-托管区域" class="headerlink" title="hosted zone-托管区域"></a>hosted zone-托管区域</h3><p>Hosted Zone（托管区域）是一个与特定域名（例如 <a href="http://example.com/">example.com</a>）关联的 DNS 区域。它包含了该域名下所有 DNS 记录的信息，用于解析域名到相应的 IP 地址或其他资源。</p><p><strong>一个包含定义如何路由流量到域名及其子域名的记录的容器</strong></p><ul><li><strong>公有托管区域</strong><ul><li>包含指定如何在互联网上路由流量的记录</li></ul></li><li><strong>私有托管区域</strong><ul><li>包含指定如何在一个或多个VPC中路由流量的记录</li></ul></li><li>每个托管区域每月收取0.5美元的费用</li></ul><h3 id="Alias-Records-别名记录"><a href="#Alias-Records-别名记录" class="headerlink" title="Alias Records-别名记录"></a>Alias Records-<strong>别名记录</strong></h3><ul><li>将主机名映射到AWS资源</li><li>别名记录始终为AWS资源的类型A&#x2F;AAAA（IPv4&#x2F;IPv6）</li><li>您无法设置TTL, route53自动设置</li><li>您无法为EC2 DNS名称设置别名记录</li><li>You cannot set an ALIAS record for an EC2 DNS name</li></ul><h3 id="Health-Checks-健康检查"><a href="#Health-Checks-健康检查" class="headerlink" title="Health Checks-健康检查"></a>Health Checks-健康检查</h3><ul><li>HTTP Health Checks are only for public resources</li><li>Health Check &#x3D;&gt; Automated DNS Failover</li><li>健康检查与CloudWatch指标集成</li><li>配置路由器&#x2F;防火墙以允许来自Route 53 Health Checkers的传入请求</li></ul><h3 id="Health-checks-that-monitor-an-endpoint"><a href="#Health-checks-that-monitor-an-endpoint" class="headerlink" title="Health checks that monitor an endpoint"></a><strong>Health checks that monitor an endpoint</strong></h3><p>您可以配置运行状况检查来监控通过 IP 地址或域名指定的端点。Route 53 按照您指定的固定间隔，通过互联网向您的应用程序、服务器或其它资源自动提交请求，以验证其是否可到达、是否可用及功能是否正常。您也可以通过配置运行状况检查来发出与用户发出的请求类似的请求，如从特定 URL 请求网页。</p><h3 id="calculated-health-checks"><a href="#calculated-health-checks" class="headerlink" title="calculated health checks"></a><strong>calculated health checks</strong></h3><ul><li>Combine the results of multiple Health Checks into a single Health Check</li><li>You can use OR, AND, or NOT</li><li>Can monitor up to 256 Child Health Checks</li><li>Specify how many of the health checks need to pass to make the parent pass</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS-12【 architecture】选择合适database</title>
      <link href="/2023/08/16/AWS-12%E3%80%90%20architecture%E3%80%91%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82database/"/>
      <url>/2023/08/16/AWS-12%E3%80%90%20architecture%E3%80%91%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82database/</url>
      
        <content type="html"><![CDATA[<h1 id="选择合适database"><a href="#选择合适database" class="headerlink" title="选择合适database"></a>选择合适database</h1><p><img src="/images/Untitled%2050.png" alt="Untitled"></p><p><strong>Online Transaction Processing”（在线事务处理）</strong></p><p>它是一种数据库处理方式，用于处理实时交易和事务。OLTP系统旨在支持并发的数据库操作，通常用于处理大量短期和频繁的交易请求，例如在线购买、银行交易、航班预订等。</p><p>OLTP系统通常具有以下特点：</p><ul><li>快速的读写操作：用于处理实时交易，需要快速响应和处理数据库记录的插入、更新和查询操作。</li><li>事务支持：OLTP系统必须支持ACID属性（原子性、一致性、隔离性和持久性），确保数据库的完整性和一致性。</li><li>高并发性：OLTP系统通常面对许多用户同时进行交易，需要能够处理高并发的请求。</li><li>精细的数据模型：OLTP系统的数据模型通常是规范化的，以减少数据冗余并提高查询性能。</li><li>实时数据访问：OLTP系统提供实时数据访问，允许用户即时获取最新的交易信息。</li></ul><h3 id="适用于OLTP的AWS服务："><a href="#适用于OLTP的AWS服务：" class="headerlink" title="适用于OLTP的AWS服务："></a>适用于OLTP的AWS服务：</h3><ol><li><strong>Amazon RDS</strong>（Relational Database Service）：支持多种关系型数据库引擎，适用于在线交易处理和实时事务。</li><li><strong>Amazon Aurora</strong>：是RDS的一个变种，专为OLTP工作负载而设计，具有高性能和高可用性。</li><li><strong>Amazon DynamoDB</strong>：全托管的NoSQL数据库，适用于高度可扩展的实时交易处理和高并发操作。</li><li><strong>Amazon ElastiCache</strong>：提供托管的内存缓存服务，加速读取操作，适用于缓存频繁读取的交易数据。</li></ol><h3 id="RDBMS"><a href="#RDBMS" class="headerlink" title="RDBMS"></a>RDBMS</h3><p>代表关系数据库管理系统（Relational Database Management System），是一种基于关系型数据库模型的软件系统。它是用于管理和操作关系型数据库的专用软件。</p><p>在RDBMS中，数据以表格的形式组织，每个表格由行和列组成。每行代表一个记录，每列代表记录的属性或字段。RDBMS使用结构化查询语言（SQL）来操作和查询数据库中的数据。</p><p>RDBMS具有以下特点：</p><ol><li><strong>表格结构</strong>：数据以表格形式存储，每个表格有唯一的名称，并定义了数据的结构和约束。</li><li><strong>关系</strong>：不同表格之间可以建立关系，通过使用主键和外键来连接数据。</li><li><strong>数据完整性</strong>：RDBMS支持定义数据完整性规则，确保数据的一致性和准确性。</li><li><strong>事务支持</strong>：RDBMS支持事务处理，保证数据的原子性、一致性、隔离性和持久性（ACID属性）。</li><li><strong>并发控制</strong>：RDBMS能够处理多用户同时对数据库进行读写的情况，并确保数据的一致性和可靠性。</li><li><strong>查询语言</strong>：通过使用SQL，用户可以方便地查询和操作数据库中的数据。</li></ol><p>常见的RDBMS包括MySQL、Oracle Database、Microsoft SQL Server、PostgreSQL和IBM DB2等。RDBMS被广泛用于企业和组织中，用于管理和存储大量结构化数据，如业务数据、客户信息、交易记录等。</p><h2 id="Amazon-RDS"><a href="#Amazon-RDS" class="headerlink" title="Amazon RDS"></a>Amazon RDS</h2><ul><li>Managed PostgreSQL&#x2F; MySOL &#x2F; Oracle&#x2F; SOL Server&#x2F; MariaDB &#x2F; Custom<ul><li><p>Provisioned RDS Instance Size and EBS Volume Type &amp; Size</p></li><li><p>Auto-scaling capability for Storage</p></li><li><p>Support for Read Replicas and Multi AZ</p></li><li><p>Security through lAM, Security Groups, KMS, SSL in transit</p></li><li><p>Automated Backup with Point in time restore feature (up to 35 days)</p></li><li><p>Manual DB Snapshot for longer-term recovery</p></li><li><p>Managed and Scheduled maintenance (with downtime)</p></li><li><p>Support for IAM Authentication, integration with Secrets Manager</p></li><li><p>RDS Custom for access to and customize the underlying instance (Oracle &amp; SQL Server)</p></li><li><p>Use case: Store relational datasets (RDBMS &#x2F; OLTP), perform SQL queries, transactions</p></li></ul></li><li>为 RDS 实例大小和 EBS 卷类型和大小提供支持</li><li>存储Auto-scaling capability</li><li>支持 Read Replicas and Multi AZ</li><li>通过IAM、安全组、KMS,SSL实现安全性传输</li><li><strong>自动备份，具备点时间还原功能（长达35天）</strong></li><li>用于长期恢复的手动DB Snapshot</li><li>管理和定期维护（with downtime）</li><li>支持IAM认证，与Secrets Manager 集成</li><li>RDS Custom 用于访问和自定义底层实例（Oracle 和 SQL Server）</li></ul><aside>🍋 use case：存储关系数据集（RDBMS/ OLTP），执行SQL查询，事务</aside><h2 id="Amazon-Aurora"><a href="#Amazon-Aurora" class="headerlink" title="Amazon Aurora"></a>Amazon Aurora</h2><ul><li><p>Compatible API for PostgreSQL &#x2F; MySQL, separation of storage and compute</p><ul><li>Storage: data is stored in 6 replicas, across 3 AZ -highly available, self-healing, auto-scaling</li><li>Compute: Cluster of DB Instance across multiple AZ, auto-scaling of Read Replicas</li><li>Cluster: Custom endpoints for writer and reader DB instances</li><li>Same security &#x2F; monitoring&#x2F; maintenance features as RDS</li><li>Know the backup &amp; restore options for Aurora</li><li><strong>Aurora Serverless</strong> - for unpredictable &#x2F; intermittent workloads, no capacity planning</li><li><strong>Aurora Multi-Master</strong> - for continuous writes failover (high write availability)</li><li><strong>Aurora Global</strong>: up to 16 DB Read instances in each region, &lt; I second storage replication</li><li><strong>Aurora Machine Learning:</strong> perform ML using SageMaker &amp; Comprehend on Aurora</li><li><strong>Aurora Database Cloning</strong>: new cluster from existing one, faster than restoring a snapshot</li><li>Use case: same as RDS,but with less maintenance &#x2F; more flexibility &#x2F; more performance &#x2F; more features</li></ul><p>  <img src="/images/Untitled%2051.png" alt="Untitled">  </p></li><li><p>兼容的 PostgreSQL &#x2F; MySQL API，存储和计算分离</p></li><li><p>存储：数据存储在6个副本中，跨越3个可用区, 高可用、自我修复、自动扩展</p></li><li><p>计算：Cluster of DB Instance across multiple AZ,， auto-scaling of Read Replicas</p></li><li><p>集群:编写器和阅读器DB实例的自定义终端节点</p></li><li><p>与RDS相同的安全&#x2F;监控&#x2F;维护功能</p></li><li><p>了解Aurora的备份和恢复选项</p></li><li><p><strong>Aurora Serverless</strong> - 适用于不可预测&#x2F;<strong>间歇性</strong>工作负载，<strong>无需容量规划</strong></p></li><li><p><strong>Aurora Multi-Master</strong> - for continuous writes failover 用于连续写入故障转移（高写入可用性）</p></li><li><p><strong>Aurora Global</strong>：在每个区域中最多有16个DB读取实例，storage replication存储复制小于1秒</p></li><li><p><strong>Aurora Machine Learning</strong>：使用SageMaker和Comprehend在Aurora上执行ML</p></li><li><p><strong>Aurora Database Cloning</strong>：从现有集群创建新集群，比恢复快</p>  <aside>  🍋 use case：与RDS相同，但维护较少/更灵活/性能更好/具有更多功能AZ    </aside></li></ul><h2 id="Amazon-ElastiCache"><a href="#Amazon-ElastiCache" class="headerlink" title="Amazon ElastiCache"></a>Amazon ElastiCache</h2><ul><li><p>Managed Redis&#x2F; Memcached (similar offering as RDS, but for caches)</p><ul><li>In-memory data store, sub-millisecond latency</li><li>Must provision an EC2 instance type</li><li>Support for Clustering (Redis) and Multi AZ, Read Replicas (sharding)</li><li>Security through IAM, Security Groups, KMS, Redis Auth</li><li>Backup &#x2F; Snapshot &#x2F; Point in time restore feature</li><li>Managed and Scheduled maintenance</li><li><strong>Requires some application code changes to be leveraged</strong></li></ul>  <aside>  🍋 Use Case: Key/Value store, Frequent reads, less writes, cache results for DB queries, store session data for websites, cannot use SQL    </aside>  <p>  <img src="/images/Untitled%2052.png" alt="Untitled">  </p></li><li><p>内存数据存储，<strong>亚毫秒延迟sub-millisecond latency</strong></p></li><li><p>compatible with Redis or Memcached.</p></li><li><p>必须预配EC2实例类型</p></li><li><p>支持集群（Redis）和多AZ，读取副本（分片）Read Replicas (sharding)</p></li><li><p>通过IAM，Security Groups，KMS，Redis Auth实现安全性</p></li><li><p>备份&#x2F;快照&#x2F;时间点恢复功能</p></li><li><p>托管和计划维护</p></li><li><p><strong>需要更改应用程序代码才能利用</strong></p></li></ul><aside>🍋 用例：键/值存储，频繁读取，较少写入，缓存DB查询结果，存储网站会话数据，无法使用SQL</aside><h2 id="Amazon-DynamoDB"><a href="#Amazon-DynamoDB" class="headerlink" title="Amazon DynamoDB"></a>Amazon DynamoDB</h2><ul><li><p>AWS proprietary technology,managed serverless NoSOL database, milisecond latency</p><ul><li>Capacity modes: provisioned capacity with optional auto-scaling or on-demand capacity</li><li>Can replace ElastiCache as a key&#x2F;value store (storing session data for example, using TL feature)</li><li>Highly Available, Multi AZ by default, Read and Writes are decoupled, transaction capability</li><li>DAX cluster for read cache, microsecond read latency</li><li>Security authentication and authorization is done through IAM</li><li>Event Processing: DynamoDB Streams to integrate with AWS Lambda, or Kinesis Data Streams</li><li>Global Table feature; active -active setup</li><li>Autorated backups up to 35 days with PITR (restore to new table), or on demand backups Export to S3 without using RCU within the PITR, window, import from S3 without using WCU• Great to rapidly evolve schemas</li></ul>  <aside>  🍋 Use Case: Serverless applications development (small documents 100s KB), distributed serverless       cache, doesn't have SOL query language available    </aside>  <p>  <img src="/images/Untitled%2053.png" alt="Untitled"></p></li></ul><p><img src="/images/Untitled%2054.png" alt="Untitled"></p><ul><li>Amazon DynamoDB is a key-value, document, NoSQL database.</li><li>AWS专有技术，托管无服务器NoSQL数据库，毫秒级延迟 milisecond latency</li><li>容量模式：预置容量和可选自动扩展或按需容量</li><li>可以替换ElastiCache作为键&#x2F;值存储（例如存储会话数据，使用TL功能）</li><li>默认高可用性，多AZ，读写解耦，具有事务功能</li><li><strong>DAX集群用于读取缓存，微秒级读取延迟</strong></li><li>安全认证和授权通过IAM完成</li><li>事件处理：DynamoDB Streams与AWS Lambda或Kinesis Data Streams集成</li><li>全局表功能；<strong>主动-主动设置</strong></li><li>自动化备份长达35天，具有PITR（还原到新表）或按需备份，可在PITR窗口内无需使用RCU导出到S3，从S3导入无需使用WCU</li><li><strong>适用于快速演变的架构</strong></li></ul><aside>🍋 用例：无服务器应用程序开发（小型文档100 KB），分布式无服务器缓存，**doesn't have SOL query language available**</aside><h2 id="Amazon-S3"><a href="#Amazon-S3" class="headerlink" title="Amazon S3"></a>Amazon S3</h2><ul><li><p>S3 is a… key&#x2F; value store for objects</p><ul><li>Great for bigger objects, not so great for many small objects</li><li>Serverless, scales infinitely, max object size is 5 TB, versioning capability</li><li>Tiers: S3 Standard, S3 Infrequent Access, S3 Intelligent, S3 Glacier + lifecycle policy</li><li>Features: Versioning, Encryption, Replication, MFA-Delete, Access Logs…</li><li>Security. I&#x2F;AM, Bucket Palicies, ACL, Access Points, Object Lambda, CORS. Object&#x2F;aut Lock</li><li>Encryption: SSE-S3, SSE-KMS, SSE-C, client-side, TLS in transit, default encryption</li><li>Batch operations on objects using S3 Batch, listing files using S3 Inventory</li><li>Performance: Multi-part upload, S3 Transfer Acceleration, S3 Select</li><li>Automation: S3 Event Notifications (SNS, SOS, Lambda, EventBridge)</li><li>Use Cases; static files, key value store for big files, website hosting</li></ul><p>  <img src="/images/Untitled%2055.png" alt="Untitled">  </p></li><li><p>S3是一个用于object的<strong>键&#x2F;值存储系统</strong></p></li><li><p>非常适合存储大型对象，但对于<strong>大量</strong>小对象则不太适用</p></li><li><p><strong>无服务器</strong>架构，可无限扩展，单个对象最大大小为5TB，支持versioning</p></li><li><p>存储类型：S3 Standard, S3 Infrequent Access, S3 Intelligent, S3 Glacier + lifecycle policy</p></li><li><p>功能：版本控制、加密、复制、MFA-删除、访问日志等等</p></li><li><p>安全性：IAM、存储桶策略、ACL、访问点、对象Lambda、CORS、对象&#x2F;自动锁定</p></li><li><p>加密：SSE-S3、SSE-KMS、SSE-C、客户端加密、TLS in transit、默认加密</p></li><li><p>使用S3 Batch进行对象批量操作，使用S3 Inventory列出文件</p></li><li><p>性能：Multi-part upload, S3 Transfer Acceleration, S3 Select</p></li><li><p>自动化：S3事件通知（SNS、SOS、Lambda、EventBridge）</p></li></ul><aside>🍋 使用场景：静态文件存储static files、大文件的键值存储 key value store for big files、网站托管 website hosting</aside><h2 id="DocumentDB"><a href="#DocumentDB" class="headerlink" title="DocumentDB"></a>DocumentDB</h2><ul><li><p>documentDB</p><p>  <img src="/images/Untitled%2056.png" alt="Untitled"></p></li><li><p>Aurora是对PostgreSQL &#x2F; MySQL的AWS实现…</p></li><li><p><strong>DocumentDB是MongoDB的AWS实现（MongoDB是一种NoSQL数据库）</strong></p></li><li><p>MongoDB用于存储、查询和索引JSON数据</p></li><li><p>与Aurora类似的部署概念</p></li><li><p>完全托管，高可用性，跨3个可用区进行复制</p></li><li><p>Aurora存储会自动增长，每次增加10GB，最多可达64TB。</p></li><li><p>automatically scales to workloads with millions of request per seconds</p></li></ul><p>自动缩放以处理每秒数百万个请求的工作负载</p><h2 id="Neptune"><a href="#Neptune" class="headerlink" title="Neptune"></a>Neptune</h2><ul><li><p>neptune</p><p>  <img src="/images/Untitled%2057.png" alt="Untitled"></p></li></ul><p>Amazon Neptune is a <strong>fast, reliable, fully-managed graph database service</strong> that makes it easy to build and run applications that work with highly connected datasets</p><ul><li>Neptune是一个托管的图形数据库服务，用于构建图形数据应用程序。</li><li>支持图形数据库模型和图形查询语言，处理复杂的关系型数据。</li><li>完全托管的图形数据库</li><li>一个流行的图形数据集可以是一个社交网络<ul><li>用户拥有朋友</li><li>帖子有评论</li><li>评论有用户的喜欢</li><li>用户分享和喜欢帖子……</li></ul></li><li>在3个可用区内高可用性，最多支持15个读取副本</li><li>构建和运行与高度连接的数据集合一起工作的应用程序 - 为这些复杂和繁重的查询进行了优化</li><li>可以存储上百亿个关系并以毫秒级的延迟查询图</li><li>通过多个可用区进行复制来实现高可用性</li></ul><aside>🍋 适用于知识图谱（如维基百科）、欺诈检测、推荐引擎、社交网络等应用</aside><h2 id="Keyspaces："><a href="#Keyspaces：" class="headerlink" title="Keyspaces："></a>Keyspaces：</h2><ul><li><p>keyspaces</p><p>  <img src="/images/Untitled%2058.png" alt="Untitled"></p></li><li><p>用于Apache Cassandra）：</p></li><li><p>Apache Cassandra是一种开源的分布式NoSQL数据库。</p></li><li><p>这是一种托管的与Apache Cassandra兼容的数据库服务。</p></li><li><p>无服务器架构，可扩展，高可用性，由AWS全面托管。</p></li><li><p>根据应用程序的流量自动调整表格的规模。</p></li><li><p>表格在多个可用区内复制3次。</p></li><li><p>使用Cassandra查询语言（CQL）。</p></li><li><p>即使在大规模情况下，单位数毫秒的延迟，每秒数千个请求。</p></li><li><p>容量：按需模式或配额模式与自动扩展。</p></li><li><p>支持加密、备份和35天的按时间点恢复（PITR）</p></li></ul><aside>🍋 使用场景：存储物联网设备信息、时间序列数据等。</aside><ul><li>具有高度可扩展性和高性能，适用于处理海量的分布式数据。</li><li></li></ul><h2 id="QLDB（Quantum-Ledger-Database）："><a href="#QLDB（Quantum-Ledger-Database）：" class="headerlink" title="QLDB（Quantum Ledger Database）："></a>QLDB（Quantum Ledger Database）：</h2><ul><li><p>QLDB</p><p>  <img src="/images/Untitled%2059.png" alt="Untitled"></p></li><li><p>QLDB是一个全托管、不可变、透明的账本数据库。</p></li><li><p>Quantum Ledger Database-量子账本数据库</p></li><li><p>用于记录交易历史和变更，并保证数据的安全性和完整性。</p></li><li><p>账本是记录财务交易的记录册</p></li><li><p>完全托管、无服务器、高可用性，在3个可用区进行复制</p></li><li><p>用于查看应用程序数据的所有更改历史</p></li><li><p>不可变系统；任何条目都无法删除或修改，具有加密验证</p></li><li><p>使用SQL轻松操作数据，性能比常见的账本区块链框架提高2-3倍</p></li><li><p>与Amazon Managed Blockchain集成，提供强大的区块链功能</p></li></ul><h2 id="Timestream："><a href="#Timestream：" class="headerlink" title="Timestream："></a>Timestream：</h2><ul><li><p>timestream</p><p>  <img src="/images/Untitled%2060.png" alt="Untitled"></p></li><li><p>Timestream是一个全托管的时间序列数据库服务，用于存储和分析时间序列数据，如IoT传感器数据、应用程序日志等。</p></li><li><p>完全托管、快速、可扩展、无服务器的时间序列数据库</p></li><li><p>自动按需调整容量，实现自动扩缩容</p></li><li><p>可存储和分析每天数万亿个事件</p></li><li><p>比关系型数据库快1000倍，成本仅为其十分之一</p></li><li><p>支持定期查询、多指标记录、SQL兼容性</p></li><li><p>数据存储层次：近期数据保存在内存中，历史数据保存在成本优化的存储中</p></li><li><p>内置时间序列分析功能（帮助您在近实时中识别数据中的模式）</p></li><li><p>在传输和静态状态下进行加密</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS-14【 网络】网络连接</title>
      <link href="/2023/08/16/AWS-15%E3%80%90%20%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/"/>
      <url>/2023/08/16/AWS-15%E3%80%90%20%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Internet-Gateway-IGW"><a href="#1-Internet-Gateway-IGW" class="headerlink" title="1. Internet Gateway (IGW)"></a>1. Internet Gateway (IGW)</h2><ul><li><strong>IGW（Internet gateway）是AWS提供的，用来实现VPC和Internet之间相互通信的高可用组件。</strong></li><li>IGW 是连接 VPC 内部<strong>私有子网</strong>和<strong>公共 Internet</strong> 的组件。</li><li>在公有子网中，IGW 允许实例与 Internet 通信，且可以使用公有 IP。</li><li>一个VPC只能连接到一个IGW，反之亦然</li></ul><h2 id="2-NAT"><a href="#2-NAT" class="headerlink" title="2. NAT"></a>2. NAT</h2><h3 id="NAT-Network-Address-Translation"><a href="#NAT-Network-Address-Translation" class="headerlink" title="NAT &#x3D; Network Address Translation"></a>NAT &#x3D; Network Address Translation</h3><p>NAT 网关主要用于<strong>私有子网中的实例</strong>访问互联网</p><p><strong><code>出站连接</code></strong></p><h3 id="NAT-instance"><a href="#NAT-instance" class="headerlink" title="NAT instance"></a><strong>NAT instance</strong></h3><p>需要手动配置，适用于小规模流量。Old, must be setup in a public subnet, disable Source &#x2F; Destination check flag</p><p><img src="/images/Untitled%20152.png" alt="Untitled"></p><h3 id="NAT-gateway"><a href="#NAT-gateway" class="headerlink" title="NAT gateway"></a>NAT gateway</h3><p>AWS 托管，适用于大规模流量和高可用性需求。</p><p>NAT Gateway由AWS管理，提供可扩展的IPv4私有EC2实例Internet访问。</p><p>性能和可用性较高，所以通常优于NAT Instance。</p><p><img src="/images/Untitled%20153.png" alt="Untitled"></p><h2 id="3-AWS-Direct-Connect-DX-直连"><a href="#3-AWS-Direct-Connect-DX-直连" class="headerlink" title="3. AWS Direct Connect (DX)-直连"></a>3. AWS Direct Connect (DX)-直连</h2><p><img src="/images/Untitled%20154.png" alt="Untitled"></p><ul><li><strong>专用的物理连接</strong></li><li>AWS Direct Connect 在您的本地部署网络和 AWS 之间建立专用网络连接。</li><li>可以实现更稳定、低延迟的连接，用于大数据传输和混合云架构。</li></ul><h2 id="Direct-Connect-DX"><a href="#Direct-Connect-DX" class="headerlink" title="Direct Connect (DX)"></a>Direct Connect (DX)</h2><ul><li>提供从远程网络到您的VPC的dedicated private专用私有连接。</li><li>Data Center and <em><strong>AWS Direct Connect locations</strong></em>之间设置专用连接。</li></ul><aside>💡 DX Location是AWS Direct Connect服务的实际物理位置，通过连接到这些位置，您可以建立专用的物理连接</aside><ul><li><p>可以在同一连接上访问公共资源（如S3）和私有资源（如EC2）。</p></li><li><p>支持IPv4和IPv6。</p><p>  <img src="/images/Untitled%20155.png" alt="Untitled"></p></li></ul><blockquote><p><strong>连接流程：</strong></p></blockquote><ol><li>您在AWS控制台中选择一个DX Location，这是您将要建立连接的物理位置。</li><li>在您的本地网络中，您配置一个CGW，以确保它能够连接到DX Location。</li><li>您在AWS中创建一个VGW，并分配一个公共IP地址。</li><li>您在CGW和VGW之间建立IPSec隧道，通过配置加密和认证参数，以建立安全的通信通道。</li><li>一旦隧道建立，数据可以通过VPN连接在CGW和VGW之间进行加密传输。</li></ol><h2 id="Direct-Connect-Gateway"><a href="#Direct-Connect-Gateway" class="headerlink" title="Direct Connect Gateway"></a>Direct Connect Gateway</h2><ul><li>如果您想要在许多不同的区域（同一账户）中设置与一个或多个VPC的Direct Connect连接，您必须使用Direct Connect网关。If you want to set up a Direct Connect to one or more VPC in many different regions (same account), you must use a Direct Connect Gateway</li><li>建立新连接需要一个月以上的时间。</li><li>在传输中的数据未加密，但是保持私密性。<ul><li>AWS Direct Connect + VPN提供了一个IPsec加密的私有连接。</li></ul></li><li>如果Direct Connect发生故障，您可以设置备份Direct Connect连接（费用较高），或者设置站点到站点VPN连接。In case Direct Connect fails, you can set up a backup Direct Connect connection (expensive), or a Site-to-Site VPN connection</li><li></li></ul><p><img src="/images/Untitled%20156.png" alt="Untitled"></p><p><img src="/images/Untitled%20157.png" alt="Untitled"></p><h2 id="4-Bastion-Hosts"><a href="#4-Bastion-Hosts" class="headerlink" title="4. Bastion Hosts"></a>4. Bastion Hosts</h2><ul><li>一个作为跳板的 EC2 instance</li><li>Bastion Host 是放置在公有子网中的实例，用于安全远程访问私有子网中的实例。</li><li>通常用于管理和维护私有子网中的实例，提供临时访问。</li></ul><p>访问跳板：在受保护的内部网络和外部网络之间进行访问的中间节点。</p><p>位于公共网络中</p><p>使用bastion hosts  to SSH into 私有EC2实例</p><p><img src="/images/Untitled%20158.png" alt="Untitled"></p><h2 id="5-Ephemeral-Ports"><a href="#5-Ephemeral-Ports" class="headerlink" title="5. Ephemeral Ports"></a>5. Ephemeral Ports</h2><p><code>临时端口，短暂端口或动态端口</code></p><ul><li>随机分配的临时端口</li><li>Ephemeral Ports（短暂端口）是客户端与服务器之间临时建立的端口，用于数据传输。</li><li>通常在连接时随机分配，并在连接终止后释放。</li><li>Clients connect to a defined port, and expect a response on this port</li></ul><h2 id="6-AWS-VPN-CloudHub-和站点到站点-Site-to-Site-VPN"><a href="#6-AWS-VPN-CloudHub-和站点到站点-Site-to-Site-VPN" class="headerlink" title="6. AWS VPN CloudHub 和站点到站点 (Site-to-Site) VPN"></a>6. AWS VPN CloudHub 和站点到站点 (Site-to-Site) VPN</h2><h2 id="Site-to-Site-VPN"><a href="#Site-to-Site-VPN" class="headerlink" title="Site-to-Site VPN"></a>Site-to-Site VPN</h2><p>将本地数据中心与 VPC 直接连接的方法，作为备份连接方式。</p><p><strong>建立本地到VPC的连接：</strong> VPC站点到站点VPN允许您在VPC和本地数据中心之间建立一个加密的连接，使您的本地资源可以与VPC中的资源进行通信。</p><aside>💡 **VPN Gateway：** 在云服务中和本地网络中分别创建VPN Gateway：<aside>💡 VGW表示VPC侧的VPN设备</aside><aside>💡 LWG表示本地数据中心侧的VPN设备。</aside></aside><h3 id="VGW（Virtual-Private-Gateway）："><a href="#VGW（Virtual-Private-Gateway）：" class="headerlink" title="VGW（Virtual Private Gateway）："></a><strong>VGW（Virtual Private Gateway）：</strong></h3><ul><li>VGW是云服务提供商（如AWS）中的虚拟设备，用于建立VPN连接并处理数据的传入和传出。</li><li>VGW is created and attached to the VPC from which you want to create the Site-to-Site VPN connection</li></ul><h3 id="CGW（Customer-Gateway）："><a href="#CGW（Customer-Gateway）：" class="headerlink" title="CGW（Customer Gateway）："></a><strong>CGW（Customer Gateway）：</strong></h3><ul><li>本地网络中的物理设备或虚拟设备</li><li>与VGW之间建立IPSec隧道来实现安全通信。</li></ul><p><img src="/images/Untitled%20159.png" alt="Untitled"></p><h2 id="Site-to-Site-VPN-connection-as-a-backup"><a href="#Site-to-Site-VPN-connection-as-a-backup" class="headerlink" title="Site-to-Site VPN connection as a backup"></a>Site-to-Site VPN connection as a backup</h2><p><img src="/images/Untitled%20160.png" alt="Untitled"></p><h2 id="AWS-VPN-CloudHub"><a href="#AWS-VPN-CloudHub" class="headerlink" title="AWS VPN CloudHub"></a>AWS VPN CloudHub</h2><p>AWS VPN CloudHub 允许多个站点通过 VPN 连接到 AWS。</p><p>集中式的解决方案</p><ul><li>Provide secure communication between multiple sites, if you have multiple VPN connections</li><li>Low-cost hub-and-spoke model for primary or secondary network connectivity between different locations (VPN only)</li><li>It’s a VPN connection so it goes over the public Internet</li><li>如果有多个 VPN 连接，可以在多个站点之间提供安全通信</li><li>低成本的枢纽-辐射模型，用于不同位置之间的主要或次要网络连接 (仅限 VPN)</li><li>这是一种 VPN 连接，因此它经过公共互联网传输</li></ul><ol start="6"><li><strong>多站点连接：</strong> AWS VPN CloudHub支持同时连接多个远程站点。这些站点可以是不同地理位置的办公室、数据中心等。</li><li><strong>中心式架构：</strong> CloudHub采用中心式架构，其中AWS云中的一个VPC被用作中心（hub），连接到多个远程站点（spokes）。</li><li><strong>单一VPN连接：</strong> 在CloudHub配置中，每个远程站点与AWS云中的中心VPC之间只需要一个VPN连接。</li></ol><h2 id="7-Transit-Gateway-中转网关"><a href="#7-Transit-Gateway-中转网关" class="headerlink" title="7. Transit Gateway-中转网关"></a>7. Transit Gateway-<strong>中转网关</strong></h2><ul><li>Transit Gateway 是中心化的路由交换设备，用于连接多个 VPC、VPN 和 Direct Connect。</li><li>它简化了大规模 VPC 网络的管理和扩展。</li></ul><h2 id="Transit-Gateway（中转网关）"><a href="#Transit-Gateway（中转网关）" class="headerlink" title="Transit Gateway（中转网关）"></a><em><strong>Transit Gateway（中转网关）</strong></em></h2><p><strong>support  IP Multicast</strong></p><p>Transit Gateway是一种网络服务，用于在成千上万个VPC和本地网络之间建立具有<strong>传递性</strong>的中心式（星型）连接。以下是Transit Gateway的关键概念：</p><ul><li><strong>传递性对等连接：</strong> Transit Gateway允许在多个VPC和本地网络之间建立传递性的对等连接，形成一个中心枢纽连接。</li><li>Regional resource**：** Transit Gateway是region级别的资源，可以cross-region工作，实现不同AWS区域的连接。</li><li>Share cross-account contents using Resource Access Manager (RAM)</li><li>**使用RAM（Resource Access Manager）**Share cross-account contents</li></ul><p><img src="/images/Untitled%20161.png" alt="Untitled"></p><h3 id="Site-to-Site-VPN-ECMP"><a href="#Site-to-Site-VPN-ECMP" class="headerlink" title="Site-to-Site VPN ECMP"></a>Site-to-Site VPN ECMP</h3><ul><li>ECMP &#x3D; Equal-cost multi-path routing</li><li>Routing strategy to allow to forward a packet over multiple best path</li><li>Use case: create multiple Site-To-Site VPN connections to increase the bandwidth of your connection to AWS</li><li>站点对站点 VPN ECMP<ul><li>ECMP &#x3D; 等价多路径路由</li><li>转发数据包的路由策略，允许通过多个最佳路径</li><li>使用场景：创建多个站点对站点 VPN 连接，以增加到 AWS 的带宽</li></ul></li></ul><p><img src="/images/Untitled%20162.png" alt="Untitled"></p><p><img src="/images/Untitled%20163.png" alt="Untitled"></p><p><img src="/images/Untitled%20164.png" alt="Untitled"></p><h2 id="8-Traffic-Mirroring"><a href="#8-Traffic-Mirroring" class="headerlink" title="8. Traffic Mirroring"></a>8. Traffic Mirroring</h2><ul><li><strong>流量镜像：</strong> 通过使用流量镜像，您可以将来自<strong>生产 VPC</strong> 的流量镜像到特定的目标（例如 EC2 实例或另一个 VPC），然后在目标上执行流量<strong>检查和过滤</strong>。</li><li><strong>将流量路由到安全设备：</strong> 以进行内容检查、威胁监控、故障排除等操作。</li><li><strong>源和目标位置：</strong> 流量镜像的源和目标可以在同一VPC内或不同VPC之间（通过VPC Peering）。</li><li><strong>应用场景：</strong> 使用Transit Gateway的流量镜像功能可以用于内容检查、威胁监控、故障排除等场景。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS-13【 网络】VPC</title>
      <link href="/2023/08/16/AWS-14%E3%80%90%20%E7%BD%91%E7%BB%9C%E3%80%91VPC/"/>
      <url>/2023/08/16/AWS-14%E3%80%90%20%E7%BD%91%E7%BB%9C%E3%80%91VPC/</url>
      
        <content type="html"><![CDATA[<h1 id="VPC"><a href="#VPC" class="headerlink" title="VPC"></a><strong>VPC</strong></h1><h3 id="Virtual-Private-Cloud"><a href="#Virtual-Private-Cloud" class="headerlink" title="Virtual Private Cloud"></a>Virtual Private Cloud</h3><p><img src="/images/Untitled%20133.png" alt="Untitled"></p><h2 id="1-VPC-概述"><a href="#1-VPC-概述" class="headerlink" title="1. VPC 概述"></a>1. VPC 概述</h2><ul><li>VPC 是一个逻辑隔离的 AWS 云网络，允许您在自己定义的虚拟网络中运行 AWS 资源。</li><li>VPC 具有 IP 地址范围（CIDR 块）。</li><li>类似传统网络中的<strong>VLAN</strong></li><li>multiple VPCs  in a region(最多5个）</li><li>VPC的最大CIDR范围可以是&#x2F;16（65,536个IP地址）到&#x2F;28（16个IP地址）</li></ul><p><img src="/images/Untitled%20134.png" alt="Untitled"></p><h2 id="2-Subnets-子网"><a href="#2-Subnets-子网" class="headerlink" title="2. Subnets-子网"></a>2. Subnets-子网</h2><ul><li>Subnet 是 VPC IP 地址范围的一部分，用于在 VPC 内部划分不同的网络区域。</li></ul><p><img src="/images/Untitled%20135.png" alt="Untitled"></p><ul><li>子网必须位于单个可用区中</li><li>子网可以分配给不同的AZ，确保高可用性。<ul><li>保留5个IP地址，前四个和最后一个</li></ul></li><li><strong>公有子网（Public Subnet</strong>：与 Internet Gateway（IGW）关联，可以直接访问 Internet。</li><li><strong>私有子网（Private Subnet）</strong>：无法直接访问 Internet，通常用于安全敏感的工作负载。通过NAT网关或NAT实例来实现对Internet的有限访问</li></ul><h2 id="3-Route-Table-路由表"><a href="#3-Route-Table-路由表" class="headerlink" title="3.Route Table-路由表"></a>3.<strong>Route Table-路由表</strong></h2><p>路由表定义了网络流量如何在子网之间和VPC内部进行路由。每个子网都会关联一个路由表，该表指定了流量的目标以及如何将流量转发到目标。</p><h2 id="4-安全组-Security-Group-和NACL"><a href="#4-安全组-Security-Group-和NACL" class="headerlink" title="4. 安全组 (Security Group) 和NACL"></a>4. 安全组 (Security Group) 和NACL</h2><ul><li><p><strong>安全组（Security Group）</strong></p><ul><li><strong>层次： instance-level</strong>每个实例可以关联一个或多个安全组。它是第一层防御，应用在每个实例上。</li><li><strong>规则：</strong> 基于”allow”的原则。如果规则没有明确允许，那么它就会被隐式地拒绝。</li><li><strong>状态：stateful</strong></li><li><strong>应用：</strong> 用于实现实例级别的访问控制，通常用于控制实例之间的通信。</li></ul></li><li><p><strong>网络访问控制列表（NACL）-Network Access Control List</strong></p><p>  <strong>默认情况下，它允许所有入站和出站 IPv4 流量以及 IPv6 流量</strong></p><ul><li><p><strong>层次：</strong> NACL是在子网级别操作的，每个子网都有一个关联的NACL。它是第二层防御，应用在子网内。</p></li><li><p><strong>规则：</strong> 基于”allow”和”deny”。</p></li><li><p><strong>状态：</strong> <strong>stateless，如果您允许出站流量，入站回复流量不会自动被允许。<code>这意味着你需要同时考虑入站和出站规则，因为出站规则也会影响入站流量的回复。</code></strong></p><ul><li><strong><code>需要确保相关的出站规则允许响应的HTTPS流量返回</code></strong></li></ul></li><li><p><strong>应用：</strong> 用于实现子网级别的访问控制，通常用于控制子网之间的通信。</p></li><li><p>Default NACL</p><ul><li>Accepts everything inbound&#x2F;outbound with the subnets it’s associated with</li><li>Do NOT modify the Default NACL, instead create custom NACLs</li></ul><p>  <img src="/images/Untitled%20136.png" alt="Untitled"></p></li></ul></li></ul><table><thead><tr><th>特点 &#x2F; 注意事项</th><th>安全组 (SG)</th><th>网络访问控制列表 (NACL)</th></tr></thead><tbody><tr><td>类型</td><td>实例级别防火墙</td><td>子网级别防火墙</td></tr><tr><td>方向</td><td>可以配置入站和出站规则</td><td><strong>必须</strong>同时配置入站和出站规则</td></tr><tr><td>默认规则</td><td>拒绝所有流量</td><td>允许所有流量</td></tr><tr><td>有状态性</td><td>有状态，自动允许相关回复流量</td><td>无状态，入站和出站流量的状态是分开维护</td></tr><tr><td>数量限制</td><td>一个实例可以关联多个安全组</td><td>一个子网只能关联一个网络访问控制列表</td></tr><tr><td>功能</td><td>简单，易于使用</td><td>较为复杂，可用于更细粒度的控制</td></tr></tbody></table><p><strong>注意事项：</strong></p><p><strong>安全组 (SG)：</strong></p><ul><li>安全组适用于实例级别的访问控制，配置更简单，但只能定义基于协议、端口和IP范围的规则。</li><li>可以在安全组之间进行联动，一个实例可以关联多个安全组，规则叠加。</li><li>入站规则优先于出站规则，相关回复流量自动允许。</li></ul><p><strong>网络访问控制列表 (NACL)：</strong></p><ul><li>NACL 适用于子网级别的访问控制，可以更细粒度地定义入站和出站规则。</li><li>需要同时配置入站和出站规则，注意规则的顺序和编号。</li><li>无状态性意味着入站和出站流量的状态是分开维护的，需要确保出站规则允许相关回复流量。</li><li>更适合处理较复杂的网络策略，但需要更多的配置工作。</li></ul><p>请根据你的需求和网络架构，选择合适的访问控制方式。一般情况下，安全组用于基本的实例级别防火墙，而 NACL 则用于更细粒度的子网级别控制。</p><p><img src="/images/Untitled%20137.png" alt="Untitled"></p><p><strong>选择安全组还是NACL：</strong></p><ul><li>如果您需要更精细的控制，并且关注于实例级别的访问控制，使用安全组。</li><li>如果您需要更高层次的网络防御，以及控制子网之间的通信，使用NACL。</li><li>在复杂的网络环境中，通常会同时使用安全组和NACL来提供多层次的安全性。</li></ul><h2 id="5-VPC-Peering-对等连接"><a href="#5-VPC-Peering-对等连接" class="headerlink" title="5. VPC Peering-对等连接"></a>5. VPC Peering-<strong>对等连接</strong></h2><p>VPC Peering 允许在不同的 VPC 之间创建私有连接。</p><ul><li><strong>连接不同VPC：</strong> VPC Peering允许您将两个不同的VPC连接在一起，使它们之间可以进行安全的通信。</li><li><strong>不具备传递性</strong></li><li><strong>跨帐户&#x2F;区域：</strong> 您可以在不同的AWS帐户或不同的AWS区域之间创建VPC Peering连接，从而实现多个帐户或区域之间的私有通信。<ul><li>可以在不同 AWS 账户之间或同一账户下的不同 VPC 之间建立 VPC Peering。</li></ul></li><li><strong>引用安全组：</strong> 在同一区域的不同帐户之间，您可以通过VPC Peering引用另一个VPC中的安全组，以实现资源间的访问控制。</li><li><strong>路由表更新：</strong> 在建立VPC Peering后，您需要更新每个VPC子网的路由表，以确保VPC内的EC2实例可以通过Peering连接进行通信。</li></ul><h2 id="6-VPC-端点-Endpoints"><a href="#6-VPC-端点-Endpoints" class="headerlink" title="6. VPC 端点 (Endpoints)"></a>6. VPC 端点 (Endpoints)</h2><p>用于在 <strong>VPC 内部与 AWS 服务</strong>进行安全通信。</p><ul><li>VPC 端点允许 <strong>VPC 中的实例与 AWS 服务</strong>通信，而无需通过 Internet。</li><li>分为网关端点（Gateway Endpoint）和接口端点（Interface Endpoint）。</li><li>They’re redundant and scale horizontally冗余性并且水平扩展</li></ul><p><img src="/images/Untitled%20138.png" alt="Untitled"></p><ul><li><p><strong>类型：</strong> 有两种类型的VPC终端节点：</p><ul><li><strong>接口终端节点（Interface Endpoints）：</strong> 使用AWS PrivateLink提供支持，它为您的VPC分配一个Elastic Network Interface（<strong>ENI</strong>），作为访问AWS服务的入口点。支持大多数AWS服务，<strong>需要按小时计费并按数据处理量付费。</strong></li></ul><p>  <img src="/images/Untitled%20139.png" alt="Untitled"></p><ul><li><strong>网关终端节点（Gateway Endpoints）：</strong> 适用于S3和DynamoDB，可以将终端节点作为目标添加到VPC的路由表中。网关终端节点<strong>免费且不使用安全组。</strong></li></ul><p>  <img src="/images/Untitled%20140.png" alt="Untitled">  </p></li><li><p><strong>适用场景：</strong></p><ul><li>对于需要安全地连接到AWS服务的情况，如数据库、存储和计算资源，VPC终端节点是一个理想的选择。</li><li>接口终端节点适用于需要连接多种AWS服务的场景，而网关终端节点适用于S3和DynamoDB的访问</li></ul></li><li><p>Gateway or Interface Endpoint for <strong>S3</strong>?</p><ul><li>Gateway is most likely going to be preferred all the time at the exam</li><li>Unless, access is required from on premises (Site to Site VPN or Direct Connect), a different VPC or a different region</li><li>选择S3的网关终端节点还是接口终端节点？<br>  在考试中，gateway很可能会始终被优先选择<br>  除非需要从本地环境（站点到站点VPN或直接连接）、不同的VPC或不同的区域访问。</li></ul></li></ul><h2 id="7-VPC-流日志-Flow-Logs"><a href="#7-VPC-流日志-Flow-Logs" class="headerlink" title="7. VPC 流日志 (Flow Logs)"></a>7. VPC 流日志 (Flow Logs)</h2><ul><li>VPC 流日志可捕获 VPC 内部网络流量的详细信息，用于安全审计和网络监控。</li><li>流日志可以将数据发送到 Amazon S3、CloudWatch Logs 或 Amazon ES。</li></ul><h2 id="VPC-Flow-Logs"><a href="#VPC-Flow-Logs" class="headerlink" title="VPC Flow Logs"></a>VPC Flow Logs</h2><ul><li>Capture information about IP traffic going into your interfaces</li><li>Helps to monitor &amp; troubleshoot connectivity issues</li><li>Flow logs data can go to S3 &#x2F; CloudWatch Logs</li><li>Query VPC flow logs using Athena on S3 or CloudWatch Logs Insights</li><li>捕获进入接口的IP流量信息</li><li>有助于监视和解决连接问题</li><li>流日志数据可发送到S3 &#x2F; CloudWatch日志</li><li>使用Athena在S3上查询VPC流日志或CloudWatch日志洞察</li></ul><p><img src="/images/Untitled%20141.png" alt="Untitled"></p><h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p><img src="/images/Untitled%20142.png" alt="Untitled"></p><p><img src="/images/Untitled%20143.png" alt="Untitled"></p><p><img src="/images/Untitled%20144.png" alt="Untitled"></p><p><img src="/images/Untitled%20145.png" alt="Untitled"></p><p><img src="/images/Untitled%20146.png" alt="Untitled"></p><p><img src="/images/Untitled%20147.png" alt="Untitled"></p><p><img src="/images/Untitled%20148.png" alt="Untitled"></p><p><img src="/images/Untitled%20149.png" alt="Untitled"></p><p><img src="/images/Untitled%20150.png" alt="Untitled"></p><p><img src="/images/Untitled%20151.png" alt="Untitled"></p><h1 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h1><h2 id="1-Internet-Gateway-IGW"><a href="#1-Internet-Gateway-IGW" class="headerlink" title="1. Internet Gateway (IGW)"></a>1. Internet Gateway (IGW)</h2><ul><li><strong>IGW（Internet gateway）是AWS提供的，用来实现VPC和Internet之间相互通信的高可用组件。</strong></li><li>IGW 是连接 VPC 内部<strong>私有子网</strong>和<strong>公共 Internet</strong> 的组件。</li><li>在公有子网中，IGW 允许实例与 Internet 通信，且可以使用公有 IP。</li><li>一个VPC只能连接到一个IGW，反之亦然</li></ul><h2 id="2-NAT"><a href="#2-NAT" class="headerlink" title="2. NAT"></a>2. NAT</h2><h3 id="NAT-Network-Address-Translation"><a href="#NAT-Network-Address-Translation" class="headerlink" title="NAT &#x3D; Network Address Translation"></a>NAT &#x3D; Network Address Translation</h3><p>NAT 网关主要用于<strong>私有子网中的实例</strong>访问互联网</p><p><strong><code>出站连接</code></strong></p><h3 id="NAT-instance"><a href="#NAT-instance" class="headerlink" title="NAT instance"></a><strong>NAT instance</strong></h3><p>需要手动配置，适用于小规模流量。Old, must be setup in a public subnet, disable Source &#x2F; Destination check flag</p><p><img src="/images/Untitled%20152.png" alt="Untitled"></p><h3 id="NAT-gateway"><a href="#NAT-gateway" class="headerlink" title="NAT gateway"></a>NAT gateway</h3><p>AWS 托管，适用于大规模流量和高可用性需求。</p><p>NAT Gateway由AWS管理，提供可扩展的IPv4私有EC2实例Internet访问。</p><p>性能和可用性较高，所以通常优于NAT Instance。</p><p><img src="/images/Untitled%20153.png" alt="Untitled"></p><h2 id="3-AWS-Direct-Connect-DX-直连"><a href="#3-AWS-Direct-Connect-DX-直连" class="headerlink" title="3. AWS Direct Connect (DX)-直连"></a>3. AWS Direct Connect (DX)-直连</h2><p><img src="/images/Untitled%20154.png" alt="Untitled"></p><ul><li><strong>专用的物理连接</strong></li><li>AWS Direct Connect 在您的本地部署网络和 AWS 之间建立专用网络连接。</li><li>可以实现更稳定、低延迟的连接，用于大数据传输和混合云架构。</li></ul><h2 id="Direct-Connect-DX"><a href="#Direct-Connect-DX" class="headerlink" title="Direct Connect (DX)"></a>Direct Connect (DX)</h2><ul><li>提供从远程网络到您的VPC的dedicated private专用私有连接。</li><li>Data Center and <em><strong>AWS Direct Connect locations</strong></em>之间设置专用连接。</li></ul><aside>💡 DX Location是AWS Direct Connect服务的实际物理位置，通过连接到这些位置，您可以建立专用的物理连接</aside><ul><li><p>可以在同一连接上访问公共资源（如S3）和私有资源（如EC2）。</p></li><li><p>支持IPv4和IPv6。</p><p>  <img src="/images/Untitled%20155.png" alt="Untitled"></p></li></ul><blockquote><p><strong>连接流程：</strong></p></blockquote><ol><li>您在AWS控制台中选择一个DX Location，这是您将要建立连接的物理位置。</li><li>在您的本地网络中，您配置一个CGW，以确保它能够连接到DX Location。</li><li>您在AWS中创建一个VGW，并分配一个公共IP地址。</li><li>您在CGW和VGW之间建立IPSec隧道，通过配置加密和认证参数，以建立安全的通信通道。</li><li>一旦隧道建立，数据可以通过VPN连接在CGW和VGW之间进行加密传输。</li></ol><h2 id="Direct-Connect-Gateway"><a href="#Direct-Connect-Gateway" class="headerlink" title="Direct Connect Gateway"></a>Direct Connect Gateway</h2><ul><li>如果您想要在许多不同的区域（同一账户）中设置与一个或多个VPC的Direct Connect连接，您必须使用Direct Connect网关。If you want to set up a Direct Connect to one or more VPC in many different regions (same account), you must use a Direct Connect Gateway</li><li>建立新连接需要一个月以上的时间。</li><li>在传输中的数据未加密，但是保持私密性。<ul><li>AWS Direct Connect + VPN提供了一个IPsec加密的私有连接。</li></ul></li><li>如果Direct Connect发生故障，您可以设置备份Direct Connect连接（费用较高），或者设置站点到站点VPN连接。In case Direct Connect fails, you can set up a backup Direct Connect connection (expensive), or a Site-to-Site VPN connection</li><li></li></ul><p><img src="/images/Untitled%20156.png" alt="Untitled"></p><p><img src="/images/Untitled%20157.png" alt="Untitled"></p><h2 id="4-Bastion-Hosts"><a href="#4-Bastion-Hosts" class="headerlink" title="4. Bastion Hosts"></a>4. Bastion Hosts</h2><ul><li>一个作为跳板的 EC2 instance</li><li>Bastion Host 是放置在公有子网中的实例，用于安全远程访问私有子网中的实例。</li><li>通常用于管理和维护私有子网中的实例，提供临时访问。</li></ul><p>访问跳板：在受保护的内部网络和外部网络之间进行访问的中间节点。</p><p>位于公共网络中</p><p>使用bastion hosts  to SSH into 私有EC2实例</p><p><img src="/images/Untitled%20158.png" alt="Untitled"></p><h2 id="5-Ephemeral-Ports"><a href="#5-Ephemeral-Ports" class="headerlink" title="5. Ephemeral Ports"></a>5. Ephemeral Ports</h2><p><code>临时端口，短暂端口或动态端口</code></p><ul><li>随机分配的临时端口</li><li>Ephemeral Ports（短暂端口）是客户端与服务器之间临时建立的端口，用于数据传输。</li><li>通常在连接时随机分配，并在连接终止后释放。</li><li>Clients connect to a defined port, and expect a response on this port</li></ul><h2 id="6-AWS-VPN-CloudHub-和站点到站点-Site-to-Site-VPN"><a href="#6-AWS-VPN-CloudHub-和站点到站点-Site-to-Site-VPN" class="headerlink" title="6. AWS VPN CloudHub 和站点到站点 (Site-to-Site) VPN"></a>6. AWS VPN CloudHub 和站点到站点 (Site-to-Site) VPN</h2><h2 id="Site-to-Site-VPN"><a href="#Site-to-Site-VPN" class="headerlink" title="Site-to-Site VPN"></a>Site-to-Site VPN</h2><p>将本地数据中心与 VPC 直接连接的方法，作为备份连接方式。</p><p><strong>建立本地到VPC的连接：</strong> VPC站点到站点VPN允许您在VPC和本地数据中心之间建立一个加密的连接，使您的本地资源可以与VPC中的资源进行通信。</p><aside>💡 **VPN Gateway：** 在云服务中和本地网络中分别创建VPN Gateway：<aside>💡 VGW表示VPC侧的VPN设备</aside><aside>💡 LWG表示本地数据中心侧的VPN设备。</aside></aside><h3 id="VGW（Virtual-Private-Gateway）："><a href="#VGW（Virtual-Private-Gateway）：" class="headerlink" title="VGW（Virtual Private Gateway）："></a><strong>VGW（Virtual Private Gateway）：</strong></h3><ul><li>VGW是云服务提供商（如AWS）中的虚拟设备，用于建立VPN连接并处理数据的传入和传出。</li><li>VGW is created and attached to the VPC from which you want to create the Site-to-Site VPN connection</li></ul><h3 id="CGW（Customer-Gateway）："><a href="#CGW（Customer-Gateway）：" class="headerlink" title="CGW（Customer Gateway）："></a><strong>CGW（Customer Gateway）：</strong></h3><ul><li>本地网络中的物理设备或虚拟设备</li><li>与VGW之间建立IPSec隧道来实现安全通信。</li></ul><p><img src="/images/Untitled%20159.png" alt="Untitled"></p><h2 id="Site-to-Site-VPN-connection-as-a-backup"><a href="#Site-to-Site-VPN-connection-as-a-backup" class="headerlink" title="Site-to-Site VPN connection as a backup"></a>Site-to-Site VPN connection as a backup</h2><p><img src="/images/Untitled%20160.png" alt="Untitled"></p><h2 id="AWS-VPN-CloudHub"><a href="#AWS-VPN-CloudHub" class="headerlink" title="AWS VPN CloudHub"></a>AWS VPN CloudHub</h2><p>AWS VPN CloudHub 允许多个站点通过 VPN 连接到 AWS。</p><p>集中式的解决方案</p><ul><li>Provide secure communication between multiple sites, if you have multiple VPN connections</li><li>Low-cost hub-and-spoke model for primary or secondary network connectivity between different locations (VPN only)</li><li>It’s a VPN connection so it goes over the public Internet</li><li>如果有多个 VPN 连接，可以在多个站点之间提供安全通信</li><li>低成本的枢纽-辐射模型，用于不同位置之间的主要或次要网络连接 (仅限 VPN)</li><li>这是一种 VPN 连接，因此它经过公共互联网传输</li></ul><ol start="6"><li><strong>多站点连接：</strong> AWS VPN CloudHub支持同时连接多个远程站点。这些站点可以是不同地理位置的办公室、数据中心等。</li><li><strong>中心式架构：</strong> CloudHub采用中心式架构，其中AWS云中的一个VPC被用作中心（hub），连接到多个远程站点（spokes）。</li><li><strong>单一VPN连接：</strong> 在CloudHub配置中，每个远程站点与AWS云中的中心VPC之间只需要一个VPN连接。</li></ol><h2 id="7-Transit-Gateway-中转网关"><a href="#7-Transit-Gateway-中转网关" class="headerlink" title="7. Transit Gateway-中转网关"></a>7. Transit Gateway-<strong>中转网关</strong></h2><ul><li>Transit Gateway 是中心化的路由交换设备，用于连接多个 VPC、VPN 和 Direct Connect。</li><li>它简化了大规模 VPC 网络的管理和扩展。</li></ul><h2 id="Transit-Gateway（中转网关）"><a href="#Transit-Gateway（中转网关）" class="headerlink" title="Transit Gateway（中转网关）"></a><em><strong>Transit Gateway（中转网关）</strong></em></h2><p><strong>support  IP Multicast</strong></p><p>Transit Gateway是一种网络服务，用于在成千上万个VPC和本地网络之间建立具有<strong>传递性</strong>的中心式（星型）连接。以下是Transit Gateway的关键概念：</p><ul><li><strong>传递性对等连接：</strong> Transit Gateway允许在多个VPC和本地网络之间建立传递性的对等连接，形成一个中心枢纽连接。</li><li>Regional resource**：** Transit Gateway是region级别的资源，可以cross-region工作，实现不同AWS区域的连接。</li><li>Share cross-account contents using Resource Access Manager (RAM)</li><li>**使用RAM（Resource Access Manager）**Share cross-account contents</li></ul><p><img src="/images/Untitled%20161.png" alt="Untitled"></p><h3 id="Site-to-Site-VPN-ECMP"><a href="#Site-to-Site-VPN-ECMP" class="headerlink" title="Site-to-Site VPN ECMP"></a>Site-to-Site VPN ECMP</h3><ul><li>ECMP &#x3D; Equal-cost multi-path routing</li><li>Routing strategy to allow to forward a packet over multiple best path</li><li>Use case: create multiple Site-To-Site VPN connections to increase the bandwidth of your connection to AWS</li><li>站点对站点 VPN ECMP<ul><li>ECMP &#x3D; 等价多路径路由</li><li>转发数据包的路由策略，允许通过多个最佳路径</li><li>使用场景：创建多个站点对站点 VPN 连接，以增加到 AWS 的带宽</li></ul></li></ul><p><img src="/images/Untitled%20162.png" alt="Untitled"></p><p><img src="/images/Untitled%20163.png" alt="Untitled"></p><p><img src="/images/Untitled%20164.png" alt="Untitled"></p><h2 id="8-Traffic-Mirroring"><a href="#8-Traffic-Mirroring" class="headerlink" title="8. Traffic Mirroring"></a>8. Traffic Mirroring</h2><ul><li><strong>流量镜像：</strong> 通过使用流量镜像，您可以将来自<strong>生产 VPC</strong> 的流量镜像到特定的目标（例如 EC2 实例或另一个 VPC），然后在目标上执行流量<strong>检查和过滤</strong>。</li><li><strong>将流量路由到安全设备：</strong> 以进行内容检查、威胁监控、故障排除等操作。</li><li><strong>源和目标位置：</strong> 流量镜像的源和目标可以在同一VPC内或不同VPC之间（通过VPC Peering）。</li><li><strong>应用场景：</strong> 使用Transit Gateway的流量镜像功能可以用于内容检查、威胁监控、故障排除等场景。</li></ul><h1 id="Route-53-域名系统"><a href="#Route-53-域名系统" class="headerlink" title="Route 53-域名系统"></a>Route 53-域名系统</h1><h3 id="Amazon-Route-53"><a href="#Amazon-Route-53" class="headerlink" title="Amazon Route 53"></a><strong>Amazon Route 53</strong></h3><p><img src="/images/Untitled%20165.png" alt="Untitled"></p><ul><li>“Route 53”是指传统DNS使用的端口号（53）</li></ul><ol start="9"><li><strong>域名解析</strong>：Route 53 允许您将域名映射到各种 AWS 资源，如 **Amazon S3 存储桶、Amazon EC2 实例、Elastic Load Balancer（ELB）**等。您可以配置 DNS 记录，将用户输入的域名转换为 IP 地址，从而使用户能够通过域名访问您的资源。</li><li><strong>高可用和可靠性</strong>：Route 53 提供全球分布的 DNS 服务，具有高可用性和可靠性。它将自动将 DNS 记录分发到多个全球边缘位置，以确保用户能够就近访问资源，提高响应速度和可用性。</li><li><strong>负载均衡</strong>：Route 53 可与 Amazon Elastic Load Balancing 集成，实现负载均衡。您可以配置 DNS 记录，将流量分发到不同的负载均衡器，以实现高可用性和性能优化。</li></ol><ul><li>能够检查您的资源的健康状态</li><li><strong>100% SLA保证</strong>：Route 53是唯一一个AWS服务提供100%可用性的服务级别协议（SLA）。</li></ul><h3 id="“Route-53-Active-Passive”"><a href="#“Route-53-Active-Passive”" class="headerlink" title="“Route 53 Active-Passive”"></a>“Route 53 Active-Passive”</h3><p>是一种架构配置，主要用于实现高可用性和故障恢复。</p><p>在 Active-Passive 配置中，我们通常考虑系统中的两种状态：活动状态（Active）和待命状态（Passive）。</p><ul><li><strong>活动状态（Active）：</strong> 这是系统中当前正在提供服务的状态。在一个 “Route 53 Active-Passive” 配置中，活动状态通常指向一个实际提供服务的资源，比如一个服务器、虚拟机实例或应用程序。</li><li><strong>待命状态（Passive）：</strong> 这是系统中备用的、处于待命状态的资源。它不提供实际的服务，而是等待在活动状态不可用时接管服务。待命状态的资源会与活动状态资源保持同步，以确保数据的一致性。</li></ul><h3 id="Route-53故障转移的关键点如下："><a href="#Route-53故障转移的关键点如下：" class="headerlink" title="Route 53故障转移的关键点如下："></a><strong>Route 53故障转移</strong>的关键点如下：</h3><ol start="12"><li><strong>Failover Routing Policy</strong>：Route 53的Failover路由策略允许您配置主&#x2F;备份资源，以便在主资源不可用时自动将流量切换到备份资源。例如，您可以将流量引导到主要AWS区域中的资源，但如果该区域发生故障，Route 53可以将流量切换到另一个备份区域中的资源。</li><li><strong>Health Checks</strong>：您可以设置Route 53的健康检查来监控各个资源的可用性。当主资源不可用时，健康检查可以自动触发Route 53的Failover策略，将流量切换到备份资源。</li><li><strong>Global Accelerator Integration</strong>：Route 53可以与AWS Global Accelerator结合使用，以提供全球级别的流量管理和故障转移。Global Accelerator可以优化全球范围内的流量分发，确保将用户流量快速引导到最近的健康资源。</li><li><strong>Latency-Based Routing</strong>：虽然不直接是故障转移，但根据延迟的路由策略可以确保将用户流量引导到距离最近且延迟最低的资源，从而提高用户体验并减少延迟。</li></ol><h3 id="Routing-Policies-路由策略"><a href="#Routing-Policies-路由策略" class="headerlink" title="Routing Policies-路由策略"></a>Routing Policies-<strong>路由策略</strong></h3><ul><li><p>Defines how Route53 responds to DNS queries</p><p>  定义了如何将 DNS 查询路由到资源</p><p>  以下是展示 Amazon Route 53 不同路由策略及其特点和适用场景的表格：</p><table><thead><tr><th>路由策略</th><th>特点和适用场景</th></tr></thead><tbody><tr><td>简单路由策略（Simple）</td><td>流量路由到一个资源</td></tr><tr><td>权重路由策略（Weighted）</td><td>- 按照权重分配到不同资源</td></tr><tr><td>故障转移路由策略（Failover）</td><td>- 当活动实例<strong>未通过健康检查</strong>时，备用实例将接管并成为活动实例</td></tr><tr><td>基于延迟的路由策略（Latency）</td><td>- 重定向到距离用户最近的资源，适用于要求<strong>低延迟的全球性应用</strong>。</td></tr><tr><td>地理位置路由策略（Geolocation）</td><td>- 基于用户位置进行路由</td></tr><tr><td>多值路由策略（Multivalue）</td><td>- 用于将流量路由到多个资源</td></tr></tbody></table><p>  这个表格展示了 Amazon Route 53 不同的路由策略，以及每个策略的特点和适用场景。希望这能够帮助您更清楚地了解每种路由策略的用途和优势。</p></li></ul><h3 id="Simple-Routing（简单路由）"><a href="#Simple-Routing（简单路由）" class="headerlink" title="Simple Routing（简单路由）:"></a><strong>Simple Routing</strong>（简单路由）:</h3><ul><li>返回单个资源的所有记录</li><li>如果返回了多个相同记录的值，则客户端将随机选择一个</li><li>不能与健康检查相关联</li></ul><h3 id="Weighted-Routing（加权路由）"><a href="#Weighted-Routing（加权路由）" class="headerlink" title="Weighted Routing（加权路由）:"></a><strong>Weighted Routing</strong>（加权路由）:</h3><ul><li>control traffic by weight</li><li>can be associated with Health Checks</li><li>Assign a weight of 0 to a record to stop sending traffic to a resource • If all records have we</li><li><strong>按照权重分配到不同资源</strong></li><li>按权重控制流量</li><li>可以与健康检查相关联</li><li>将记录的权重分配为0，以停止向资源发送流量</li><li>如果所有记录的权重都为0，则不会向该资源发送流量</li></ul><h3 id="Failover-Routing（故障转移路由）"><a href="#Failover-Routing（故障转移路由）" class="headerlink" title="Failover Routing（故障转移路由）:"></a><strong>Failover Routing</strong>（故障转移路由）:</h3><ul><li>When an active instance failed the health check, the standby instance will failover and become active</li></ul><p>当<strong>活动实例未通过健康检查时，备用实例将接管并成为活动实例。</strong></p><h3 id="Latency-based-Routing（基于延迟的路由）"><a href="#Latency-based-Routing（基于延迟的路由）" class="headerlink" title="Latency-based Routing（基于延迟的路由）:"></a><strong>Latency-based Routing</strong>（基于延迟的路由）:</h3><ul><li>Redirect to the resource that has the least latency close to user</li><li>Latency is based on traffic between users and AWS Regions</li><li>Can be associated with Health Checks</li><li>重定向到距离用户最近的资源</li><li>延迟基于用户和AWS区域之间的流量</li><li>可以与健康检查相关联</li></ul><h3 id="Geolocation-Routing（地理位置路由）"><a href="#Geolocation-Routing（地理位置路由）" class="headerlink" title="Geolocation Routing（地理位置路由）:"></a><strong>Geolocation Routing</strong>（地理位置路由）:</h3><ul><li>This routing is based on user location</li><li>Can be associated with Health Checks</li></ul><h3 id="Multi-Value-Answer-Routing（多值回答路由）"><a href="#Multi-Value-Answer-Routing（多值回答路由）" class="headerlink" title="Multi-Value Answer Routing（多值回答路由）:"></a><strong>Multi-Value Answer Routing</strong>（多值回答路由）:</h3><ul><li>Use when routing traffic to multiple resources</li><li>Each resource receives a separate DNS response, and Route 53 responds to DNS queries with multiple IP addresses.</li><li>Can be associated with Health Checks (return only values for healthy resources)</li><li>用于将流量路由到多个资源</li><li>每个资源都会收到单独的 DNS 响应，并且 Route 53 会用多个 IP 地址响应 DNS 查询。</li><li>可以与健康检查相关联（仅返回健康资源的值）</li><li>有助于实现<strong>负载均衡</strong>和<strong>高可用性</strong>。</li></ul><h3 id="Geoproximity-Routing（地理接近路由）"><a href="#Geoproximity-Routing（地理接近路由）" class="headerlink" title="Geoproximity Routing（地理接近路由）:"></a><strong>Geoproximity Routing</strong>（地理接近路由）:</h3><ul><li>Route traffic to your resources based on the geographic location of users and resources</li><li>Ability to shift more traffic to resources based on the defined bias</li></ul><h3 id="Route-53-–-Records记录集"><a href="#Route-53-–-Records记录集" class="headerlink" title="Route 53 – Records记录集"></a><strong>Route 53 – Records</strong>记录集</h3><p>用于将域名映射到特定资源（例如IP地址、其他域名或负载均衡器）的信息</p><ul><li><strong>Domain&#x2F;subdomain Name</strong> – e.g., example.com</li><li><strong>Record Type</strong> – e.g., A or AAAA</li><li><strong>Value</strong> – e.g., 12.34.56.78</li><li><strong>Routing Policy</strong> – how Route 53 responds to queries</li><li><strong>TTL（time to live）</strong> – amount of time the record cached at DNS Resolvers</li></ul><h3 id="Record-Types-记录类型"><a href="#Record-Types-记录类型" class="headerlink" title="Record Types-记录类型"></a><strong>Record Types-记录类型</strong></h3><ul><li><strong>A</strong> – maps a hostname to IPv4</li><li><strong>AAAA</strong> – maps a hostname to IPv6</li><li><strong>CNAME</strong> – maps a hostname to another hostname<ul><li>The target is a domain name which must have an A or AAAA record</li><li>Can’t create a CNAME record for the top node of a DNS namespace (Zone Apex)</li><li>Example: you can’t create for example.com, but you can create for <a href="http://www.example.com/">www.example.com</a></li></ul></li><li><strong>NS</strong> – Name Servers for the Hosted Zone<ul><li>Control how traffic is routed for a domain</li></ul></li></ul><h3 id="hosted-zone-托管区域"><a href="#hosted-zone-托管区域" class="headerlink" title="hosted zone-托管区域"></a>hosted zone-托管区域</h3><p>Hosted Zone（托管区域）是一个与特定域名（例如 <a href="http://example.com/">example.com</a>）关联的 DNS 区域。它包含了该域名下所有 DNS 记录的信息，用于解析域名到相应的 IP 地址或其他资源。</p><p><strong>一个包含定义如何路由流量到域名及其子域名的记录的容器</strong></p><ul><li><strong>公有托管区域</strong><ul><li>包含指定如何在互联网上路由流量的记录</li></ul></li><li><strong>私有托管区域</strong><ul><li>包含指定如何在一个或多个VPC中路由流量的记录</li></ul></li><li>每个托管区域每月收取0.5美元的费用</li></ul><h3 id="Alias-Records-别名记录"><a href="#Alias-Records-别名记录" class="headerlink" title="Alias Records-别名记录"></a>Alias Records-<strong>别名记录</strong></h3><ul><li>将主机名映射到AWS资源</li><li>别名记录始终为AWS资源的类型A&#x2F;AAAA（IPv4&#x2F;IPv6）</li><li>您无法设置TTL, route53自动设置</li><li>您无法为EC2 DNS名称设置别名记录</li><li>You cannot set an ALIAS record for an EC2 DNS name</li></ul><h3 id="Health-Checks-健康检查"><a href="#Health-Checks-健康检查" class="headerlink" title="Health Checks-健康检查"></a>Health Checks-健康检查</h3><ul><li>HTTP Health Checks are only for public resources</li><li>Health Check &#x3D;&gt; Automated DNS Failover</li><li>健康检查与CloudWatch指标集成</li><li>配置路由器&#x2F;防火墙以允许来自Route 53 Health Checkers的传入请求</li></ul><h3 id="Health-checks-that-monitor-an-endpoint"><a href="#Health-checks-that-monitor-an-endpoint" class="headerlink" title="Health checks that monitor an endpoint"></a><strong>Health checks that monitor an endpoint</strong></h3><p>您可以配置运行状况检查来监控通过 IP 地址或域名指定的端点。Route 53 按照您指定的固定间隔，通过互联网向您的应用程序、服务器或其它资源自动提交请求，以验证其是否可到达、是否可用及功能是否正常。您也可以通过配置运行状况检查来发出与用户发出的请求类似的请求，如从特定 URL 请求网页。</p><h3 id="calculated-health-checks"><a href="#calculated-health-checks" class="headerlink" title="calculated health checks"></a><strong>calculated health checks</strong></h3><ul><li>Combine the results of multiple Health Checks into a single Health Check</li><li>You can use OR, AND, or NOT</li><li>Can monitor up to 256 Child Health Checks</li><li>Specify how many of the health checks need to pass to make the parent pass</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS-11【Storage Gateway】</title>
      <link href="/2023/08/15/AWS-13%E3%80%90Storage%20Gateway%E3%80%91/"/>
      <url>/2023/08/15/AWS-13%E3%80%90Storage%20Gateway%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Storage-Gateway-混合存储"><a href="#Storage-Gateway-混合存储" class="headerlink" title="Storage Gateway-混合存储"></a><strong>Storage Gateway-混合存储</strong></h1><p><strong>Storage Gateway-混合存储</strong><br><img src="/images/Untitled%2038.png" alt="Untitled"></p><p><strong>在本地环境和AWS云存储之间建立连接</strong></p><p>AWS Storage Gateway充当本地应用和AWS云存储之间的桥梁，使您能够轻松<strong>扩展本地存储容量</strong>，将本地数据备份到AWS云中，并在本地应用和AWS云存储之间实现<strong>无缝的数据迁移</strong>。</p><p><img src="/images/Untitled%2039.png" alt="Untitled"></p><ul><li>文件网关接口：NFS 和 SMB。</li></ul><p>NFS和SMB都是用于文件共享的协议：</p><ol><li>NFS（Network File System）：NFS是一种用于在计算机网络中共享文件的协议，最初由Sun Microsystems开发。它允许不同操作系统的计算机之间通过网络访问和共享文件和目录。NFS主要在Unix和Linux系统中使用。</li><li>SMB（Server Message Block）：SMB是一种用于共享文件、打印机和其他资源的网络协议，最初由微软开发，后来被称为CIFS（Common Internet File System）。SMB&#x2F;CIFS协议通常用于Windows操作系统中的文件和打印机共享。</li></ol><p>在S3文件网关的情境中，NFS和SMB是用于创建本地网络共享，使得应用程序可以通过这些共享访问存储在Amazon S3中的数据。</p><h2 id="use-cases"><a href="#use-cases" class="headerlink" title="use cases"></a>use cases</h2><ol><li><strong>Backup &amp; recovery</strong></li><li><strong>Disaster Recovery</strong></li><li><strong>Local Storage Extension</strong></li><li><strong>tiered storage</strong></li><li><strong>Data Archiving and Long-Term Storage数据归档和长期存储</strong></li><li><strong>Cloud Backup and Data Migration云中备份和数据迁移</strong></li><li><strong>Hybrid Cloud Environments混合云环境</strong></li></ol><h2 id="部署模式"><a href="#部署模式" class="headerlink" title="部署模式"></a>部署模式</h2><p><img src="/images/Untitled%2040.png" alt="Untitled"></p><h3 id="S3-File-Gateway："><a href="#S3-File-Gateway：" class="headerlink" title="S3 File Gateway："></a><strong>S3 File Gateway</strong>：</h3><p><strong>S3文件网关特点：</strong></p><ul><li>将S3文件网关部署在本地，作为本地文件系统和Amazon S3                                                                      之间的桥梁。</li><li>支持四种存储网关类型：文件、卷、缓存和虚拟带。</li><li>可以<strong>使用文件共享协议（NFS、SMB）访问存储在Amazon S3中的数据</strong>。</li><li>文件网关提供本地缓存，可以缓存频繁访问的数据，提供更快的访问速度。</li><li>支持数据在本地缓存和Amazon S3之间的自动传输。</li></ul><p><strong>适合使用场景：</strong></p><ul><li>需要在本地应用程序和Amazon S3之间建立文件共享的场景。</li><li>需要快速访问本地缓存数据和远程S3数据的应用程序，提高数据访问速度。</li><li>需要自动化数据传输，将本地数据定期或按需上传到Amazon S3中。</li><li>适用于文件备份、归档、协作等需要本地和云存储的场景。</li></ul><p><img src="/images/Untitled%2041.png" alt="Untitled"></p><h3 id="FSx-File-Gateway"><a href="#FSx-File-Gateway" class="headerlink" title="FSx  File Gateway"></a>FSx  <strong>File Gateway</strong></h3><p><img src="/images/Untitled%2042.png" alt="Untitled"></p><h3 id="Volume-Gateway-卷网关"><a href="#Volume-Gateway-卷网关" class="headerlink" title="Volume Gateway-卷网关"></a><strong>Volume Gateway-卷网关</strong></h3><ul><li><strong>缓存卷（Cached Volumes）</strong>：在<strong>本地缓存中保留常用数据</strong>，将数据异步上传到云中。适用于需要低延迟访问的应用程序。<ul><li>缓存卷的大小范围可以是 1 GiB 到 32 TiB</li></ul></li><li><strong>存储卷（Stored Volumes）</strong>：将<strong>数据完全保存在本地</strong>，并异步备份到云中。适用于需要在本地保留副本的应用程序。<ul><li>存储卷的大小范围从1gib到16tib</li></ul></li></ul><p><img src="/images/Untitled%2043.png" alt="Untitled"></p><p>卷网关允许您在本地创建iSCSI（Internet Small Computer System Interface）卷，将卷视为本地存储设备。然后，您可以通过卷网关将这些iSCSI卷的快照备份到AWS S3或AWS EBS（Elastic Block Store）卷中。</p><p>适用于将本地存储扩展到云中或进行数据备份和灾难恢复的场景。</p><ul><li>特点：提供iSCSI协议的块级别访问，允许在本地服务器上挂载虚拟卷。分为缓存卷和存储卷两种模式，数据可以部分或完全存储在云中。</li></ul><h3 id="Tape-Gateway-虚拟磁带库存储网关"><a href="#Tape-Gateway-虚拟磁带库存储网关" class="headerlink" title="**Tape Gateway-**虚拟磁带库存储网关"></a>**Tape Gateway-**虚拟磁带库存储网关</h3><p><img src="/images/Untitled%2044.png" alt="Untitled"></p><p>虚拟磁带库允许您在本地创建虚拟磁带库，将虚拟磁带视为磁带存储设备。您可以通过虚拟磁带库将磁带数据备份到AWS S3 Glacier或AWS S3 Glacier Deep Archive中，以实现长期数据归档和存储。</p><ul><li>特点：模拟磁带库，允许将备份和归档数据保存为虚拟磁带，并将其存储在Amazon S3中。<strong>适用于长期数据保留和归档</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS-10【DynamoDB】</title>
      <link href="/2023/08/12/AWS-10%E3%80%90DynamoDB%E3%80%91/"/>
      <url>/2023/08/12/AWS-10%E3%80%90DynamoDB%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="DynamoDB"><a href="#DynamoDB" class="headerlink" title="DynamoDB"></a>DynamoDB</h1><p><img src="/images/Untitled%2031.png" alt="Untitled"></p><p>Amazon DynamoDB 是一种全托管式 NoSQL 数据库服务，可提供快速且可预测的性能，能够实现无缝扩展。</p><ul><li>完全托管，高可用性，在多个可用区进行复制</li><li>NoSQL database - 不是关系型数据库</li><li><ul><li>with transaction support</li></ul></li><li>可扩展到大规模工作负载，<strong>分布式数据库distributed database</strong></li><li>每秒数百万次请求，数万亿行数据，数百TB的存储</li><li>高性能且稳定（单位数<strong>毫秒级</strong>）</li><li>与IAM集成以提供安全性、授权和管理</li><li>低成本和自动扩展能力</li><li>无需维护或打补丁，始终可用No maintenance or patching, always available</li><li>标准和低频访问（IA）表格类型</li></ul><aside>🍁 DynamoDB 在许多应用场景中得到广泛应用，包括 Web 应用程序、移动应用程序、游戏、物联网（IoT）设备、实时分析等。它的高可用性、弹性扩展性和低延迟性能使其成为处理大规模非结构化数据的优秀选择。</aside><h2 id="capacity-modes-数据流容量模式"><a href="#capacity-modes-数据流容量模式" class="headerlink" title="capacity modes-数据流容量模式"></a>capacity modes-数据流<em>容量模式</em></h2><p>在 DynamoDB 中，读取和写入容量模式是一种用于配置表格吞吐量的选项:</p><ol><li><p><strong>Provisioned Capacity Mode（预配置容量模式）default：</strong></p><p> default<br> 在预配置容量模式下，您需要在创建表格时显式指定预期的读取容量单位（Read Capacity Units，RCUs）和写入容量单位（Write Capacity Units，WCUs）。每个 RCU 和 WCU 表示每秒钟读取或写入项目的数量。根据您的配置，DynamoDB 将分配所需的硬件资源来支持指定的吞吐量。</p></li></ol><p>预配置容量模式适用于具有<strong>可预测和稳定流量</strong>的应用程序。您可以根据业务需求预先分配容量，并根据需要随时进行调整。这种模式允许您更精确地控制和优化数据库的性能和成本。</p><ol start="2"><li><p><strong>On-Demand Capacity Mode（点播&#x2F;按需容量模式）：</strong><br>在按需容量模式下，DynamoDB 会根据您的实际读取和写入请求的数量动态地自动缩放表格的吞吐量。您无需预先配置 RCUs 和 WCUs，只需根据实际使用情况支付实际使用的读写吞吐量。</p><p> 按需容量模式适用于具有<em>不稳定和不可预测</em>流量的应用程序</p></li></ol><p>。它提供了更大的灵活性和简便性，无需手动管理吞吐量配置。按需模式适用于突发性负载或流量波动较大的场景，因为它可以自动缩放以满足您的应用需求，同时避免了预配置容量可能带来的浪费。</p><p><img src="/images/Untitled%2032.png" alt="Untitled"></p><h3 id="DynamoDB-Global-Tables"><a href="#DynamoDB-Global-Tables" class="headerlink" title="DynamoDB Global Tables"></a><strong>DynamoDB Global Tables</strong></h3><p>DynamoDB Global Tables是一种全球性的多主区域数据库解决方案。它允许您在不同AWS区域中创建多个DynamoDB副本，并确保这些副本之间的数据同步。这样可以实现数据的全球性复制和低延迟的读写操作。</p><ul><li><strong>多主区域数据库</strong>：每个区域中的DynamoDB表格都可以作为主表（Master Table），允许在该区域内执行读写操作。这样，当数据写入到一个区域时，会自动复制到其他区域中的主表。</li><li><strong>自动复制和同步</strong></li><li><strong>低延迟访问</strong></li></ul><p><img src="/images/Untitled%2033.png" alt="Untitled"></p><h3 id="DynamoDB-Backup-备份"><a href="#DynamoDB-Backup-备份" class="headerlink" title="DynamoDB Backup-备份"></a><strong>DynamoDB Backup-备份</strong></h3><p>DynamoDB Backup是一种全托管的备份服务，可用于定期备份DynamoDB表格的数据。备份可以保留在AWS中，以防止意外数据丢失或系统故障。</p><ul><li><strong>全托管备份</strong>：DynamoDB Backup由AWS完全管理，您无需关心备份的维护和管理。您可以使用AWS控制台或AWS SDK创建和管理备份。</li><li><strong>点-in-time恢复</strong>：备份不仅可以用于恢复整个表格，还支持<strong>点-in-time</strong>恢复。这允许您将表格恢复到特定时间点之前的状态。</li><li><strong>自动保留</strong>：您可以设置备份的保留期，AWS将自动保留备份，并在保留期过后自动删除旧备份。</li></ul><h3 id="DynamoDB与S3的集成"><a href="#DynamoDB与S3的集成" class="headerlink" title="DynamoDB与S3的集成:"></a><strong>DynamoDB与S3的集成</strong>:</h3><p>DynamoDB与Amazon S3之间有多种集成方式，这可以帮助您更好地处理和存储数据。</p><ul><li><p><strong>DynamoDB Streams与Lambda集成</strong>：DynamoDB Streams是一种记录表格中数据更改的数据流服务。您可以使用AWS Lambda来订阅DynamoDB Streams，然后根据数据更改触发特定的逻辑和处理。这样，您可以在表格中的数据发生变化时，自动触发Lambda函数，处理和分析数据。</p></li><li><p><strong>DynamoDB导出到S3</strong>：您可以使用DynamoDB的数据导出功能将表格中的数据导出到Amazon S3中。导出后的数据可以用于数据备份、数据分析和长期存储等用途。</p></li><li><p><strong>DynamoDB与S3之间的数据交互</strong>：您可以编写AWS Lambda函数，实现DynamoDB表格与S3之间的数据同步和交互。这可以帮助您将数据从DynamoDB表格导出到S3，或者将S3中的数据导入到DynamoDB表格中。</p><p>  <img src="/images/Untitled%2034.png" alt="Untitled"></p></li></ul><h3 id="Stream-Processing-数据流处理"><a href="#Stream-Processing-数据流处理" class="headerlink" title="Stream Processing (数据流处理):"></a><strong>Stream Processing (数据流处理)</strong>:</h3><p>DynamoDB Streams和AWS Lambda结合使用，使得实时数据流处理变得非常方便。数据流处理允许您实时地对DynamoDB表格中的数据更改进行处理和分析。</p><ul><li><strong>数据流订阅</strong>：使用AWS Lambda函数订阅DynamoDB Streams，以便在数据更改时自动触发Lambda函数。</li><li><strong>实时处理</strong>：当表格中的数据更改时，DynamoDB Streams会捕获这些变化，并将记录发送给Lambda函数。Lambda函数可以实时处理这些数据，执行特定的业务逻辑或将数据发送到其他服务。</li><li><strong>数据流处理的用途</strong>：数据流处理可以用于实时数据分析、数据同步、业务逻辑处理、监控和告警等场景。</li></ul><aside>🍁 use case典型使用场景：</aside><ol start="3"><li>react to changes in real-time (welcome email to new users)</li><li>real-time analytics-<strong>实时数据分析</strong>：通过订阅DynamoDB Streams并使用AWS Lambda函数来实时处理表格中的数据变更，可以进行实时数据分析和计算。</li><li><strong>数据同步</strong>：在多个DynamoDB表格之间进行数据同步是常见的应用场景。通过DynamoDB Streams，您可以捕获一个表格的数据变更，并将这些变更实时地复制到其他表格中，从而保持数据的一致性。</li><li><strong>触发事件</strong>：DynamoDB Streams可以作为触发器，当表格中的数据发生变更时，自动触发相应的事件。这可以用于实现业务流程、发送通知、执行后续操作等。</li><li><strong>实时通知</strong>：通过订阅DynamoDB Streams并与其他服务集成，可以实现实时通知。例如，当有新数据插入到DynamoDB表格中时，可以触发Lambda函数发送实时通知到移动设备或者Web应用程序。</li><li><strong>实时监控</strong>：利用DynamoDB Streams和Lambda函数，可以实现对表格的实时监控。您可以设置特定的数据变更规则，当满足条件时，触发监控和告警操作。</li><li><strong>版本控制</strong>：通过DynamoDB Streams，可以记录数据变更的历史，并实现数据的版本控制。这有助于跟踪和回溯数据的变更历史。</li><li><strong>数据审计</strong>：DynamoDB Streams可以用于数据审计目的，记录表格中的数据变更和操作，确保数据的安全性和合规性。</li></ol><p>总体而言，DynamoDB Stream Processing为DynamoDB表格的实时处理提供了强大的功能和灵活性。它可以与其他AWS服务集成，帮助您构建强大的实时数据处理和响应机制，从而更好地满足业务需求和用户期望。</p><p><img src="/images/Untitled%2035.png" alt="Untitled"></p><h3 id="dynamoDB-scream-VS-kinesis-data-scream"><a href="#dynamoDB-scream-VS-kinesis-data-scream" class="headerlink" title="dynamoDB scream VS kinesis data scream"></a>dynamoDB scream <strong>VS</strong> kinesis data scream</h3><table><thead><tr><th>特性</th><th>DynamoDB Streams</th><th>Kinesis Data Streams</th></tr></thead><tbody><tr><td><strong>Retention（数据保留期限）</strong></td><td>24小时</td><td>按需配置，默认值 24 小时。最长365天</td></tr><tr><td><strong>消费者数量</strong></td><td>limit</td><td>high</td></tr><tr><td>数据源和目的地的集成</td><td>主要用于DynamoDB，与Lambda函数</td><td>适用于多种数据源和目的地</td></tr><tr><td>数据目的</td><td>实时处理和分析</td><td>实时处理和分析</td></tr><tr><td>数据传递方式</td><td>服务器推送</td><td>客户端拉取</td></tr><tr><td>可订阅的事件</td><td>插入、更新、删除</td><td>数据记录</td></tr><tr><td>数据延迟</td><td>通常为毫秒级</td><td>可以自行配置</td></tr></tbody></table><ol start="11"><li><strong>Retention（数据保留期限）</strong>：<ul><li>DynamoDB Streams：默认的数据保留期限是24小时，即数据变更记录在DynamoDB Streams中保留24小时，过期后会自动删除。</li><li>Kinesis Data Streams：数据保留期限可以根据需求进行配置，最长可达7天，可以设置数据在Stream中保留的时间。</li></ul></li><li><strong>Of Consumers（消费者）</strong>：<ul><li>DynamoDB Streams：DynamoDB Streams主要用于实时处理DynamoDB表格中的数据变更。消费者通常是AWS Lambda函数，可以使用Lambda函数订阅DynamoDB Streams，并在数据变更时触发Lambda函数执行特定逻辑。</li><li>Kinesis Data Streams：Kinesis Data Streams适用于多种数据源，并可以根据业务需求实现实时处理和分析。消费者可以是Lambda函数，也可以是自行实现的Kinesis Client Library。</li></ul></li><li><strong>Processing Using（数据处理方式）</strong>：<ul><li>DynamoDB Streams：主要用于实时处理DynamoDB表格中的数据变更，通常与Lambda函数结合使用。Lambda函数可以对数据变更进行实时处理，比如计算、聚合、触发事件等。</li><li>Kinesis Data Streams：适用于多种数据源和场景，数据消费者可以根据需求自行实现数据处理逻辑。Kinesis Data Streams通常用于实时数据流处理，如设备数据采集、日志数据处理、实时监控等。</li></ul></li></ol><h3 id="DynamoDB-Accelerator-DAX"><a href="#DynamoDB-Accelerator-DAX" class="headerlink" title="DynamoDB Accelerator-DAX"></a>DynamoDB Accelerator-DAX</h3><ul><li><strong>DAX集群用于读取缓存，微秒级读取延迟</strong></li></ul><p>AWS 提供的全托管的缓存服务，专门为<strong>加速 Amazon DynamoDB 数据库的读取操作</strong>而设计。</p><p>它允许您将缓存层置于 DynamoDB 之前，从而显著提高读取操作的性能，降低对 DynamoDB 的负载压力，并降低应用程序的延迟。</p><p>DAX 具有以下关键特点和优势：</p><ol start="14"><li><strong>高性能缓存：</strong> DAX 使用一个分布式内存缓存，可以存储 DynamoDB 表中经常访问的数据。这使得读取操作可以在缓存中完成，从而大大加快响应时间和降低 DynamoDB 的负载。</li><li><strong>无缝集成：</strong> DAX 可以无缝集成到现有的 DynamoDB 应用程序中，无需更改应用程序代码。通过使用 DAX，您的应用程序可以保持对 DynamoDB 表的相同访问模式，但获得更快的响应时间。</li><li><strong>自动缓存管理：</strong> DAX 提供自动缓存管理，会根据数据的使用频率和模式来自动填充和更新缓存。这样，您无需手动管理缓存，可以专注于应用程序的开发。</li><li><strong>高可用性：</strong> DAX 提供多个可用区的多活功能，以实现高可用性和容错性。它在多个可用区内复制缓存数据，以保证缓存的可用性。</li><li><strong>安全性：</strong> DAX 与 DynamoDB 一样，提供了多层级的安全性措施，包括 VPC 网络隔离、IAM 访问控制和加密。</li><li><strong>降低成本：</strong> 通过使用 DAX，您可以显著降低 DynamoDB 的读取操作费用，因为 DAX 缓存数据后，大部分读取操作都可以在缓存中完成，无需访问 DynamoDB 表。</li></ol><p>DAX 适用于需要高度响应性和低延迟的读取操作的应用程序，特别是对于具有高流量的读取工作负载的应用程序。它可以显著提高应用程序的性能，并为用户提供更好的体验，同时还可以降低与 DynamoDB 读取操作相关的费用。</p><h2 id="DAX（DynamoDB-Accelerator）和-Elasticache"><a href="#DAX（DynamoDB-Accelerator）和-Elasticache" class="headerlink" title="DAX（DynamoDB Accelerator）和 Elasticache"></a>DAX（DynamoDB Accelerator）和 Elasticache</h2><ol start="20"><li><strong>适用的数据库：</strong><ul><li>DAX 是专门为加速 Amazon DynamoDB 的读取操作而设计的缓存服务。它与 DynamoDB 密切集成，通过将缓存层置于 DynamoDB 之前，加快读取操作的性能。</li><li>Elasticache 是 AWS 提供的通用缓存服务，支持多种缓存引擎，如 Redis 和 Memcached。它可以用于缓存各种数据库的查询结果、计算结果或应用程序的状态，不限于特定数据库。</li></ul></li><li><strong>目标数据库类型：</strong><ul><li>DAX 主要用于加速 DynamoDB 的读取操作，对于写入操作（写入数据到 DynamoDB 表）仍然需要直接访问 DynamoDB。</li><li>Elasticache 可以用于任何需要缓存的应用场景，无论是读取还是写入操作。</li></ul></li><li><strong>缓存引擎：</strong><ul><li>DAX 使用一个专门针对 DynamoDB 设计的缓存引擎，支持高性能和自动缓存管理。</li><li>Elasticache 支持多种缓存引擎，包括 Redis 和 Memcached。您可以根据应用程序的需求选择合适的缓存引擎。</li></ul></li><li><strong>特定应用场景：</strong><ul><li>DAX 适用于对 DynamoDB 读取操作延迟要求较高的应用场景。当应用程序需要频繁读取 DynamoDB 表的数据，并且要求低延迟和高吞吐量时，DAX 可以显著提高性能。</li><li>Elasticache 适用于各种应用程序，特别是需要缓存读取结果、频繁访问外部数据源、降低数据库负载压力或提供临时计算结果的场景。</li></ul></li><li><strong>集群规模：</strong><ul><li>DAX 可以配置成多个节点的集群，但其规模通常不会像 Elasticache 那样大，因为 DAX 主要用于加速 DynamoDB 读取操作，而 DynamoDB 本身已经具有高度的水平扩展性。</li><li>Elasticache 可以根据需求配置成更大规模的缓存集群，以支持大量的缓存数据和高并发访问。</li></ul></li></ol><p>总的来说，DAX 是专为加速 DynamoDB 读取操作而设计的缓存服务，针对 DynamoDB 表的读取优化。而 Elasticache 则是通用的缓存服务，可以用于任何需要缓存的应用场景，支持多种缓存引擎，并适用于各种不同类型的数据库和应用程序。</p><p><img src="/images/Untitled%2036.png" alt="Untitled"></p><p>DynamoDB Accelerator (DAX) 为访问最终一致性数据提供快速响应时间。</p><p><img src="/images/Untitled%2037.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS-09【ElastiCache】</title>
      <link href="/2023/08/11/AWS-11%E3%80%90ElastiCache%E3%80%91/"/>
      <url>/2023/08/11/AWS-11%E3%80%90ElastiCache%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Amazon-ElastiCache"><a href="#Amazon-ElastiCache" class="headerlink" title="Amazon ElastiCache"></a><strong>Amazon ElastiCache</strong></h1><p><img src="/images/Untitled%2030.png" alt="Untitled"></p><p><code>缓存是一种用于提高数据访问性能的技术，通过将数据存储在高速存储介质（如内存）中，避免了频繁从慢速的数据存储（如数据库）中读取数据。</code></p><p>doesn’t cache at <em><strong>edge locations</strong></em></p><p>Amazon ElastiCache允许您在云中轻松创建和管理cache。</p><p>缓存是一种快速存储数据的方法，可以加快应用程序的速度。</p><p>它提供了高性能、低延迟的内存数据库，用于缓存数据。</p><ul><li>ElastiCache支持两种流行的缓存引擎：Redis和Memcached。</li><li><strong>内存数据库（Caches）的高性能和低延迟：</strong> ElastiCache提供了高性能和低延迟的内存数据库，允许您在内存中存储和检索数据，从而加快数据访问速度。</li><li><strong>减轻数据库负载：</strong> 使用ElastiCache可以将读取密集型工作负载的负载转移到缓存数据库中，从而减轻主数据库的负载，提高数据库的性能和响应能力。</li><li><strong>用户会话存储：</strong> ElastiCache还可以用作应用程序的用户会话存储，帮助使应用程序无状态化。通过将用户会话存储在缓存中，可以实现应用程序的无状态设计，从而更好地处理负载均衡和可扩展性。</li><li><strong>AWS管理和维护：</strong> Amazon ElastiCache负责托管Redis或Memcached的操作系统维护、补丁管理、性能优化、设置、配置、监控、故障恢复和备份。这样，您无需担心底层基础设施和管理任务。</li><li><strong>应用程序代码更改：</strong> 使用ElastiCache通常需要对应用程序代码进行适度的更改，以支持缓存功能。例如，您需要调整应用程序的读取逻辑，以先查找缓存，如果缓存中没有，则再查找主数据库。</li></ul><p><strong>Redis与Memcached对比：</strong></p><table><thead><tr><th>特征</th><th>Redis</th><th>Memcached</th></tr></thead><tbody><tr><td>数据结构支持</td><td>支持更丰富的数据结构，如字符串、哈希、列表、集合、有序集等</td><td>仅支持简单的键值对存储</td></tr><tr><td>persistent data持久化数据</td><td>✅</td><td>❌</td></tr><tr><td>replication</td><td>✅</td><td>❌</td></tr><tr><td>backup and restore</td><td>✅</td><td>❌</td></tr><tr><td>多节点分区</td><td>✅</td><td>✅</td></tr><tr><td>多线程支持</td><td>单线程</td><td>多线程</td></tr><tr><td>适用场景</td><td>复杂数据结构、持久化需求、<strong>高可用性</strong></td><td>简单键值对缓存、高性能需求</td></tr></tbody></table><h2 id="Cache-Security"><a href="#Cache-Security" class="headerlink" title="Cache Security"></a><strong>Cache Security</strong></h2><ul><li>All caches in ElastiCache:<ul><li>不支持IAM身份验证</li><li>ElastiCache上的IAM策略仅用于AWS API级别的安全性</li></ul></li><li>Redis认证（AUTH）：<ul><li>令牌：You can set a “password&#x2F;token” when you create a Redis cluster</li><li>This is an extra level of security for your cache (<strong>on top of security groups</strong>)</li><li>Support SSL in flight encryption</li></ul></li><li>Memcached<ul><li>支持基于SASL的身份验证（高级功能）</li></ul></li></ul><h2 id="patterns-for-ElasticCache"><a href="#patterns-for-ElasticCache" class="headerlink" title="patterns for ElasticCache"></a>patterns for ElasticCache</h2><p><strong>Lazy Loading (延迟加载)：</strong><br>这个方法很lazy，读取数据首先检查cache里面有没有，有的话直接读取，没有再到持久性数据储存中读取。但这样导致cache里的数据可能会过时，必须额外设置更新数据</p><p><strong>Write-through (写入透穿)：</strong><br>在写入数据库时同时将数据添加或更新到缓存中</p><p><strong>Session Store (会话存储)：</strong><br>将临时会话数据存储在缓存中（使用TTL功能）。</p><h2 id="ElastiCache-–-Redis-Use-Case"><a href="#ElastiCache-–-Redis-Use-Case" class="headerlink" title="ElastiCache – Redis Use Case"></a><strong>ElastiCache – Redis Use Case</strong></h2><ul><li>游戏排行榜的复杂计算</li><li>Redis排序集保证了唯一性和元素顺序</li><li>每次添加新元素时，都会对其进行实时排名，然后添加到正确的顺序</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS-09【Amazon Aurora】</title>
      <link href="/2023/08/10/AWS-09%E3%80%90Amazon%20Aurora%E3%80%91/"/>
      <url>/2023/08/10/AWS-09%E3%80%90Amazon%20Aurora%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="Amazon-Aurora"><a href="#Amazon-Aurora" class="headerlink" title="Amazon Aurora"></a><strong>Amazon Aurora</strong></h2><p><img src="/images/Untitled%2026.png" alt="Untitled"></p><p>Amazon Aurora 是一款完全托管式关系数据库引擎，专为云端打造，与 MySQL 和 PostgreSQL 兼容。Amazon Aurora 是 Amazon RDS 的一部分。</p><p><strong>separation of storage and compute</strong></p><ul><li>Aurora is a proprietary technology from AWS (not open sourced)</li><li>Postgres and MySQL are both supported as Aurora DB (that means your drivers will work as if Aurora was a Postgres or MySQL database)</li><li>Aurora被称为“AWS云优化”，声称相比RDS上的MySQL，性能提高了5倍，比RDS上的PostgreSQL性能提高了3倍。</li><li>Aurora存储会自动以10GB为增量增长，最高可达128TB。</li><li>Aurora最多可以有**15个raplica，而MySQL只能有5个，**并且复制过程更快（副本延迟低于10毫秒）。</li><li>Aurora的故障切换是即时的。它具有本地高可用性（High Availability）。</li><li>Aurora的成本比RDS更高（高出20%），但更高效。</li></ul><h3 id="Aurora-High-Availability-and-Read-Scaling"><a href="#Aurora-High-Availability-and-Read-Scaling" class="headerlink" title="Aurora High Availability and Read Scaling"></a><strong>Aurora High Availability and Read Scaling</strong></h3><ul><li>数据在3个AZ中有6个copies：<ul><li>对于写入，需要6个副本中的4个。</li><li>对于读取，需要6个副本中的3个。</li><li>使用点对点复制实现自动修复。</li><li>存储跨数百个卷进行条带化（striped）。</li></ul></li><li>一个Aurora实例用于写入（master）。</li><li>automated failover for instance for master in less then 30s</li><li>主实例和最多15 Aurora Read Replicas serve用于读取服务。</li><li><strong>支持跨区域复制（Cross Region Replication）</strong>。</li></ul><h3 id="Aurora-DB-Cluster"><a href="#Aurora-DB-Cluster" class="headerlink" title="Aurora DB Cluster"></a>Aurora DB Cluster</h3><p><img src="/images/Untitled%2027.png" alt="Untitled"></p><h3 id="Aurora-replicas-auto-scaling"><a href="#Aurora-replicas-auto-scaling" class="headerlink" title="Aurora replicas -auto scaling"></a>Aurora replicas -auto scaling</h3><p><img src="/images/Untitled%2028.png" alt="Untitled"></p><h3 id="Aurora-–-Custom-Endpoints"><a href="#Aurora-–-Custom-Endpoints" class="headerlink" title="Aurora – Custom Endpoints"></a><strong>Aurora – Custom Endpoints</strong></h3><ul><li>将一组Aurora实例定义为自定义终端节点。</li><li>示例：在特定副本上运行分析查询。</li><li>在定义自定义终端节点后，通常不再使用读取终端节点（Reader Endpoint）。</li></ul><p><img src="https://img2022.cnblogs.com/blog/2122768/202204/2122768-20220417155832116-1925105483.png" alt="https:&#x2F;&#x2F;img2022.cnblogs.com&#x2F;blog&#x2F;2122768&#x2F;202204&#x2F;2122768-20220417155832116-1925105483.png"></p><h3 id="Aurora-serverless"><a href="#Aurora-serverless" class="headerlink" title="Aurora serverless"></a>Aurora serverless</h3><p>可以根据实际负载需求自动调整数据库的计算容量，从而实现按需自动缩放。</p><ol><li><strong>自动扩展和缩减</strong>：Aurora Serverless可以根据负载自动增加或减少计算容量，确保数据库能够高效地处理变化的工作负载，同时最大程度地降低成本。</li><li><strong>无需管理实例大小</strong>：用户无需手动配置数据库实例的大小，Aurora Serverless会自动处理资源调整。</li><li><strong>暂停和恢复功能</strong>：当数据库不活动时，Aurora Serverless可以自动暂停实例，从而节省资源并降低成本。一旦有查询请求或数据库活动，它会快速恢复并处理请求。</li><li><strong>基于秒级的计费</strong>：Aurora Serverless按照数据库使用的秒数进行计费，这意味着您只需支付实际使用的资源量。</li></ol><aside>🐳 适合infrequent不频繁, intermittent间歇性 or unpredictable 不可预测的workloads</aside><aside>🐳 对数据库负载有波动性的场景，如开发和测试环境、不规则的工作负载和季节性业务。</aside><h3 id="Aurora-Multi-master"><a href="#Aurora-Multi-master" class="headerlink" title="Aurora Multi-master"></a>Aurora Multi-master</h3><p>传统的数据库系统通常只有一个主节点，所有写入操作都要经过该主节点处理，这可能会成为瓶颈并限制数据库的写入吞吐量。而Aurora Multi-Master则允许多个主实例并行处理写入请求，从而显著提高了数据库的写入性能和容量。</p><p>主要特点如下：</p><ol><li><strong>多主节点</strong>：Aurora Multi-Master允许在Aurora集群中配置多个主节点，每个主节点都可以处理写入请求。</li><li><strong>并行写入</strong>：由于有多个主节点，写入操作可以并行处理，这样大大提高了数据库的写入吞吐量。</li><li><strong>高可用性</strong>：每个主节点都具有独立的网络和存储，因此即使某个主节点发生故障，其他主节点仍然可以继续处理写入请求，确保数据库的高可用性。</li><li><strong>读取负载均衡</strong>：Aurora Multi-Master还支持读取负载均衡，多个主节点可以处理读取请求，从而进一步提高数据库的读取性能。</li></ol><p>Aurora Multi-Master适用于高写入负载的场景，例如大规模的写入操作、高并发的写入请求或需要实时同步多个数据源的应用程序。通过允许多个主节点处理写入请求，Aurora Multi-Master提供了更高的可伸缩性和性能，使得数据库可以更好地适应大规模的写入操作。</p><h3 id="Global-Aurora"><a href="#Global-Aurora" class="headerlink" title="Global Aurora"></a><strong>Global Aurora</strong></h3><p><strong>Aurora multi-AZ replicas：用于disaster recovery</strong></p><p>这种设置适用于非常关键的应用程序，因为它提供了最小的故障恢复时间，但它并不提供在另一个区域中实时写入的能力。</p><p>-<br>    - 每个辅助区域最多16个 read replica<br>    - 有助于降低延迟<br>    - 将另一个区域提升为主要区域（用于灾难恢复）的恢复时间目标（RTO）小于1分钟<br>    - replicate data across-region takes less than 1s</p><h3 id="Aurora-Database-Cloning"><a href="#Aurora-Database-Cloning" class="headerlink" title="Aurora Database Cloning"></a>Aurora Database Cloning</h3><p>create a new aurora DB cluster from an existing one</p><p>faster than snapshot &amp; restore</p><ol><li><strong>快速创建准确副本</strong>：Aurora数据库克隆使用现有数据库的快照创建副本，因此它是原始数据库的准确复制。这个过程是非常快速的，不需要从头开始复制和创建数据库。</li><li><strong>节省时间和资源</strong>：通过克隆，您无需手动配置新的数据库实例，从头开始加载数据，或者执行其他复杂的操作。这节省了时间和资源，使得数据库克隆非常便捷。</li><li><strong>测试和开发</strong>：Aurora数据库克隆非常适合用于测试和开发环境。您可以创建数据库的克隆副本，并在测试或开发环境中使用它，而不影响生产环境的数据库。</li><li><strong>数据分析和报告</strong>：您可以使用克隆数据库来进行数据分析、生成报告以及运行复杂查询，而无需在生产数据库上执行这些操作，从而减少生产数据库的负担。</li><li><strong>数据库快照</strong>：数据库克隆是基于现有数据库的快照创建的。因此，在克隆数据库上执行的任何更改不会影响原始数据库</li></ol><p><img src="/images/Untitled%2029.png" alt="Untitled"></p><h3 id="RDS-Aurora-Security"><a href="#RDS-Aurora-Security" class="headerlink" title="RDS &amp; Aurora Security"></a><strong>RDS &amp; Aurora Security</strong></h3><h4 id="1-静态加密（At-rest-encryption）"><a href="#1-静态加密（At-rest-encryption）" class="headerlink" title="1 **-**静态加密（At rest encryption）"></a>1 **-**静态加密（At rest encryption）</h4><ul><li>可以使用AWS KMS（Key Management Service）的AES-256加密，对主数据库和只读副本进行加密。</li><li>加密必须在启动时定义。</li><li>如果主数据库未加密，则无法对只读副本进行加密。</li><li>对已存在的未加密数据库进行加密，可以通过创建数据库快照，并在恢复时选择使用加密方式进行恢复，以实现加密功能</li></ul><h4 id="2-动态加密（In-flight-encryption）"><a href="#2-动态加密（In-flight-encryption）" class="headerlink" title="2-动态加密（In-flight encryption）"></a>2-动态加密（In-flight encryption）</h4><ul><li>默认支持TLS，客户端使用AWS TLS根证书</li></ul><h4 id="3-安全组（Security-Groups）："><a href="#3-安全组（Security-Groups）：" class="headerlink" title="3.安全组（Security Groups）："></a>3.安全组（Security Groups）：</h4><p>控制对RDS &#x2F; Aurora数据库的网络访问</p><h4 id="4-IAM-Authentication（身份验证）"><a href="#4-IAM-Authentication（身份验证）" class="headerlink" title="4-IAM Authentication（身份验证）"></a>4-<strong>IAM Authentication（身份验证）</strong></h4><p>使用IAM角色连接数据库（而非用户名&#x2F;密码）</p><h4 id="5-审计日志可以启用，并发送到CloudWatch-Logs以便更长时间保留。"><a href="#5-审计日志可以启用，并发送到CloudWatch-Logs以便更长时间保留。" class="headerlink" title="5-审计日志可以启用，并发送到CloudWatch Logs以便更长时间保留。"></a>5-审计日志可以启用，并发送到CloudWatch Logs以便更长时间保留。</h4><h4 id="6-除RDS-Custom外，不支持SSH"><a href="#6-除RDS-Custom外，不支持SSH" class="headerlink" title="6-除RDS Custom外，不支持SSH"></a>6-除RDS Custom外，不支持SSH</h4>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS-08【RDS】</title>
      <link href="/2023/08/09/AWS-08%E3%80%90RDS%E3%80%91/"/>
      <url>/2023/08/09/AWS-08%E3%80%90RDS%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="RDS"><a href="#RDS" class="headerlink" title="RDS"></a>RDS</h2><p> <strong>Relational Database Service 关系数据库服务</strong></p><p><img src="/images/Untitled%2023.png" alt="Untitled"></p><p> <strong>we can’t SSH into our RDS inst</strong></p><p>多种数据库引擎支持：包括MySQL、PostgreSQL、Oracle、Microsoft SQL Server和Amazon Aurora。这使得用户可以根据应用程序的需求选择合适的数据库引擎。</p><h3 id="RDS-Backups-备份"><a href="#RDS-Backups-备份" class="headerlink" title="RDS Backups 备份"></a><strong>RDS Backups 备份</strong></h3><ul><li>RDS中自动启用备份功能。</li><li>自动备份：<ul><li>每天在维护窗口期间对数据库进行完整备份。</li><li>RDS每隔5分钟备份一次事务日志。</li><li>可以还原到任意时间点（从最早的备份到5分钟前的时间点）。</li><li>保留备份数据的时间为7天（可以增加至<strong>35天</strong>）。</li></ul></li><li>数据库快照（DB Snapshots）：<ul><li>用户可以手动触发备份操作。</li><li>可以根据需要保留备份数据的时间，没有时间限制。</li></ul></li></ul><p>自动备份适用于对数据可靠性和恢复性有较高要求的场景</p><p>数据库快照更适用于具有特定备份需求或需要长期保留备份的场景。(花费更小）</p><h3 id="storage-auto-scaling存储自动扩展"><a href="#storage-auto-scaling存储自动扩展" class="headerlink" title="storage auto scaling存储自动扩展"></a>storage auto scaling存储自动扩展</h3><p>根据需要自动调整RDS数据库实例的存储空间</p><ul><li>您需要设置最大存储阈值（数据库存储的最大限制）</li><li>满足以下条件：<br>剩余存储空间少于已分配存储空间的10%<br>低存储状态持续至少5分钟<br>距离上次调整已经过去6小时</li><li>适用于具有<strong>不可预测的工作负载</strong>的应用程序。</li><li>支持所有RDS数据库引擎（MariaDB，MySQL，PostgreSQL，SQL Server，Oracle）。</li></ul><h3 id="RDS-Proxy-代理"><a href="#RDS-Proxy-代理" class="headerlink" title="RDS Proxy 代理"></a>RDS Proxy 代理</h3><p>RDS Proxy allows for managing thousands of concurrent database<br>connections, which can help reduce connection errors</p><p><strong>serverless, autoscaling, multi-AZ (high available)</strong></p><p><strong>RDS Proxy提高数据库的性能、可扩展性和安全性</strong></p><p>RDS Proxy是RDS（Amazon Relational Database Service）的全管理数据库代理，它为应用程序提供了一个连接池，并允许应用程序共享与数据库建立的连接。它的主要目标是<strong>通过减少数据库资源（如CPU、RAM）的负载和最小化开启的连接数</strong>（以及超时）来提高数据库的效率。</p><p><strong>解释：</strong></p><ul><li>RDS Proxy充当应用程序和数据库之间的中间代理，它<strong>可以处理与数据库的连接和请求</strong>，从而减轻数据库的负担。应用程序可以通过连接池共享已建立的数据库连接，而不是每次请求都创建一个新的连接，这样可以降低数据库上的开销，提高响应效率。</li><li>减少数据库资源（如CPU和RAM）的使用，</li><li>RDS Proxy可以显著减少RDS和Aurora数据库的failover time，据称可高达66%。</li><li>RDS Proxy通过IAM身份验证强制执行数据库连接的安全性，并使用AWS Secrets Manager安全地存储数据库凭据。这意味着连接到数据库的应用程序必须经过身份验证，并且凭据被安全地存储，以确保数据库的安全性。</li><li>RDS Proxy永远不会公开访问（不可公开访问），只能从VPC（Virtual Private Cloud）内部访问。这增加了数据库的安全性</li></ul><h3 id="RDS-read-replica-for-read-scalability读取可扩展性的只读副本"><a href="#RDS-read-replica-for-read-scalability读取可扩展性的只读副本" class="headerlink" title="RDS read replica for read scalability读取可扩展性的只读副本"></a>RDS read replica for read scalability读取可扩展性的只读副本</h3><p><strong>分担主数据库的读取负载，提高读取性能。</strong></p><p><strong>主数据库负责写入操作，而读取副本负责处理查询操作，从而减轻主数据库的负担。</strong></p><ul><li><p>最多可创建5个读取副本</p></li><li><p>支持<strong>Within AZ, Cross AZ or Cross Region</strong></p></li><li><p>复制是<strong>ASYNC</strong>，因此读取最终一致性</p><ul><li>主数据库对数据的更改会立即应用到主数据库本身，但不会立即传输到所有读取副本。这意味着读取副本的数据可能在某些时候是稍有延迟的，但最终会达到一致性。</li></ul></li><li><p>副本可以晋升为独立的数据库</p></li><li><p>应用程序必须更新连接字符串以使用读取副本</p><p>  <img src="/images/Untitled%2024.png" alt="Untitled"></p><h1 id="Network-Cost"><a href="#Network-Cost" class="headerlink" title="Network Cost"></a><strong>Network Cost</strong></h1><ul><li>In AWS there’s a network cost when data goes from one AZ to another</li><li><strong>For RDS Read Replicas within the same region, you don’t pay that fee</strong></li></ul><h1 id="网络成本"><a href="#网络成本" class="headerlink" title="网络成本"></a><strong>网络成本</strong></h1><ul><li>在AWS中，当数据从一个AZ传输到另一个AZ时，会产生网络成本。</li><li><strong>对于同一区域中的RDS只读副本，您不需要支付该费用</strong>。</li></ul></li></ul><h3 id="Multi-AZ-used-for-disaster-recovery-用于灾难恢复的多个可用区"><a href="#Multi-AZ-used-for-disaster-recovery-用于灾难恢复的多个可用区" class="headerlink" title="Multi AZ used for disaster recovery-用于灾难恢复的多个可用区"></a>Multi AZ used for disaster recovery-用于灾难恢复的多个可用区</h3><ul><li><strong>SYNC</strong> replication, Increase <strong>availability</strong></li><li><strong>同步</strong>复制，提高<strong>可用性</strong></li><li>RDS 主实例和辅助实例（读取副本）位于不同的可用区</li></ul><h3 id="RDS-–-From-Single-AZ-to-Multi-AZ"><a href="#RDS-–-From-Single-AZ-to-Multi-AZ" class="headerlink" title="RDS – From Single-AZ to Multi-AZ"></a><strong>RDS – From Single-AZ to Multi-AZ</strong></h3><ul><li>Zero downtime operation (no need to stop the DB)</li><li>Just click on “modify” for the database</li><li>The following happens internally:<ul><li>A snapshot is taken</li><li>A new DB is restored from the snapshot in a new AZ</li><li>Synchronization is established between the two databases</li></ul></li></ul><h3 id="RDS-–-从单可用区迁移到多可用区"><a href="#RDS-–-从单可用区迁移到多可用区" class="headerlink" title="RDS – 从单可用区迁移到多可用区"></a><strong>RDS – 从单可用区迁移到多可用区</strong></h3><ul><li>零停机操作（无需停止数据库）</li><li>只需单击数据库的“modify”按钮</li><li>下列操作在内部进行：<ul><li>拍摄一个快照</li><li>在新的 AZ 中从快照中还原一个新的数据库</li><li>在两个数据库之间建立同步</li></ul></li></ul><p><img src="/images/Untitled%2025.png" alt="Untitled"></p><h3 id="Important-ports"><a href="#Important-ports" class="headerlink" title="Important ports:"></a><strong>Important ports:</strong></h3><ul><li>FTP: 21</li><li>SSH: 22</li><li>SFTP: 22 (same as SSH)</li><li>HTTP: 80</li><li>HTTPS: 443</li></ul><h4 id="vs-RDS-Databases-ports"><a href="#vs-RDS-Databases-ports" class="headerlink" title="vs RDS Databases ports:"></a><strong>vs RDS Databases ports:</strong></h4><ul><li>PostgreSQL: 5432</li><li>MySQL: 3306</li><li>Oracle RDS: 1521</li><li>MSSQL Server: 1433</li><li>MariaDB: 3306 (same as MySQL)</li><li>Aurora: 5432 (if PostgreSQL compatible) or 3306 (if MySQL compatible)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS-07【FSx】</title>
      <link href="/2023/08/07/AWS-07%E3%80%90FSx%E3%80%91/"/>
      <url>/2023/08/07/AWS-07%E3%80%90FSx%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="FSx"><a href="#FSx" class="headerlink" title="FSx"></a><strong>FSx</strong></h2><p> File System for Windows and Lustre</p><p><img src="/images/Untitled%2022.png" alt="Untitled"></p><ul><li>Amazon FSx for Windows File Server 是一种托管的Windows文件共享服务，支持标准的SMB协议，适用于文件共享和备份。</li><li>提供了完全托管的第三方文件系统。</li><li>启动、运行和扩缩功能丰富的高性能文件系统</li></ul><h3 id="FSx-for-Windows-File-Server："><a href="#FSx-for-Windows-File-Server：" class="headerlink" title="FSx for Windows File Server："></a><strong>FSx for Windows File Server：</strong></h3><ul><li><strong>Windows 兼容性</strong>：FSx for Windows File Server 支持标准的 Server Message Block（SMB）协议，这是 Windows 环境中常用的文件共享协议。您可以使用现有的 Windows 工具和应用程序，无缝地连接和访问 FSx 文件系统。</li><li><strong>可伸缩性</strong>：FSx 可以根据您的需求自动扩展存储和性能，确保您始终能够满足不断增长的文件存储需求。</li><li><strong>备份和数据复制</strong>：FSx 自动处理数据的备份和复制，确保数据的高度可靠性和持久性。</li><li><strong>集成 AWS 功能</strong>：FSx 与其他 AWS 服务紧密集成，例如 Amazon S3、AWS Identity and Access Management（IAM）等，帮助您构建全面的存储和数据管理解决方案。</li></ul><h3 id="FSx-for-Lustre："><a href="#FSx-for-Lustre：" class="headerlink" title="FSx for Lustre："></a><strong>FSx for Lustre：</strong></h3><p>**high performance computing(HPC)**高性能计算</p><p>可扩展的、低延迟的</p><p>适用于 HPC、机器学习、媒体处理等场景</p><h4 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a><strong>存储类型</strong></h4><ul><li>固态硬盘 (SSD):<ul><li>对于低延迟、IOPS 密集型工作负载，这些工作负载通常具有小型随机文件操作，请选择其中一个 SSD 存储选项。</li></ul></li><li>硬盘驱动器 (HDD)<ul><li>对于吞吐量密集型工作负载，这些工作负载通常具有大型顺序文件操作，请选择其中一个 HDD 存储选项。</li></ul></li></ul><h3 id="seamless-integration-with-S3"><a href="#seamless-integration-with-S3" class="headerlink" title="seamless integration with S3"></a><strong>seamless integration with S3</strong></h3><p><strong>与S3无缝集成:</strong> 允许您在 Lustre 文件系统中无缝访问和处理 Amazon S3 存储的对象数据</p><ol><li><strong>直接访问 S3 数据</strong>：FSx for Lustre 可以直接访问存储在 Amazon S3 上的对象数据</li><li><strong>数据一致性</strong>：当您将数据从 Amazon S3 写入 Lustre 文件系统或从 Lustre 文件系统写回到 S3 时，FSx for Lustre 会确保数据的一致性。</li><li><strong>高性能</strong>：Lustre 文件系统和 Amazon S3 存储都是高性能的服务。通过 Seamless Integration with S3，您可以在 Lustre 文件系统中利用 Lustre 的低延迟和高吞吐量特性来快速读取和处理 S3 存储的数据，从而提高数据处理效率。</li><li><strong>数据持久性</strong>：由于 Lustre 文件系统直接访问 S3 存储的数据，数据的持久性和可靠性与 Amazon S3 保持一致。</li></ol><h3 id="FSx-file-system-deployment-options-文件部署选项"><a href="#FSx-file-system-deployment-options-文件部署选项" class="headerlink" title="FSx file system deployment options-文件部署选项"></a><strong>FSx file system deployment options-文件部署选项</strong></h3><ul><li><strong>Persistent File System (持久文件系统)</strong><ul><li>temporary storage</li><li>data is not replicated (doesn’t persist when file server fails).意味着如果文件服务器发生故障，数据可能会丢失。</li><li>high bust</li><li>usage :short-term processing, optimize costs</li></ul></li><li><strong>Scratch File System (短期文件系统)</strong><ul><li>long-term storage</li><li>data is replicated witnin same AZ</li><li>raplace failed files within minutes确保数据的可靠性和完整性。</li><li>usage: long-term processing , sensitive data</li></ul></li></ul><h4 id="FSx-for-NetApp-ONTAP："><a href="#FSx-for-NetApp-ONTAP：" class="headerlink" title="FSx for NetApp ONTAP："></a><strong>FSx for NetApp ONTAP：</strong></h4><p>一项完全托管的服务，提供基于流行的 ONTAP 文件系统构建的高可靠、可扩展、高性能和功能丰富的文件存储。</p><ul><li>企业级性能和功能：FSx for NetApp ONTAP 基于 NetApp 公司的存储操作系统，提供了企业级的性能、可靠性和功能。</li><li><strong>多协议支持：支持 Network File System (NFS) 和 Server Message Block (SMB) 等多种协议，与不同应用程序和环境无缝集成。</strong></li><li>高可用性：FSx for NetApp ONTAP 部署在多个 AWS 可用区，提供数据冗余和高可用性。</li><li>数据备份和恢复：FSx for NetApp ONTAP 支持数据备份、快照和灾难恢复，确保数据的安全性。</li></ul><h4 id="FSx-for-OpenZFS："><a href="#FSx-for-OpenZFS：" class="headerlink" title="FSx for OpenZFS："></a><strong>FSx for OpenZFS：</strong></h4><ul><li>Amazon FSx for Lustre 是一种高性能的托管文件系统服务，适用于高性能计算、机器学习、媒体处理等场景。可选择SSD或HDD存储类型，并可以与Amazon S3无缝集成。<ul><li><strong>Windows 兼容性</strong>：FSx for Windows File Server 支持标准的 Server Message Block（SMB）协议，这是 Windows 环境中常用的文件共享协议。您可以使用现有的 Windows 工具和应用程序，无缝地连接和访问 FSx 文件系统。</li><li><strong>可伸缩性</strong>：FSx 可以根据您的需求自动扩展存储和性能，确保您始终能够满足不断增长的文件存储需求。</li><li><strong>备份和数据复制</strong>：FSx 自动处理数据的备份和复制，确保数据的高度可靠性和持久性。</li><li><strong>集成 AWS 功能</strong>：FSx 与其他 AWS 服务紧密集成，例如 Amazon S3、AWS Identity and Access Management（IAM）等，帮助您构建全面的存储和数据管理解决方案。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS-06【EFS】</title>
      <link href="/2023/08/06/AWS-06%E3%80%90EFS%E3%80%91/"/>
      <url>/2023/08/06/AWS-06%E3%80%90EFS%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="EFS"><a href="#EFS" class="headerlink" title="EFS"></a>EFS</h2><p> <strong>Elastic File System</strong></p><p><img src="/images/Untitled%2021.png" alt="Untitled"></p><h3 id="serverless"><a href="#serverless" class="headerlink" title="serverless"></a>serverless</h3><p><strong>可以挂在到一个instance上</strong></p><p><strong>可以挂载到multi-AZ的不同instance上</strong></p><p><strong>EFS 文件系统不能直接跨越多个 AWS  region进行挂载。</strong></p><p>扩展到 PB 级数，在添加和删除文件时自动增加和缩减</p><p>EFS 基于NFS协议的文件存储服务，是一个分布式的文件系统，允许多个 Amazon EC2 实例同时访问和共享文件。</p><p><strong>POSIX 兼容性</strong>：Amazon EFS 设计为与 POSIX 文件系统接口兼容，因此你可以将现有的应用程序和工作负载迁移到 EFS 上，而无需进行大量修改。</p><aside>➡️ POSIX（Portable Operating System Interface，可移植操作系统接口）是一组操作系统标准，旨在提供一种标准化的编程接口，使不同操作系统上的应用程序能够在不进行太多修改的情况下移植和运行。</aside><ul><li>Highly available, scalable, expensive (3x gp2), pay per use</li><li>Use cases: content management, web serving, data sharing,Wordpress</li><li>Uses NFSv4.1 protocol</li><li>Uses security group to control access to EFS</li><li><strong>Compatible with Linux based AMI (not Windows)：兼容Linux AMI（不支持Windows）</strong></li><li>不支持在基于微软 Windows 的Amazon EC2 实例上使用 Amazon EFS。</li><li>Encryption at rest using KMS</li></ul><h3 id="存储类别选项："><a href="#存储类别选项：" class="headerlink" title="存储类别选项："></a>存储类别选项：</h3><ul><li><strong>标准存储类别</strong><ul><li>EFS Standard: 经常访问的数据需要最高的耐久性和可用性。</li><li>EFS Standard–IA: 寿命长、不经常访问的数据，需要最高的耐久性和可用性。</li></ul></li><li><strong>单区存储类别</strong><ul><li><p>EFS One Zone:经常访问的数据，不需要最高水平的耐久性和可用性。</p></li><li><p>EFS One Zone-IA:寿命长、不经常访问的数据，不需要最高水平的耐久性和可用性。</p><blockquote><p>由于 EFS One Zone 存储类将数据存储在单个AWS可用区中，因此在发生影响可用区内所有数据副本的灾难或其他故障时，或者可用区被破坏时，存储在这些存储类中的数据可能会丢失。</p></blockquote></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS-05【EBS】</title>
      <link href="/2023/08/05/AWS-05%E3%80%90EBS%E3%80%91/"/>
      <url>/2023/08/05/AWS-05%E3%80%90EBS%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="EBS-Elastic-block-system"><a href="#EBS-Elastic-block-system" class="headerlink" title="EBS-Elastic block system"></a>EBS-Elastic block system</h2><p><img src="/images/Untitled%2016.png" alt="Untitled"></p><p>一种持久性、高性能的存储解决方案，专为在AWS云环境中运行的EC2实例设计。</p><h3 id="EBS-Volume"><a href="#EBS-Volume" class="headerlink" title="EBS Volume:"></a><strong>EBS Volume:</strong></h3><p>EBS卷是AWS提供的一种块存储服务，用于为EC2实例提供持久性存储。它提供了可供EC2实例使用的虚拟硬盘。EBS卷可以附加到EC2实例，并用于存储应用程序数据和其他持久性数据。</p><p>以下是一些关键特点和用途：</p><ol><li><strong>持久性和可靠性</strong>：EBS卷的数据是持久存储的，即使EC2实例关机或遇到故障，数据也会得到保留。EBS数据具有高可靠性，并提供数据冗余和自动备份功能。</li><li><strong>可扩展性和高性能</strong>：EBS卷的容量和性能可以根据需要进行调整。你可以根据应用程序的需求增加或减少卷的大小，并调整卷的吞吐量和IOPS（每秒输入&#x2F;输出操作数）。</li><li><strong>快照备份</strong>：EBS提供了快照功能，可以创建卷的点-in-time备份。快照是卷数据的完整拷贝，可以用于数据备份、灾难恢复和创建新的EBS卷。</li><li><strong>多种卷类型</strong>：EBS提供多种卷类型，包括SSD（固态硬盘）和HDD（机械硬盘）等。每种类型都具有不同的性能和成本特性，可以根据应用程序的需求选择适合的卷类型。</li><li><strong>可用性和地理位置</strong>：EBS卷可以在不同的可用区之间进行复制和备份，以提高数据的可用性和可靠性。此外，EBS卷还可以进行跨区域复制，以实现地理位置的灾难恢复。</li></ol><h4 id="volume-types-卷类型"><a href="#volume-types-卷类型" class="headerlink" title="volume types-卷类型"></a>volume types-卷类型</h4><p>EBS volume types：</p><blockquote><p>• <strong>Only gp2&#x2F;gp3 and io1&#x2F;io2 can be used as boot volumes</strong></p></blockquote><ul><li><p><strong>gp2&#x2F;gp3（SSD）</strong>：General purpose SSD volume，提供平衡的价格和性能，适用于各种工作负载。</p><ul><li>gp3可以独立设置IOPS和throughput，gp2的IOPS和 throughput是linked</li><li>价格：</li></ul><p>  <img src="/images/Untitled%2017.png" alt="Untitled">  </p></li><li><h2 id="io1-io2（SSD）：Highest-performance-SSD-volume-for-mission-critical-low-latency-or-high-throughput-workloads-more-than-16000-IOPS-great-for-databases-workloads-increase-PIOPS-independently-from-storage-size"><a href="#io1-io2（SSD）：Highest-performance-SSD-volume-for-mission-critical-low-latency-or-high-throughput-workloads-more-than-16000-IOPS-great-for-databases-workloads-increase-PIOPS-independently-from-storage-size" class="headerlink" title="io1&#x2F;io2（SSD）：Highest-performance SSD volume for mission-critical low-latency or high-throughput workloads  - more than 16000 IOPS  - great for databases workloads  - increase PIOPS independently from storage size"></a><strong>io1&#x2F;io2（SSD）</strong>：Highest-performance SSD volume for mission-critical low-latency or high-throughput workloads<br>  - more than 16000 IOPS<br>  - great for databases workloads<br>  - increase PIOPS independently from storage size</h2><p>  <img src="/images/Untitled%2018.png" alt="Untitled"></p></li><li><p><strong>st1（HDD）</strong>：Low cost HDD volume，专为频繁访问、吞吐量密集型的工作负载而设计。</p></li><li><p><strong>sc1（HDD）</strong>：Low cost HDD volume，专为不频繁访问的工作负载而设计。</p><p>  <img src="/images/Untitled%2019.png" alt="Untitled"></p></li></ul><h3 id="delete-on-termination-attribute"><a href="#delete-on-termination-attribute" class="headerlink" title="delete on termination attribute"></a>delete on termination attribute</h3><p>EBS volume的属性</p><p>用于定义当关联的 EC2 实例终止时是否自动删除该 EBS 卷。具体而言，如果 “delete on termination” 属性被设置为启用（默认情况下是启用的），则当关联的 EC2 实例终止时，该 EBS 卷将自动被删除，其上的数据也将被清除。</p><p>By default, the Root volume type will be deleted as its “Delete On Termination” attribute checked by default. Any other EBS volume types will not be deleted as its “Delete On Termination” attribute disabled by default.</p><p>默认情况下，根卷类型将被删除，因为其“删除终止”属性已默认选中。任何其他EBS卷类型将不被删除，因为其“删除终止”属性默认禁用。</p><h3 id="root-volume-EBS-volume-instance-store"><a href="#root-volume-EBS-volume-instance-store" class="headerlink" title="root volume * EBS volume * instance store"></a>root volume * EBS volume * instance store</h3><p><img src="/images/Untitled%2020.png" alt="Untitled"></p><p>root volume是EC2实例的主要存储卷，通常用于操作系统和系统文件。它是<strong>EC2实例的一部分</strong>，与实例的生命周期绑定。</p><p>EBS volume是一种可附加attach到EC2实例的虚拟硬盘</p><p> <strong>root volume是instance的一部分，可以是instance store或EBS volume。</strong></p><ul><li>如果根卷是实例存储，直接连接到实例主机。它提供了高性能和低延迟的存储，但是它是<strong>临时性</strong>的，</li><li>如果根卷是EBS卷，它是一种持久性存储，数据会被保留，即使实例停止或终止</li></ul><h3 id="snapshot-快照"><a href="#snapshot-快照" class="headerlink" title="snapshot 快照"></a>snapshot 快照</h3><p>a backup of EBS volume at any point time</p><p>can copy snapshots across AZ or Region</p><p><strong>增量备份：</strong> 快照采用增量备份的方式，只备份卷上的更改数据，从而减少存储空间和传输成本。</p><h3 id="multi-attach-多重附加"><a href="#multi-attach-多重附加" class="headerlink" title="multi attach -多重附加"></a>multi attach -多重附加</h3><p>Attach the same EBS volume to multiple EC2 instances <strong>in the same AZ</strong></p><p><strong>io1&#x2F;io2 family</strong></p><ul><li>Attach the same EBS volume to multiple EC2 instances in the same AZ</li><li>Each instance has full read &amp; write permissions to the volume</li><li>Use case:<ul><li>Achieve <strong>higher application availability</strong> in clustered Linux applications (ex: Teradata)</li><li>Applications must manage concurrent write operations</li></ul></li><li>Must use a file system that’s cluster-aware (not XFS, EX4, etc…)</li></ul><h3 id="Encryption-加密"><a href="#Encryption-加密" class="headerlink" title="Encryption-加密"></a><strong>Encryption-加密</strong></h3><p>当您创建一个加密的EBS卷时：</p><ul><li><strong>数据静态存储时会在卷内部进行加密，保护数据的安全性。</strong></li><li><strong>实例和卷之间传输的所有数据都会进行加密，确保数据在传输过程中的机密性。</strong></li><li>所有的快照都会被加密，包括从未加密的卷创建的快照。</li><li><strong>从快照创建的所有卷都会继承快照的加密属性，成为加密卷。</strong></li><li>EBS加密使用来自AWS KMS的AES-256密钥进行加密和解密。</li></ul><p>要对未加密的EBS卷进行加密，您可以按照以下步骤操作：</p><ol start="6"><li>创建卷的快照。</li><li>使用复制操作对快照进行加密。</li><li>使用加密的快照创建新的EBS卷，这个卷也会是加密的。</li><li>将加密的卷附加到原始实例上。</li></ol><h3 id="Instance-store"><a href="#Instance-store" class="headerlink" title="Instance store"></a>Instance store</h3><p>EC2 Instance Store是<strong>基于物理硬盘</strong>的本地存储，它直接连接到运行实例的物理硬件。这意味着实例存储是实际的物理硬盘驱动器，提供了低延迟和高吞吐量的性能。</p><p>EBS 卷是基于<strong>网络连接</strong>的虚拟存储设备，它是通过网络连接到实例，并提供持久性数据存储。</p><p>EBS volume are network drives with good but limited performance</p><p>if you need a high-performance hardware disk, use EC2 instance store</p><ul><li>better I&#x2F;O performance</li><li>**ephemeral—**EC2 instance store lose their storage if they’re stopped</li><li>good for buffer&#x2F; cache &#x2F; scratch data &#x2F; temporary content</li><li>not for long term storage</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> 云原生 </tag>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS-04【S3】</title>
      <link href="/2023/08/04/AWS-04%E3%80%90S3%E3%80%91/"/>
      <url>/2023/08/04/AWS-04%E3%80%90S3%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="S3"><a href="#S3" class="headerlink" title="S3"></a><strong>S3</strong></h2><p><strong>Simple Storage Service</strong></p><p><img src="/images/203.png" alt="图片1"></p><ul><li>S3是AWS提供的对象存储服务，适用于存储和检索任意类型的数据，如文件、图像、视频等。</li><li>S3是高度可扩展、耐用、安全的存储解决方案。</li></ul><h3 id="S3-存储桶（Bucket）："><a href="#S3-存储桶（Bucket）：" class="headerlink" title="S3 存储桶（Bucket）："></a><strong>S3 存储桶（Bucket）：</strong></h3><ul><li>存储桶的名称在整个AWS中必须是全局唯一的。</li><li>Amazon S3 允许用户将object（文件）存储在“bucket”（目录）中。</li><li>存储桶必须有一个<strong>全局唯一的名称</strong>。</li><li>Buckets are defined at the region level存储桶在区域级别上定义。</li></ul><aside>🐳 命名约定<ul><li>不使用<strong>大写字母</strong></li><li>不使用下划线</li><li>长度为3-63个字符</li><li>不是IP地址</li><li>必须以小写字母或数字开头。</li></ul></aside><h3 id="S3-对象（Object）："><a href="#S3-对象（Object）：" class="headerlink" title="S3 对象（Object）："></a><strong>S3 对象（Object）：</strong></h3><p>可以是任意类型的数据，例如文本文件、图像、视频、数据库备份等。</p><p>在S3中，对象由以下三个主要组成部分构成：</p><ol><li><strong>键（Key）</strong>：<ul><li>键是对象的唯一标识符，用于在S3存储桶中唯一标识对象。</li><li>Key并不是完整路径，而是相对于存储桶的路径或文件名。</li></ul></li><li><strong>值（Value）</strong>：<ul><li>对象值是主体内容</li><li>值是实际的数据内容，也就是存储在对象中的实际数据。</li><li>值可以是任何字节流，允许存储各种类型的文件和数据。</li></ul></li><li><strong>元数据（Metadata）</strong>：<ul><li>元数据是关于对象的一组键值对信息，用于描述对象的属性和其他相关信息。</li><li>元数据可以包含诸如对象的创建日期、文件类型、大小、所有者等信息。</li></ul></li></ol><h3 id="storage-class-存储类别"><a href="#storage-class-存储类别" class="headerlink" title="storage class 存储类别"></a><strong>storage class 存储类别</strong></h3><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>S3 Standard（default）</td><td>标准存储</td><td>适用于频繁访问的数据大数据分析，移动应用，游戏</td></tr><tr><td>S3 Intelligent-Tiering</td><td>智能分层—数据根据<strong>访问模式</strong>分层存储</td><td>自动优化存储费用和性能；不确定访问频率的数据, 成本敏感型应用</td></tr><tr><td>S3 Standard-IA</td><td>infrequent access</td><td>**访问频率较低，但即时访问的数据。**灾难恢复，备份</td></tr><tr><td>S3 One Zone-IA</td><td>S3-One zone not suitable for business critical data<strong>不适合关键性数据</strong></td><td>可重新创建的、不经常访问的数据(每月一次)，存储在单个可用区中，访问时间为毫秒……………与 S3 Standard-IA相比具有<em><strong>更低的存储成本</strong></em></td></tr><tr><td>Glacier Instant Retrieval</td><td>Glacier <strong>即时</strong>检索，数据不可更新</td><td>适用于需要即时访问的归档数据；</td></tr><tr><td>Glacier Flexible Retrieval</td><td>Glacier 灵活检索，数据不可更新</td><td>适用于很少访问且不<strong>需要即时访问</strong>的长期数据；</td></tr><tr><td>S3 Glacier Deep Archive</td><td>Glacier 深度存档，</td><td>long-term:适用于以<strong>最低的云存储成本</strong>进行长期归档和数字保存。</td></tr></tbody></table><p>Amazon S3 还提供了在整个数据生命周期内管理数据的功能。设置 S3 生命周期策略之后，无需更改您的应用程序，您的数据将自动传输到其他存储类。</p><aside>🚫 您无法从以下内容进行转换：<ol><li>任何存储类别到S3 Standard。</li><li>任何存储类别到冗余存储（RRS）类别。</li><li>S3 Intelligent-Tiering存储类别到S3 Standard-IA。<br>S3 One Zone-IA存储类别到S3 Intelligent-Tiering，S3 Standard-IA或S3 Glacier即时检索存储类别。</li></ol></aside><h4 id="moving-between-storage-classes"><a href="#moving-between-storage-classes" class="headerlink" title="moving between storage classes"></a>moving between storage classes</h4><p>moving objects can be automated using a <strong>lifecycle configuration</strong></p><h3 id="Storage-Class-Analysis"><a href="#Storage-Class-Analysis" class="headerlink" title="Storage Class Analysis"></a><strong>Storage Class Analysis</strong></h3><ul><li>您可以设置S3分析以帮助确定何时将对象从标准转换为Standard_IA。</li><li>不适用于ONEZONE_IA或GLACIER。</li><li>报告每天更新。</li><li>首次启动需要约24小时至48小时。</li><li>组合生命周期规则（或改进生命周期规则）的好第一步！</li></ul><h3 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a><strong>数据管理</strong></h3><p>：对象版本控制、生命周期配置、跨区域复制、数据传输加速等功能。</p><h4 id="S3Versioning版本控制"><a href="#S3Versioning版本控制" class="headerlink" title="** S3Versioning版本控制**"></a>** S3Versioning版本控制**</h4><p>启用版本控制后，S3将为每个存储在存储桶中的对象创建不同的版本，而不是覆盖之前的版本。</p><ul><li>可在bucket级别启用</li><li>可恢复特定版本以及轻松回滚</li><li>默认版本 ID 为“null”</li><li>suspending versionsing does not delete the previous versions</li></ul><h4 id="S3-Lifecycle-Rules生命周期"><a href="#S3-Lifecycle-Rules生命周期" class="headerlink" title="S3 Lifecycle Rules生命周期"></a><strong>S3 Lifecycle Rules生命周期</strong></h4><ul><li><strong>Transition actions</strong>:：它定义了对象何时转换为另一个存储类别。<ul><li>创建后60天将对象移动到标准IA类别。</li><li>6个月后将对象移动到Glacier进行归档。</li></ul></li><li><strong>Expiration actions</strong>：<strong>配置对象在一定时间后过期（删除）</strong><ul><li>访问日志文件可以设置为在365天后删除。</li><li><strong>可用于删除旧文件版本（如果启用了版本控制）</strong></li><li>可<strong>用于删除未完成的多部分上传。</strong></li></ul></li><li>可以为某个前缀prefix创建规则（例如 - s3:&#x2F;&#x2F;mybucket&#x2F;mp3&#x2F;*）</li><li>可以为某些objects tags创建规则（例如 - Department: Finance）</li></ul><h4 id="对象锁定-保护对象免受删除和更改"><a href="#对象锁定-保护对象免受删除和更改" class="headerlink" title="对象锁定-保护对象免受删除和更改"></a>对象锁定-保护对象免受删除和更改</h4><ol><li><strong>合规模式（Compliance Mode）</strong>：<ul><li>合规模式是 Amazon S3 中的一种对象锁定模式，用于确保对象在指定的锁定期间内不被删除或更改。</li><li>在合规模式下，对象一旦被锁定，即使具有管理权限的用户（<strong>包括 root</strong> 用户）也无法删除或更改对象，直到锁定期结束。</li><li>合规模式适用于需要满足法规和合规性要求，确保数据不被篡改或删除的场景。</li></ul></li><li><strong>治理模式（Governance Mode）</strong>：<ul><li>治理模式也是 Amazon S3 中的一种对象锁定模式，用于在指定的锁定期间内保护对象免受删除和更改。</li><li>在治理模式下，具有管理权限的用户（如 root 用户）可以申请对对象进行更改或删除，但需要提前指定锁定结束的日期和时间。</li><li>治理模式适用于需要保护数据免受误删除或更改的场景，但允许有一定管理权限的用户提前申请解锁。</li></ul></li></ol><h4 id="S3-Replication-CRR-SRR-复制"><a href="#S3-Replication-CRR-SRR-复制" class="headerlink" title="S3 Replication (CRR &amp; SRR)复制"></a><strong>S3 Replication (CRR &amp; SRR)复制</strong></h4><ul><li><p><strong>Must enable versioning</strong> in source and destination</p></li><li><p><strong>跨区域复制Cross Region Replication (CRR)</strong></p></li><li><p><strong>同一区域复制Same Region Replication (SRR)</strong></p></li><li><p>复制是asynchronous异步的</p></li><li><p>存储桶可以位于不同的账户中</p></li><li><p>必须为S3授予适当的IAM权限</p></li><li><p>CRR - 使用场景：合规性，更低的延迟访问，跨账户复制</p></li><li><p>SRR - 使用场景：log aggregation日志聚合，live replication between production and test accounts生产和测试账户之间的实时复制</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><em><strong>注意事项</strong></em></h3></li><li><p>激活后，只有新对象会被复制（不会追溯复制旧对象）</p></li><li><p>对于删除操作：</p><ul><li>可以从源复制到目标删除maker（可选设置）</li><li>具有版本 ID 的删除不会被复制（以避免恶意删除）</li></ul></li><li><p>复制不传递</p><ul><li>如果 bucket 1 复制到 bucket 2，bucket 2 复制到 bucket 3, 那么在 bucket 1 中创建的对象不会被复制到 bucket 3</li></ul></li></ul><h4 id="S3-Transfer-Acceleration-数据传输加速"><a href="#S3-Transfer-Acceleration-数据传输加速" class="headerlink" title="S3 Transfer Acceleration 数据传输加速"></a><strong>S3 Transfer Acceleration</strong> 数据传输加速</h4><ul><li>通过将文件传输到AWS边缘位置，增加传输速度，该位置将数据转发到目标区域的S3存储桶</li><li>兼容多部分上传Compatible with multi-part upload</li></ul><h4 id="S3-–-Baseline-Performance基准性能"><a href="#S3-–-Baseline-Performance基准性能" class="headerlink" title="S3 – Baseline Performance基准性能"></a><strong>S3 – Baseline Performance基准性能</strong></h4><ul><li>Amazon S3可以自动扩展到高请求率，延迟为100-200毫秒。</li><li>您的应用程序每个存储桶前缀每秒可以实现至少3,500个PUT&#x2F;COPY&#x2F;POST&#x2F;DELETE和5,500个GET&#x2F;HEAD请求。</li></ul><h4 id="S3-Performance"><a href="#S3-Performance" class="headerlink" title="S3 Performance"></a><strong>S3 Performance</strong></h4><ul><li><p><strong>Multi-Part upload:</strong></p><ul><li><p>推荐用于大于100MB的文件，对于大于5GB的文件必须使用</p></li><li><p>可以并行上传（加快传输速度）</p></li></ul></li><li><p><strong>S3 Transfer Acceleration</strong></p><ul><li>通过将文件传输到AWS边缘位置，增加传输速度，该位置将数据转发到目标区域的S3存储桶</li><li>兼容多部分上传Compatible with multi-part upload</li></ul></li></ul><h4 id="S3-Select-Glacier-Select"><a href="#S3-Select-Glacier-Select" class="headerlink" title="S3 Select &amp; Glacier Select"></a><strong>S3 Select &amp; Glacier Select</strong></h4><ul><li>使用简单的<strong>SQL</strong>进行服务器端过滤，以检索<strong>较少的数据</strong></li><li><strong>可以按行和列进行过滤</strong></li><li>较少的网络传输和客户端的CPU成本</li><li><strong>Use Case</strong>:<ul><li>适用于需要从大型对象中仅提取特定数据的情况，例如从CSV或JSON文件中提取特定字段的值，而不需要下载整个对象。</li><li>Glacier Select则用于从S3 Glacier存储中检索特定数据，这样可以避免将整个归档文件恢复到S3中，从而节省时间和费用。</li></ul></li></ul><h4 id="S3-Batch-Operations批量操作"><a href="#S3-Batch-Operations批量操作" class="headerlink" title="S3 Batch Operations批量操作"></a><strong>S3 Batch Operations批量操作</strong></h4><ul><li>通过单个请求对现有S3对象执行批量操作<ul><li>一个作业包括一个对象列表，要执行的操作和可选参数</li><li>S3批量操作管理重试，跟踪进度，发送完成通知并生成报告</li><li>步骤：<ul><li>使用S3清单获取对象列表</li><li>使用S3 Select过滤对象</li><li>使用S3批量操作处理对象</li></ul></li></ul></li></ul><h4 id="S3-Byte-range-Fetches字节范围获取"><a href="#S3-Byte-range-Fetches字节范围获取" class="headerlink" title="S3 Byte-range Fetches字节范围获取"></a><strong>S3 Byte-range Fetches字节范围获取</strong></h4><ul><li>通过请求特定的字节范围并行化GET操作</li><li>使用场景：加快下载速度或只需要部分数据（例如文件头）</li><li><strong>Use Case</strong>: S3 Byte-range Fetches适用于需要仅获取对象的一部分内容的情况，例如音频或视频文件的部分播放、分块下载大文件或断点续传等。通过指定字节范围，客户端可以仅下载所需的部分数据，而不需要下载整个对象，从而提高效率和性能。</li></ul><h3 id="安全性security"><a href="#安全性security" class="headerlink" title="安全性security"></a><strong>安全性security</strong></h3><h4 id="Encryption-for-Objects-加密（服务器端加密、客户端加密）"><a href="#Encryption-for-Objects-加密（服务器端加密、客户端加密）" class="headerlink" title="Encryption for Objects-加密（服务器端加密、客户端加密）"></a><strong>Encryption for Objects-加密（服务器端加密、客户端加密）</strong></h4><ul><li><p><strong>服务器端加密（Server-Side Encryption，SSE）：</strong></p><p>S3 管理加密密钥（SSE-S3 或 SSE-KMS）</p><blockquote><p>SSE-S3</p></blockquote><ul><li>Object is encrypted server side</li><li>AES-256 encryption type</li><li>Must set header: <strong>“x-amz-server-side-encryption”: “AES256”</strong></li></ul><blockquote><p>SSE-KMS</p></blockquote><p>加密密钥由 AWS Key Management Service (KMS) 管理。</p><ul><li>KMS Advantages: user control + audit trail</li><li>Object is encrypted server side</li><li>Must set header: <strong>“x-amz-server-side-encryption”: “aws:kms”</strong></li></ul></li><li><p><strong>客户管理加密密钥（SSE-C）：</strong></p><ul><li>SSE-C（Server-Side Encryption with Customer-Provided Keys）</li><li><strong>Amazon S3 不会存储您提供的加密密钥</strong></li><li><strong>HTTPS must be used</strong></li><li>Encryption key must provided in HTTP headers, for every HTTP request made</li><li>允许客户使用自己管理的加密密钥对数据进行加密。客户在上传对象时必须提供加密密钥，并在后续下载时提供正确的密钥来解密数据。</li></ul></li><li><p><strong>客户端加密Client Side Encryption：</strong></p><ul><li>客户端必须在发送到S3之前自行加密数据</li><li>客户端必须在从S3检索数据时自行解密数据</li><li>客户完全管理密钥和加密周期</li></ul></li><li><p><strong>encryption in transit(SSL&#x2F;TSL)：</strong></p><ul><li>使用 SSL&#x2F;TLS 加密协议保护数据在传输过程中的安全性。</li><li>数据在从客户端上传到 S3 或从 S3 下载到客户端的过程中会被加密，防止中间人攻击或窃听。</li></ul></li></ul><h4 id="访问控制（IAM、桶策略、ACLs）"><a href="#访问控制（IAM、桶策略、ACLs）" class="headerlink" title="访问控制（IAM、桶策略、ACLs）"></a><strong>访问控制（IAM、桶策略、ACLs）</strong></h4><ul><li><p><strong>Bucket Policy-S3存储桶策略</strong></p><p>基于JSON的策略</p><ul><li>资源：buckets and objects</li><li>效果：Allow &#x2F; Deny</li><li>操作：允许或拒绝的API集合</li><li>主体：要应用策略的帐户或用户</li><li>应用场景<ul><li>授予公共访问桶</li><li>强制上传的对象进行加密</li><li>授予另一个帐户访问权限（跨帐户访问必须使用存储桶策略）</li></ul></li></ul></li><li><p><strong>使用IAM策略进行访问控制</strong></p><ul><li>基于用户<ul><li>IAM策略，控制特定用户从IAM可以允许哪些API调用</li></ul></li></ul></li><li><p><strong>使用预签名URL（Pre-Signed URL）授予临时访问权限</strong></p><ul><li>Can generate pre-signed URLs using SDK or CLI<ul><li>For downloads (easy, can use the CLI)</li><li>For uploads (harder, must use the SDK)</li></ul></li><li>Valid for a default of 3600 seconds, can change timeout with –expires-in [TIME_BY_SECONDS] argument</li><li>Users given a pre-signed URL inherit the permissions of the person who generated the URL for GET &#x2F; PUT</li><li>可以使用SDK或CLI生成预签名URL<ul><li>对于下载（容易，可以使用CLI）</li><li>对于上传（更难，必须使用SDK）</li></ul></li><li>默认有效期为3600秒，可以使用–expires-in [TIME_BY_SECONDS]参数更改超时时间</li><li>获得预签名URL的用户继承生成URL的人的GET &#x2F; PUT权限</li></ul></li><li><p><strong>bucket setting for block public access</strong></p><p>在AWS S3（Simple Storage Service）中，”Block Public Access”（阻止公共访问）是一组设置，用于确保您的S3存储桶及其内容不会被未经授权的公众访问。这些设置旨在增加您数据的安全性，防止因配置错误或意外而导致敏感信息泄露。</p><p>Block Public Access有以下四个设置选项：</p><ol><li>Block all public access:</li><li>Block public access to buckets and objects granted through new access control lists (ACLs):</li><li>Block public access to buckets and objects granted through any public bucket or access point policies:</li><li>Block public access to buckets and objects granted through new public bucket or access point policies:</li></ol></li></ul><h4 id="S3-MFA-Delete"><a href="#S3-MFA-Delete" class="headerlink" title="S3 MFA-Delete"></a><strong>S3 MFA-Delete</strong></h4><ul><li>MFA（多因素认证）会强制用户在进行S3上的重要操作之前，在设备上（通常是手机或硬件）生成一个代码。</li><li><strong>要使用MFA-Delete，请在S3存储桶上启用Versioning。</strong></li><li>您需要MFA来<ul><li>permanently delete an object version</li><li>suspend versioning on the bucket</li><li>永久删除对象版本</li><li>暂停存储桶的版本控制</li></ul></li><li>您不需要MFA来<ul><li>启用版本控制</li><li>列出已删除的版本</li></ul></li><li><strong>只有桶所有者（root account）可以启用&#x2F;禁用MFA-Delete</strong></li><li>MFA-Delete目前只能使用CLI启用</li><li><strong>注意：默认加密之前会评估Bucket策略</strong></li></ul><h3 id="跨域资源共享（CORS）"><a href="#跨域资源共享（CORS）" class="headerlink" title="跨域资源共享（CORS）"></a><strong>跨域资源共享（CORS）</strong></h3><blockquote><p>（Cross-Origin Resource Sharing）</p></blockquote><p>用于处理跨域资源共享。</p><p>在Web开发中，当您的网页或Web应用程序在一个域名下加载资源（例如图片、字体、脚本等），然后尝试从另一个域名进行访问时，就会发生跨域请求。默认情况下，浏览器执行跨域请求时会阻止访问，并产生CORS错误。</p><p>为了允许其他域名下的网页或应用程序访问S3存储桶中的资源，您可以配置S3 CORS规则。CORS规则告诉S3允许哪些域名下的请求来访问S3资源，并在响应中附加适当的CORS头部信息，以允许浏览器处理跨域请求。</p><p>CORS规则通常包含以下信息：</p><ol><li>允许访问的来源（Origin）：指定允许访问S3资源的域名或URL，可以是单个域名、多个域名，或者使用通配符进行匹配。</li><li>允许的HTTP方法：指定允许的HTTP方法（例如GET、PUT、POST等），用于执行跨域请求。</li><li>允许的自定义头部：指定允许浏览器在跨域请求中包含的自定义头部信息。</li><li>允许的暴露头部：指定在响应中暴露给浏览器的自定义头部信息。</li></ol><p>配置S3 CORS规则可以确保其他域名下的网页或应用程序能够正常访问和加载S3存储桶中的资源，从而实现跨域资源共享。</p><h3 id="事件通知和监控"><a href="#事件通知和监控" class="headerlink" title="事件通知和监控"></a><strong>事件通知和监控</strong></h3><h4 id="S3-event-notification事件通知"><a href="#S3-event-notification事件通知" class="headerlink" title="S3 event notification事件通知"></a><strong>S3 event notification事件通知</strong></h4><p>S3的Event Notification功能允许您对存储桶中的对象操作事件进行监视，并在事件发生时自动触发相应的通知动作。这些事件可以包括对象的创建、删除、还原等。</p><ul><li>S3event notification<ul><li>当事件发生时，发送通知到<strong>SQS、SNS、Lambda或Amazon EventBridge</strong></li><li>Amazon EventBridge提供了<ul><li>使用JSON规则（元数据、对象大小、名称）的高级过滤选项</li><li>多个目的地-例如Step Functions，Kinesis Streams&#x2F;Firehose</li><li>EventBridge功能-归档、重放事件和可靠的传递</li></ul></li><li>可以进行对象名称过滤（例如*.jpg）</li><li>创建尽可能多的”S3事件”</li><li>通常只需要几秒钟，但可能需要1分钟或更长时间</li></ul></li></ul><ol><li><strong>目标（Destination）</strong>：事件发生时，您可以选择将通知发送到一个或多个目标，包括：<ul><li>S3存储桶</li><li>SNS主题（Simple Notification Service）</li><li>SQS队列（Simple Queue Service）</li><li>Lambda函数</li><li>其他支持的AWS服务</li></ul></li></ol><h3 id="S3-Glacier"><a href="#S3-Glacier" class="headerlink" title="S3 Glacier"></a>S3 <strong>Glacier</strong></h3><p><strong>Amazon  S3 Glacier（S3）是一项安全持久的服务，适用于低成本的数据存档和长期备份。</strong></p><ol><li><strong>Glacier: 数据不可变，创建存档后便无法对其进行更新</strong></li></ol><aside>🧊 **S3 Glacier Instant Retrieval**<p>– 用于归档很少访问的、需要毫秒检索的数据。</p></aside><aside>🧊 **S3 Glacier Flexible Retrieval**<p>-用于可能需要在几分钟内检索其部分数据的归档。使用加速检索只需 1-5 分钟即可访问 数据。您还可以在最多 5-12 小时内申请免费批量检索。</p></aside><aside>🧊 **S3 Glacier Deep Archive**<p>– 用于归档很少需要访问的数据。存储的数据的默认检索时间为 12 小时。</p></aside>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> 云原生 </tag>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS-03【ELB】</title>
      <link href="/2023/08/03/AWS-03%E3%80%90ELB%E3%80%91/"/>
      <url>/2023/08/03/AWS-03%E3%80%90ELB%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="ELB-Elastic-Load-Balancing"><a href="#ELB-Elastic-Load-Balancing" class="headerlink" title="ELB- Elastic Load Balancing"></a>ELB- <strong>Elastic Load Balancing</strong></h2><p><img src="/images/Untitled%2010.png" alt="Untitled"></p><h3 id="ELB类型"><a href="#ELB类型" class="headerlink" title="ELB类型"></a>ELB类型</h3><h4 id="CLB-Classic-Load-Balancer"><a href="#CLB-Classic-Load-Balancer" class="headerlink" title="CLB-Classic Load Balancer"></a><strong>CLB-Classic Load Balancer</strong></h4><p>优势：价格便宜，容易上手劣势：效果没有NLB&#x2F;ALB好</p><p><img src="https://img2022.cnblogs.com/blog/2122768/202204/2122768-20220417095016651-1564828897.png" alt="https:&#x2F;&#x2F;img2022.cnblogs.com&#x2F;blog&#x2F;2122768&#x2F;202204&#x2F;2122768-20220417095016651-1564828897.png"></p><h4 id="ALB-Application-Load-Balancer"><a href="#ALB-Application-Load-Balancer" class="headerlink" title="ALB-Application Load Balancer"></a><strong>ALB-Application Load Balancer</strong></h4><ul><li><p>ALB非常适用于微服务和基于容器的应用程序（例如：Docker和Amazon ECS）</p></li><li><p>具有端口映射功能，可重定向到ECS中的动态端口</p></li><li><p>优势：支持基于Host和Path的转发；支持粘性会话；性能比CLB好；支持按比例的流量转发；可编辑安全组</p></li><li><p>负载均衡算法：默认算法为轮询算法,还可以使用<strong>最少未完成请求算法</strong></p><p>  最少未完成请求”算法，也称为“Least Outstanding Requests”算法。</p><p>  当一个新请求到达负载均衡器时，它会将新请求分发给当前负载最轻的服务器，以最大程度地平衡负载，从而避免某些服务器过载，而其他服务器却处于空闲状态。</p></li></ul><h5 id="good-to-know"><a href="#good-to-know" class="headerlink" title="good to know:"></a>good to know:</h5><ul><li>固定Fixed hostname (xxx.region.elb.amazonaws.com)</li><li>The application servers don’t see the IP of the client directly</li><li>The true IP of the client is inserted in the header <strong>X-Forwarded-For</strong> 请求标头可自动添加并帮助您识别客户端的 IP 地址</li><li>We can also get Port<ul><li>X-Forwarded-Port 请求标头可帮助您识别客户端与您的负载均衡器连接时所用的目标端口)</li><li>(X-Forwarded-Proto 请求标头可帮助您识别客户端与您的负载均衡器连接时所用的协议 (HTTP 或 HTTPS))</li></ul></li></ul><p><img src="https://img2022.cnblogs.com/blog/2122768/202204/2122768-20220417095141938-1484209070.png" alt="https:&#x2F;&#x2F;img2022.cnblogs.com&#x2F;blog&#x2F;2122768&#x2F;202204&#x2F;2122768-20220417095141938-1484209070.png"></p><h4 id="NLB-Network-Load-Balancer"><a href="#NLB-Network-Load-Balancer" class="headerlink" title="NLB-Network Load Balancer"></a><strong>NLB-Network Load Balancer</strong></h4><ul><li>优势：性能最好，每秒支持百万次请求，不需要预热（ALB和CLB流量大的话需要预热扩充负债均衡服务节点）；</li><li><strong>NLB的ip地址不会改变</strong>（CLB和ALB会随着时间改变，另外<strong>NLB可以分配固定弹性ip，ALB不能</strong>）</li><li><strong>无状态</strong>：NLB是无状态的，不会将请求粘滞在特定的后端实例上，适用于无状态应用。</li><li><strong>NLB has one static IP per AZ, and supports assigning Elastic IP</strong> (helpful for whitelisting specific IP)</li><li>NLB are used for extreme performance, TCP or UDP traffic</li><li><strong>Target Groups:</strong><ul><li>EC2 instances</li><li>IP Addresses – must be private IPs</li><li>Application Load Balancer</li></ul></li></ul><p><img src="https://img2022.cnblogs.com/blog/2122768/202204/2122768-20220417100514118-903354844.png" alt="https:&#x2F;&#x2F;img2022.cnblogs.com&#x2F;blog&#x2F;2122768&#x2F;202204&#x2F;2122768-20220417100514118-903354844.png"></p><h4 id="GWLB-Gateway-Load-Balancer"><a href="#GWLB-Gateway-Load-Balancer" class="headerlink" title="GWLB-Gateway Load Balancer"></a><strong>GWLB-Gateway Load Balancer</strong></h4><p>用于路由流量到多个目标（例如，虚拟机、容器、EC2 实例）以提高可用性和扩展性。GWLB 主要用于处理流量，例如 VPN、NAT（网络地址转换）、防火墙、代理和其他网络服务。以下是 Gateway Load</p><p>GWLB 是专为处理网络层流量而设计的，而不是应用层协议。它主要用于处理传输层的流量，例如 TCP 和 UDP。</p><p>典型的用途包括在 AWS 中设置网络架构，以便处理传输层的网络流量，如 VPN 连接、NAT 网关、防火墙、代理等。 GWLB 可以帮助实现高可用性和可扩展性，以满足网络流量的需求。</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a><strong>对比</strong></h4><table><thead><tr><th><strong>特性</strong></th><th><strong>CLB</strong></th><th><strong>ALB</strong></th><th><strong>NLB</strong></th><th><strong>GWLB</strong></th></tr></thead><tbody><tr><td>负载均衡类型</td><td>传输层（TCP）和应用层（HTTP&#x2F;HTTPS）</td><td>应用层（HTTP&#x2F;HTTPS）</td><td>传输层（TCP&#x2F;UDP）</td><td>传输层（TCP&#x2F;UDP）</td></tr><tr><td>支持WebSocket和HTTP&#x2F;2</td><td>不支持</td><td>支持</td><td>不支持</td><td>支持</td></tr><tr><td><strong>layer7-redirect</strong></td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>状态类型</td><td>stateful</td><td>stateful</td><td>stateless</td><td></td></tr><tr><td>支持容器化服务</td><td>不支持</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>请求路由</td><td>基于传统标签或路径</td><td>基于多个标签、路径和主机</td><td>基于端口和规则</td><td>基于多个标签、路径和主机</td></tr><tr><td>健康检查</td><td>TCP&#x2F;HTTP&#x2F;HTTPS</td><td>HTTP&#x2F;HTTPS</td><td>TCP&#x2F;UDP&#x2F;HTTP&#x2F;HTTPS</td><td>TCP&#x2F;UDP&#x2F;HTTP&#x2F;HTTPS</td></tr><tr><td>多个Target Group支持</td><td>不支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>支持IPv6</td><td>不支持</td><td>部分支持</td><td>支持</td><td>支持</td></tr><tr><td>用途</td><td>传统应用和服务的负载均衡</td><td>现代应用，<strong>microservice微服务</strong>的负载均衡</td><td>处理高流量和低延迟应用的负载均衡</td><td>使用NAT实例转发流量到私有子网和VPN设备的负载均衡</td></tr></tbody></table><h5 id="注："><a href="#注：" class="headerlink" title="注："></a><strong>注：</strong></h5><ol><li>WebSocket是一种支持双向通信的网络协议，它允许在单个TCP连接上进行全双工通信。WebSocket通常用于实现实时的双向通信，如在线聊天应用、实时游戏等。</li><li>HTTP&#x2F;2是HTTP协议的新版本，它在HTTP&#x2F;1.1的基础上进行了改进，提供了更高的性能和效率。可以加速网页加载并减少网络延迟。</li><li>ALB和NLB选择和区别当客户的业务基于HTTP&#x2F;HTTPS&#x2F;Websocket时候，优先考虑使用ALB。<strong>NLB可以处理7层的流量，但NLB不解析7层的协议</strong>，不会对协议进行处理。如果选择了ALB，则处理不了4层的流量，主要取决于选择的负载均衡器类型。</li></ol><h3 id="Sticky-Sessions-Session-Affinity-粘性会话、会话保持"><a href="#Sticky-Sessions-Session-Affinity-粘性会话、会话保持" class="headerlink" title="Sticky Sessions (Session Affinity)-粘性会话、会话保持"></a><strong>Sticky Sessions (Session Affinity)-粘性会话、会话保持</strong></h3><p>确保在会话期间将来自用户的所有请求发送到相同的实例中。这通常通过在用户的浏览器中设置一个特定的 Cookie 来实现。</p><ul><li>可以通过实现粘性会话，确保同一客户端始终被重定向到负载均衡器后面的同一实例。</li><li>这适用于经典负载均衡器和应用程序负载均衡器。</li><li>用于粘性会话的”cookie”具有您可控制的过期日期。</li><li>使用案例：确保用户不会丢失其会话数据。</li><li>启用粘性会话可能会导致后端 EC2 实例之间的负载不均衡。</li></ul><h3 id="Cookie-类型"><a href="#Cookie-类型" class="headerlink" title="Cookie 类型"></a><strong>Cookie 类型</strong></h3><ul><li>1.<strong>Application-based Cookies</strong><ul><li>自定义 Cookie<ul><li>由目标生成</li><li>这些 Cookie 是由负载均衡器的目标（即后端服务器实例）生成的。</li><li>每个目标组（Target Group）可以定义一个自定义的 Cookie 名称，以便满足应用程序的需求。</li><li>不要使用 <strong>AWSALB</strong>、<strong>AWSALBAPP</strong> 或 <strong>AWSALBTG</strong>（这些由 ELB 保留使用）</li></ul></li><li>应用程序 Cookie<ul><li>由负载均衡器生成</li><li>Cookie 名称为 <strong>AWSALBAPP</strong></li></ul></li></ul></li><li>2.<strong>持续时间Duration-based Cookies</strong></li></ul><h3 id="Cross-Zone-Balancing"><a href="#Cross-Zone-Balancing" class="headerlink" title="Cross-Zone Balancing"></a><strong>Cross-Zone Balancing</strong></h3><p>Cross-Zone Balancing允许ASG在跨越多个AZ时，尽量均匀地分布实例，以确保各个可用区的负载相对平衡。</p><ul><li><strong>Application Load Balancer</strong><ul><li><strong>Always on</strong> (can’t be disabled)</li><li>No charges for inter AZ data</li></ul></li><li><strong>Network Load Balancer</strong><ul><li>Disabled by default</li><li>You pay charges ($) for inter AZ data if enabled</li></ul></li><li><strong>Classic Load Balancer</strong><ul><li>Disabled by default</li><li>No charges for inter AZ data if enabled</li></ul></li></ul><h3 id="SSL-–-client到LB的加密"><a href="#SSL-–-client到LB的加密" class="headerlink" title="SSL – client到LB的加密"></a><strong>SSL – client到LB的加密</strong></h3><p>a SSL certificate allows traffic between your <strong>clients</strong> and your <strong>load balancer</strong> to be encrypted in <em><strong>transit</strong></em></p><h3 id="SNI-Server-Name-Indication"><a href="#SNI-Server-Name-Indication" class="headerlink" title="SNI- Server Name Indication"></a><strong>SNI</strong>- <strong>Server Name Indication</strong></h3><p>SNI解决了将<strong>多个SSL证书加载到一个Web服务器</strong>的问题（用于提供多个网站）。</p><ul><li>它是一个“较新”的协议，要求客户端在初始SSL握手中<strong>指示</strong>目标服务器的主机名。</li><li>然后服务器将查找正确的证书或返回默认证书。</li><li>SNI仅适用于ALB和NLB（新一代负载均衡器），以及CloudFront。</li><li>不适用于CLB（旧一代负载均衡器）</li></ul><h3 id="connection-draining-deregistration-delay"><a href="#connection-draining-deregistration-delay" class="headerlink" title="connection draining &amp; deregistration delay"></a><strong>connection draining &amp; deregistration delay</strong></h3><p>用于确保在服务节点从负载均衡器中移除时，已有的连接能够平滑地处理完毕而不会立即中断。</p><ol start="4"><li>CLB———Connection Draining（连接逐出）：当需要从负载均衡器上移除一个服务节点时，connection draining 是一种机制，用于逐渐关闭正在进行的连接。负载均衡器不再将新的连接分发给该节点，而是允许已有的连接完成其请求，然后逐渐关闭连接。这样可以避免中断正在进行的操作或导致数据丢失。</li><li>ALB &amp; NLB———Deregistration Delay（注销延迟）：deregistration delay 是指在将一个服务节点从负载均衡器中注销（或移除）之前，等待一段时间的延迟。在此期间，负载均衡器仍然将一部分流量转发到该节点，以确保现有的连接有足够的时间完成，并且新的连接不会立即被拒绝。这个延迟时间允许连接逐渐被关闭，确保服务平稳过渡。</li></ol><h3 id="VCPU（虚拟-CPU）"><a href="#VCPU（虚拟-CPU）" class="headerlink" title="VCPU（虚拟 CPU）"></a>VCPU（虚拟 CPU）</h3><p>虚拟机实例中使用的概念，用于模拟物理计算机的处理能力。在AWS中，当您创建虚拟机实例（instance）时，可以选择分配给该实例的VCPU数量，以满足您的计算需求。虚拟机实例是在AWS云中运行的虚拟计算资源，可以运行操作系统和应用程序。</p><p>在虚拟化环境中，<em>物理服务器上的CPU被划分为多个虚拟CPU（vCPU）以支持并发运行</em>的虚拟机实例。</p><p><strong>一个可用区包含多个实例，每个实例有一个或多个卷附加，实例的计算能力由分配给它的VCPU决定。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS-02【EC2】</title>
      <link href="/2023/08/02/AWS-02%E3%80%90EC2%E3%80%91/"/>
      <url>/2023/08/02/AWS-02%E3%80%90EC2%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="EC2"><a href="#EC2" class="headerlink" title="EC2"></a>EC2</h2><h3 id="elastic-compute-cloud，弹性计算云"><a href="#elastic-compute-cloud，弹性计算云" class="headerlink" title="elastic compute cloud，弹性计算云"></a>elastic compute cloud，弹性计算云</h3><p><img src="/images/3.png" alt="EC2"></p><p>EC2的本质是运行在云中虚拟机上的web服务。EC2 instance的本质是云上的虚拟机</p><p>Amazon EC2 提供以下功能：</p><ul><li>instance-虚拟计算环境</li><li>AMI-实例的预配置模板,也称为 *Amazon 系统映像</li><li><em>实例类型</em>:实例 CPU、内存、存储和网络容量的多种配置</li><li>使用<em>密钥对</em>的实例的安全登录信息（AWS 存储公有密钥，您在安全位置存储私有密钥）</li><li><em>实例存储卷</em>临时</li><li><em>Amazon EBS 卷</em></li><li>region AZ</li><li>防火墙，让您可以指定协议、端口，以及能够使用<em>安全组</em>到达您的实例的源 IP 范围</li><li>用于动态云计算的静态 IPv4 地址，称为<em>弹性 IP 地址</em></li><li>元数据，也称为<em>标签</em>，您可以创建元数据并分配给您的 Amazon EC2 资源</li><li>您可以创建的虚拟网络，这些网络与其余 AWS 云在逻辑上隔离，并且您可以选择连接到您自己的网络，也称为 <em>Virtual Private Cloud</em> (VPC)。</li></ul><h3 id="EC2购买选项"><a href="#EC2购买选项" class="headerlink" title="EC2购买选项"></a>EC2购买选项</h3><ol><li><p><strong>按需实例 (On-Demand Instances):</strong></p><ul><li><strong>特点：</strong> 按需实例没有长期合同，灵活性高，您只需支付您实际使用的计算能力，没有预付费或最低使用期要求。</li><li><strong>适用场景：</strong> 适用于临时工作负载、<strong>不可预测</strong>的工作负载、<strong>短期</strong>任务、初创企业或项目，以及需要快速扩展和缩减的情况。</li></ul></li><li><p><strong>预留实例 (Reserved Instances):</strong></p><ul><li><strong>特点：</strong> 预留实例需要事先支付部分费用，以换取更高的折扣，并在长期合同期间使用这些实例。分为标准、可转换、分摊和区域性预留实例。</li><li><strong>适用场景：</strong> 长期运行的<strong>稳定</strong>工作负载，具有可预测的使用需求，希望获得更大折扣的用户。</li></ul><blockquote><p>分类</p><ol><li><strong>标准预留实例（Standard Reserved Instances）：</strong><ul><li><em>指定的region 、instance family和大小</em>,不允许灵活更改实例类型</li><li>这些预留实例适用于长期稳定的工作负载。</li></ul></li><li><strong>可转换预留实例（Convertible Reserved Instances）：</strong><ul><li>可转换预留实例允许您在合同期内<strong>更改实例家族</strong>、大小和操作系统。这提供了更大的灵活性，适用于需要更改工作负载特性的情况。</li><li>虽然价格折扣通常较低，但您可以在长期合同内更改实例属性。</li></ul></li><li><strong>分摊预留实例（Scheduled Reserved Instances）：</strong><ul><li>在特定的时间窗口内使用实例</li></ul></li><li><strong>区域预留实例（Regional Reserved Instances）：</strong><ul><li>可在指定region内的多个AZ中使用</li><li>不允许更改实例家族（Instance Family）。</li></ul></li></ol></blockquote></li><li><p><strong>Spot 实例:</strong></p><ul><li><strong>特点：</strong> Spot 实例基于市场供求定价，价格通常低于按需实例，但实例可能会在供求波动时被终止。</li><li><strong>适用场景：</strong> 适用于可以容忍实例终止的工作负载，<strong>shot-time短期</strong>计算、批处理、大规模数据处理、测试和开发等。</li></ul></li><li><p><strong>Dedicated Hosts:</strong></p><ul><li><strong>特点：</strong> Dedicated Hosts 提供物理服务器，可以在上面运行 EC2 实例。适用于需要控制硬件分配和软件许可方面的情况。</li><li><strong>适用场景：</strong> 需要满足软件许可要求、安全性、合规性等需要的应用程序，以及需要在物理硬件上运行的特定工作负载。</li></ul></li></ol><h4 id="1-On-Demand-按需"><a href="#1-On-Demand-按需" class="headerlink" title="1. On Demand 按需"></a>1. On Demand 按需</h4><pre><code>recommended for **short-term** and **un-interrupted workloads**按照小时计费，根据使用时间的多少进行付费。 缺点：贵</code></pre><h4 id="2-Reserved-Instance-预留"><a href="#2-Reserved-Instance-预留" class="headerlink" title="2. Reserved Instance 预留"></a>2. Reserved Instance 预留</h4><pre><code>recommended for **steady-state usage applications**</code></pre><blockquote><p>使用类型:</p><p>可转换预留实例（Convertible Reserved Instance）</p><ul><li>实例类型转换</li><li>成本调整</li></ul><p>计划性预留实例（Scheduled Reserved Instance )</p><ul><li>预定灵活性：您可以指定特定的时间段，预订实例以满足您的计划性工作负载需求。例如，您可以预订每周的某个时间段或每天的特定时间段内的实例。</li><li>成本控制：通过计划性预留实例，您可以在计划性工作负载发生时，以更低的成本运行实例。</li></ul></blockquote><h4 id="3-Spot-Instance-竞价"><a href="#3-Spot-Instance-竞价" class="headerlink" title="3. Spot Instance 竞价"></a>3. Spot Instance 竞价</h4><p>请求未使用的 EC2 实例，这可能会显著降低您的 Amazon EC2 成本。</p><p>useful for workloads that are resilient to failure对于能够容忍故障的工作负载非常有用。</p><ul><li>batch jobs</li><li>data analysis</li><li>any distributed workloads</li></ul><p><strong>NOT suitable for critical job or database</strong></p><pre><code>竞价实例，当出价不够会被回收。 缺点：不稳定，但适合大规模集群计算</code></pre><h4 id="4-Dedicated-Hosts-专用主机"><a href="#4-Dedicated-Hosts-专用主机" class="headerlink" title="4. Dedicated Hosts 专用主机"></a>4. Dedicated Hosts 专用主机</h4><ul><li><p><strong>physical server</strong> with EC2 instance capacity</p><p>  物理服务器：EC2 Dedicated Hosts提供了一个完全专用的物理服务器，该服务器是由AWS托管的，专门为您的EC2实例提供。这意味着您的实例将独占整个物理服务器的计算资源，与其他用户的实例完全隔离。</p></li><li><p>help you address your <strong>compliance requirements</strong></p><p>  符合合规性要求：EC2 Dedicated Hosts可以帮助您满足合规性要求，例如在特定行业或法规中对计算资源的隔离性和可见性的要求。通过使用专用主机，您可以获得更高的隔离性和控制，以确保您的工作负载满足安全和合规性标准。</p></li><li><p>reduce cost by allowing you to <strong>use your existing server-bound software licenses</strong></p><p>  使用现有服务器绑定软件许可证：专用主机允许您使用您已拥有的、与特定物理服务器绑定的软件许可证。这意味着您可以将受限制的许可证软件（如特定操作系统、数据库或应用程序）部署到专用主机上，以充分利用您已经购买的软件许可证</p></li></ul><h4 id="5-Dedicate-instance"><a href="#5-Dedicate-instance" class="headerlink" title="5. Dedicate instance"></a>5. Dedicate instance</h4><h3 id="实例存储选项"><a href="#实例存储选项" class="headerlink" title="实例存储选项"></a>实例存储选项</h3><p>EBS 和 Instance Store</p><p> <strong>root volume &amp; EBS volume  &amp; instance store</strong></p><p>root volume是EC2实例的主要存储卷，通常用于操作系统和系统文件。</p><p>它是<strong>EC2实例的一部分</strong>，与实例的生命周期绑定。</p><p>EBS volume是一种可附加attach到EC2实例的虚拟硬盘</p><p><strong>root volume是instance的一部分，可以是instance store或EBS volume。</strong></p><ul><li>如果根卷是实例存储，直接连接到实例主机。它提供了高性能和低延迟的存储，但是它是<strong>临时性</strong>的，</li><li>如果根卷是EBS卷，它是一种持久性存储，数据会被保留，即使实例停止或终止</li></ul><h3 id="AWS-Savings-Plans"><a href="#AWS-Savings-Plans" class="headerlink" title="AWS Savings Plans"></a>AWS Savings Plans</h3><p><img src="/images/Untitled%204.png" alt="Untitled"></p><p>一种用于降低计算资源成本的计划，它提供了更灵活的折扣方式，适用于不同类型的计算资源和使用模式。</p><table><thead><tr><th>特征</th><th>EC2 Savings Plans</th><th>AWS Compute Savings Plans</th></tr></thead><tbody><tr><td>适用范围</td><td>EC2 实例</td><td>EC2 实例和 Fargate 任务</td></tr><tr><td>适用性灵活性</td><td>更大的实例选择</td><td>限于 EC2 实例</td></tr><tr><td>跨区域使用</td><td>可以在多个 AWS 区域使用</td><td>限于一个 AWS 区域</td></tr><tr><td></td><td><strong>在特定region内使用指定的instance family</strong></td><td>适用于您的 Fargate 和 Lambda 使用。</td></tr></tbody></table><h3 id="Compute-Savings-Plans"><a href="#Compute-Savings-Plans" class="headerlink" title="Compute Savings Plans"></a>Compute Savings Plans</h3><p>提供最大的灵活性和高达**66%**的按需价格折扣。这些计划会自动适用于您的 EC2 实例使用，不论实例类型大小区域、操作系统</p><p>它们还适用于您的 Fargate 和 Lambda 使用。</p><h3 id="EC2-instance-Savings-Plans"><a href="#EC2-instance-Savings-Plans" class="headerlink" title="EC2 instance Savings Plans"></a>EC2 instance Savings Plans</h3><p><strong>在特定region内使用指定的instance family</strong></p><p>可提供高达**72%**的按需折扣，以换取在选定的 AWS 区域（例如弗吉尼亚州的 M5）中对特定实例系列的承诺。这些计划会自动适用于使用情况，不论大小（例如 m5.xlarge、m5.2xlarge 等）、操作系统（例如 Windows、Linux 等）和租户（Host、Dedicated、Default）是否在指定的系列内。</p><p>通过 EC2 实例节省计划，您可以在实例系列内更改实例大小（例如从 c5.xlarge 到 c5.2xlarge）或操作系统（例如从 Windows 到 Linux），或从 Dedicated 租户切换到 Default，并继续获得 EC2 实例节省计划提供的折扣率。</p><h3 id="SageMaker-Savings-Plans"><a href="#SageMaker-Savings-Plans" class="headerlink" title="SageMaker Savings Plans"></a>SageMaker Savings Plans</h3><p>可提供高达64%的按需折扣。这些计划会自动适用于您的 SageMaker 实例使用，不论实例系列（例如 ml.m5、ml.c5 等）、实例大小（例如 ml.c5.large、ml.c5.xlarge 等）、区域（例如 us-east-1、us-east-2 等）或组件（例如 Notebook、Training 等）。使用 SageMaker 节省计划，您可以随时将工作负载从 ml.c5 切换到 ml.m5，将使用情况从 Europe（爱尔兰）切换到 Europe（伦敦），或将使用情况从 Training 切换到 Inference，并继续获得好处。</p><h3 id="EC2-Hibernate-休眠"><a href="#EC2-Hibernate-休眠" class="headerlink" title="EC2 Hibernate -休眠"></a>EC2 <strong>Hibernate -休眠</strong></h3><p><img src="/images/Untitled%205.png" alt="Untitled"></p><p>hibernate会将实例内存 (RAM) 中的内容保存到Amazon EBS root volume。</p><blockquote><p><strong>Use cases:</strong></p><p>long-running processing</p><p>saving the RAM state</p><p>services that take time to initialize</p></blockquote><h3 id="EC2-Hibernate-–-Good-to-know"><a href="#EC2-Hibernate-–-Good-to-know" class="headerlink" title="EC2 Hibernate – Good to know"></a><strong>EC2 Hibernate – Good to know</strong></h3><ul><li><strong>Supported instance families</strong> - C3, C4, C5, M3, M4, M5, R3, R4, and R5</li><li><strong>Instance RAM size</strong> - must be less than 150 GB</li><li><strong>Instance size</strong> - not supported for bare metal instances</li><li><strong>AMI</strong>: Amazon Linux 2, Linux AMI, Ubuntu &amp; Windows…</li><li><strong>Root Volume</strong>: must be EBS, encrypted, not instance store, and large</li><li>Available for On-Demand and Reserved Instances</li><li>An instance cannot be hibernated more than 60 days</li></ul><h3 id="EC2-nitro"><a href="#EC2-nitro" class="headerlink" title="EC2 nitro"></a>EC2 nitro</h3><p>Nitro技术是Amazon Web Services（AWS）用于提供<strong>高性能、高可靠性</strong>和<strong>安全性</strong>的云计算服务的一项技术。</p><p>Nitro系统是基于Nitro技术构建的AWS的硬件和软件基础设施。它提供了直接访问计算、存储和网络资源的能力，同时隔离虚拟化实例，提供更好的性能和安全性。</p><p>Nitro技术是指AWS用于提供云计算服务的一项技术，而Nitro系统则是该技术的实际实施和基础设施。</p><h3 id="placement-groups-置放群组"><a href="#placement-groups-置放群组" class="headerlink" title="placement groups 置放群组"></a>placement groups <strong>置放群组</strong></h3><p>EC2 服务会通过一些策略<strong>将instance置放在硬件上</strong>，以便减少故障，满足负载需求。</p><ul><li><p><strong>cluster</strong> <strong>集群</strong> :将一个AZ中靠近的实例打包在一起。通过使用该策略，工作负载可以实现所需的低延迟网络性能，以满足高性能计算（HPC）应用程序.</p><ul><li><p>high performance but high risk高性能高风险</p></li><li><p>使用案例**:**</p><p>  <strong>big data</strong> job needs to complete fast</p><p>  application that needs extremely <strong>low latency</strong> and <strong>high network throughput</strong></p></li></ul><p>  <img src="/images/Untitled%206.png" alt="Untitled">  </p></li><li><p><strong>partiton 分区</strong> – 将实例分布在不同的逻辑分区上，以便一个分区中的实例组不会与不同分区中的实例组使用相同的基础硬件。该策略通常为大型分布式和重复的工作负载所使用，例如，Hadoop、Cassandra 和 Kafka。</p><p>  使用案例：</p><p>  HDFS, HBase, Cassandra, Kafka</p><p>  <img src="/images/Untitled%207.png" alt="Untitled"></p></li><li><p><strong>Spread 分布</strong> – 将实例分别置放在不同硬件上以减少相关的故障。</p><p>  机架分布置放群组可以跨越同一区域中的多个可用区。对于机架分布置放群组，每个群组在每个可用区中最多可以运行<strong>七个</strong>实例。</p><p>  应用案例：</p><ul><li>application that needs to maximize <strong>high availability</strong></li><li>重要关键应用，必须隔离失败实例</li></ul><p>  <img src="/images/Untitled%208.png" alt="Untitled"></p></li></ul><h3 id="scaling-strategies-扩展策略"><a href="#scaling-strategies-扩展策略" class="headerlink" title="scaling strategies-扩展策略"></a>scaling strategies-扩展策略</h3><p>根据资源的需求自动调整计算实例的数量</p><ol><li><strong>Target Tracking 扩展策略：</strong><ul><li>使用 CloudWatch 指标来跟踪资源的使用情况，如 CPU 使用率、网络流量等。</li><li>定义目标值，即您希望保持的指标水平。</li><li>系统将自动调整实例数量，以使跟踪的指标接近目标值。</li></ul></li><li><strong>Simple 扩展策略：</strong><ul><li>定义一个或多个阈值，用于触发扩展或缩减操作。</li><li>当某个指标达到或超过阈值时，系统将执行相应的自动扩展操作，例如增加实例数量。</li><li>当指标低于阈值时，系统将执行缩减操作，例如减少实例数量。</li></ul></li><li><strong>Step Scaling 扩展策略：</strong><ul><li>类似于 Simple 扩展策略，但您可以定义多个阶段，每个阶段都有一个阈值和扩展&#x2F;缩减操作。</li><li>这允许您在不同的资源使用水平上采取不同的扩展步骤。</li></ul></li></ol><h3 id="Auto-Scaling"><a href="#Auto-Scaling" class="headerlink" title="Auto Scaling"></a>Auto Scaling</h3><p><img src="/images/Untitled%209.png" alt="Untitled"></p><h4 id="EC2-auto-scaling"><a href="#EC2-auto-scaling" class="headerlink" title="EC2 auto scaling"></a>EC2 auto scaling</h4><p>Amazon EC2 Auto Scaling 帮助您确保具有正确数量的 Amazon EC2 实例以处理应用程序负载。<br><strong>ASG</strong>- Auto Scaling group</p><p>ASG（Auto Scaling Group）是一种用于自动扩展和管理云资源的服务，它能根据需求自动<strong>增加scale out</strong>或<strong>减少scale in</strong>实例数量，以适应应用程序的负载变化。</p><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><p>Auto Scaling Group 可以实现以下功能：</p><ol start="4"><li><strong>自动扩展</strong>：ASG 可以根据负载情况自动增加或减少 EC2 实例的数量。当负载增加时，ASG 会自动启动新的 EC2 实例，以满足需求。当负载减少时，ASG 会自动终止多余的 EC2 实例，以节省成本。</li><li><strong>健康检查</strong>：ASG 可以定期检查 EC2 实例的健康状态，以确保它们正常工作。如果某个实例出现问题，ASG 可以自动替换该实例，以保持应用程序的可用性。</li><li><strong>负载均衡</strong>：ASG 可以与负载均衡器（如ELB）结合使用，以分发流量到不同的 EC2 实例。这有助于提高应用程序的可用性和性能。</li><li><strong>手动扩展</strong>：除了自动扩展外，您还可以手动调整 ASG 中的实例数量，以满足临时的或非常大的负载。</li><li><strong>细粒度控制</strong>：ASG 可以配置以自定义的方式来满足应用程序的需求，如设置最小和最大实例数量、扩展策略、启动配置等。</li></ol><h5 id="ASG拓展类型"><a href="#ASG拓展类型" class="headerlink" title="ASG拓展类型"></a>ASG拓展类型</h5><h6 id="手动-munual-scaling"><a href="#手动-munual-scaling" class="headerlink" title="手动-munual scaling"></a>手动-munual scaling</h6><p>通过修改 Auto Scaling 组的最大容量、最小容量或所需容量的配置，然后Auto Scaling 管理创建或终止实例的流程匹配修改后的容量。</p><h6 id="定时-scheduled-actions"><a href="#定时-scheduled-actions" class="headerlink" title="定时-scheduled actions"></a>定时-scheduled actions</h6><p>定时扩展允许您在特定时间或日期执行扩展或缩减操作，无需依赖于实际负载情况。这对于已知的预期负载变化很有用，例如每天的业务高峰期。</p><p>例如周末不允许，不需要实例</p><h6 id="按需-动态-dynamic-scaling-policies"><a href="#按需-动态-dynamic-scaling-policies" class="headerlink" title="按需&#x2F;动态-dynamic scaling policies:"></a>按需&#x2F;动态-dynamic scaling policies:</h6><p>动态扩缩会根据流量的变化扩展自动扩缩组的容量。</p><ol start="9"><li><p><strong>Target Tracking scaling-目标跟踪</strong></p><p> 没有固定阈值</p><p> 据目标指标来动态调整实例数量</p><p> 根据Amazon CloudWatch 指标和目标值增加或减少组的当前容量。</p></li><li><p><strong>Simple Scaling（简单扩展）：</strong></p><p>基于固定的阈值进行扩展或缩减<br>通过单次扩缩调整来增加和减少组的当前容量，每次扩缩活动之间有一个<strong>冷却时间</strong>。</p><p>例如在负载高峰时增加实例数量，在负载下降时减少实例数量。</p></li><li><p><strong>Step Scaling（阶梯扩展）</strong></p><p>设置阶梯，每个阶梯都有一个与之关联的触发条件<br>通过一系列扩缩调整（也称<em>步进调整</em>）来增加和减少组的当前容量，具体调整因警报严重程度而异</p></li></ol><h6 id="预测-predictive-scaling-policies"><a href="#预测-predictive-scaling-policies" class="headerlink" title="预测-predictive scaling policies"></a>预测-predictive scaling policies</h6><p>预测式扩展非常适合以下情况：</p><ul><li>周期性流量，例如正常营业时间内的高资源利用率以及晚上和周末的低资源利用率</li><li>重复 on-and-off 的工作负载模式，例如批处理、测试或定期数据分析</li><li>初始化需要很长时间的应用程序，从而在向外扩展事件期间对应用程序性能造成明显的延迟影响</li></ul><h3 id="Cross-Zone-Balancing"><a href="#Cross-Zone-Balancing" class="headerlink" title="Cross-Zone Balancing"></a>Cross-Zone Balancing</h3><p>Cross-Zone Balancing允许ASG在跨越多个AZ时，尽量均匀地分布实例，以确保各个可用区的负载相对平衡。</p><ul><li><strong>Application Load Balancer</strong><ul><li><strong>Always on</strong> (can’t be disabled)</li><li>No charges for inter AZ data</li></ul></li><li><strong>Network Load Balancer</strong><ul><li>Disabled by default</li><li>You pay charges ($) for inter AZ data if enabled</li></ul></li><li><strong>Classic Load Balancer</strong><ul><li>Disabled by default</li><li>No charges for inter AZ data if enabled</li></ul></li></ul><h3 id="ASG默认终止策略ASG-Default-Termination-Policy（简化版本）："><a href="#ASG默认终止策略ASG-Default-Termination-Policy（简化版本）：" class="headerlink" title="ASG默认终止策略ASG Default Termination Policy（简化版本）："></a><strong>ASG默认终止策略ASG Default Termination Policy（简化版本）：</strong></h3><ol start="12"><li>查找具有最多实例的可用区（AZ）。</li><li>如果在该可用区有多个实例可供选择，则删除具有最旧启动配置的实例。</li></ol><ul><li><strong>ASG默认尝试在可用区之间平衡实例数量</strong></li></ul><h3 id="Lifecycle-Hooks"><a href="#Lifecycle-Hooks" class="headerlink" title="Lifecycle Hooks"></a><strong>Lifecycle Hooks</strong></h3><p>Lifecycle Hooks允许您执行自定义脚本或操作。这使您能够在实例处于特定状态时执行额外的任务，如在实例启动前进行初始化操作，或在实例终止前执行清理任务。</p><p>Lifecycle Hooks有两种类型：</p><ol start="14"><li><strong>Lifecycle Hook for Instance Launch (启动实例生命周期挂钩)：</strong> 当新实例被添加到ASG并处于“Pending”状态时触发。您可以在此时执行一些初始化任务或验证操作。只有在完成这些任务后，实例才会被标记为“InService”状态并接收流量。</li><li><strong>Lifecycle Hook for Instance Termination (终止实例生命周期挂钩)：</strong> 当实例即将被终止时触发。您可以在此时执行清理任务或将实例从其他服务中解除绑定，以确保安全地终止实例。</li></ol><ul><li>默认情况下，一旦在ASG中启动实例，它就处于“in service”状态。</li><li>您有能力在实例进入“已服务”状态之前执行额外的步骤（“pending”状态）。</li><li>您有能力在实例终止之前执行一些操作（“terminating”状态）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS-01【云计算基础】</title>
      <link href="/2023/08/01/AWS-01%E3%80%90%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80%E3%80%91/"/>
      <url>/2023/08/01/AWS-01%E3%80%90%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="云计算基础"><a href="#云计算基础" class="headerlink" title="云计算基础"></a><strong>云计算基础</strong></h1><h2 id="云计算定义与特点："><a href="#云计算定义与特点：" class="headerlink" title="云计算定义与特点："></a><strong>云计算定义与特点</strong>：</h2><ul><li>云计算是一种基于互联网的计算模型，通过共享的计算资源，提供按需获取、快速交付和灵活扩展的计算服务。它将计算、存储、网络和其他相关技术资源提供给用户，使他们能够在不需拥有实际硬件设备和基础设施的情况下，通过网络访问和使用这些资源。</li></ul><h2 id="云计算服务模型："><a href="#云计算服务模型：" class="headerlink" title="云计算服务模型："></a><strong>云计算服务模型</strong>：</h2><ul><li>1.2.1 <strong>IaaS（基础设施即服务）</strong>：<ul><li>熟悉 IaaS 提供的基础设施层，如 Amazon EC2 实例，允许用户管理操作系统、应用程序等。</li></ul></li><li>1.2.2 <strong>PaaS（平台即服务）</strong>：<ul><li>详细了解 PaaS 模型，如 AWS Elastic Beanstalk，它提供托管的平台，简化应用程序的开发和部署。</li></ul></li><li>1.2.3 <strong>SaaS（软件即服务）</strong>：<ul><li>了解 SaaS，如 Amazon S3、Amazon RDS 等，提供现成的软件和服务。</li></ul></li></ul><h2 id="部署模型："><a href="#部署模型：" class="headerlink" title="部署模型："></a><strong>部署模型：</strong></h2><p>云计算的部署模型描述了云服务的基础设施在何处部署以及如何访问。主要有以下四种部署模型：</p><ol><li><strong>公共云：</strong> 公共云是对外提供服务的云计算基础设施，由云服务提供商管理和维护。多个用户可以共享这些资源，如 AWS、Azure、Google Cloud。</li><li><strong>私有云：</strong> 私有云是一种在企业内部或特定组织中部署的云计算基础设施。资源在受限的范围内使用，提供更严格的安全性和隐私控制。</li><li><strong>社区云：</strong> 社区云是为特定行业、垂直市场或社区组织提供的云计算基础设施，资源可以由多个组织共享。这种模型可以满足共同需求，同时保持一定程度的独立性。</li><li><strong>混合云：</strong> 混合云结合了公共云和私有云，允许数据和应用程序在不同环境之间迁移。这使得用户能够在公共云中扩展或备份私有云中的资源。</li></ol><h2 id="AWS"><a href="#AWS" class="headerlink" title="AWS"></a><strong>AWS</strong></h2><h3 id="Amazon-Web-Services"><a href="#Amazon-Web-Services" class="headerlink" title="Amazon Web Services"></a>Amazon Web Services</h3><p>是由亚马逊公司提供的云计算平台和服务。它为个人、企业和组织提供了一系列基于云技术的计算、存储、数据库、网络、分析、机器学习等服务。AWS 的目标是帮助用户以高<strong>效、灵活和经济高效的方式构建和管理各种应用程序，而无需担心传统硬件基础设施的维护和管理。</strong></p><p>AWS 提供的服务涵盖了广泛的领域，包括但不限于：</p><ol><li><strong>计算服务：</strong> 包括弹性虚拟服务器 EC2，Lambda 无服务器计算，Elastic Beanstalk 应用托管等。</li><li><strong>存储和数据库：</strong> 包括S3（Simple Storage Service）对象存储，EBS（Elastic Block Store）块存储，RDS（Relational Database Service）关系数据库，DynamoDB NoSQL 数据库等。</li><li><strong>网络和内容分发：</strong> 包括Virtual Private Cloud（VPC）虚拟网络，CloudFront内容分发网络，Route 53 域名系统等。</li><li><strong>分析和大数据：</strong> 包括Redshift 数据仓库，Athena 查询服务，EMR（Elastic MapReduce）大数据处理等。</li><li><strong>人工智能和机器学习：</strong> 包括SageMaker 机器学习平台，Rekognition 图像和视频分析，Lex 自然语言处理等。</li><li><strong>安全和身份管理：</strong> 包括IAM 身份和访问管理，Key Management Service（KMS）数据加密，WAF（Web Application Firewall）应用程序防火墙等。</li><li><strong>开发工具和集成：</strong> 包括CodeCommit 代码托管，CodeBuild 构建工具，CodeDeploy 部署工具，API Gateway 管理 API 等。</li><li><strong>物联网：</strong> 包括IoT Core 物联网核心，Greengrass 物联网设备本地运算等。</li></ol><p>AWS 为用户提供了按需使用、灵活扩展的计算资源，以及一系列强大的工具和服务，使用户能够根据业务需求进行快速创新和发展。作为全球领先的云计算服务提供商，AWS 在各种行业和规模的项目中广泛应用。</p><h1 id="AWS-全球基础设施"><a href="#AWS-全球基础设施" class="headerlink" title="AWS 全球基础设施"></a><strong>AWS 全球基础设施</strong></h1><h2 id="AZ-可用区"><a href="#AZ-可用区" class="headerlink" title="AZ-可用区"></a>AZ-可用区</h2><ul><li>Availability Zone</li><li>一个独立的数据中心或机房</li><li>AWS基础设施中的<strong>物理实际存在</strong>，代表独立的数据中心或机房，具有独立的电力、网络和故障隔离机制。用户可以利用可用区的设置来实现高可用性、容错和地理分布。</li><li>每个可用区被分配了唯一的标识符（例如：<strong>us-east-1a、us-east-1b</strong>），以区分不同的可用区。</li></ul><h2 id="Region-区域"><a href="#Region-区域" class="headerlink" title="Region-区域"></a>Region-区域</h2><ul><li>AWS区域是指AWS基础设施中的一个**物理地理区域，**具有自己的电力、网络和数据中心设施。</li><li>AWS全球基础设施由多个区域组成，每个区域可以包含多个可用区。</li></ul><h2 id="AWS-Edge-Locations-边缘位置"><a href="#AWS-Edge-Locations-边缘位置" class="headerlink" title="AWS Edge Locations-边缘位置"></a>AWS Edge Locations-边缘位置</h2><p>在全球多个城市和地区战略性地分布，以使内容更接近终端用户，从而减少延迟并提高内容传递的整体性能。</p><h2 id="AWS-Global-Accelerator"><a href="#AWS-Global-Accelerator" class="headerlink" title="AWS Global Accelerator"></a>AWS Global Accelerator</h2><ul><li><p>将用户的请求从全球各地路由到距离最近的可用源终端。</p></li><li><p>它通过使用全球分布的边缘位置（Edge Locations）和<em><strong>Anycast IP地址【任意播地址】</strong></em>，将用户的请求导向到距离最近的可用终端，从而实现更快的访问速度和更低的延迟。</p></li><li><p>Global Accelerator 非常适用于<strong>非 HTTP 情况</strong>，如游戏 (UDP)、物联网 (MQTT) 或 VoIP，</p><pre><code>          HTML</code></pre><p>  ​<br>  ​<br>  ​<br>  ​<br>  ​<br>  ​</p></li></ul><p>🐳 anycast IP-多个设备共享相同IP地址，数据包将传输到最近的设备​</p><pre><code>HTML</code></pre><p>​<br>​<br>​<br>​<br>​<br>​<br>➡️ <strong>Endpoint终端节点</strong>​</p><pre><code>HTML</code></pre><p>​<br>​<br>​<br>​<br>​<br>​<br>➡️ 终端节点是全局加速器将流量定向到的资源。<br>标准加速器的终端节点可以是NLB、ALB、EC2 实例或弹性 IP 地址。​</p><pre><code>HTML</code></pre><p>​<br>​<br>​<br>​<br>​<br>​<br>➡️ 对于每个端点，您可以配置权重，这些权重是可用于指定路由到每个端点的流量比例的数字。例如，这对于在区域内进行性能测试非常有用。​</p><ul><li>利用AWS内部网络将请求路由到您的应用程序</li><li>适用于Elastic IP、EC2实例、ALB、NLB、公共或私有资源</li><li>稳定的性能<ul><li><strong>智能路由选择最低延迟和failover快速区域故障转移</strong></li><li><strong>不会出现客户端缓存问题（因为IP不会改变）</strong></li><li>使用AWS内部网络传输数据</li></ul></li><li>健康检查<ul><li>全球加速器对您的应用程序进行健康检查</li><li>有助于使您的应用程序具备全球性（对于不健康的应用程序，<strong>故障转移时间小于1分钟）</strong></li><li>适用于灾难恢复（得益于健康检查功能）</li></ul></li><li>安全性<ul><li><em>只<strong>需将2个外部IP地址加入白名单</strong></em></li><li>得益于AWS Shield，具备DDoS防护功能</li></ul></li></ul><h2 id="CloudFront"><a href="#CloudFront" class="headerlink" title="CloudFront"></a>CloudFront</h2><p>![Untitled](D:&#x2F;hexo&#x2F;source&#x2F;_posts&#x2F;&#x2F;images&#x2F;Untitled 1.png)</p><ul><li>AWS的 CloudFront 是一个内容分发网络（Content Delivery Network，CDN）服务</li><li>它通过在<strong>全球范围</strong>内建立边缘节点，将网站的内容复制并缓存到离用户最近的服务器上，以加速网站的加载，提供更好的用户体验。</li><li>一项加快<em><strong>将静态和动态</strong></em> Web 内容（例如 .html、.css、.js 和图像文件）分发给用户的速度的 Web 服务。</li></ul><ol><li><p>静态内容（Static Content）：</p><ul><li>图像、CSS 样式表、JavaScript 文件、HTML 页面等。</li><li>静态内容不会因用户请求的不同而改变，因此可以被缓存以提高加载速度和性能。</li></ul></li><li><p>动态内容（Dynamic Content）：</p><ul><li><p>动态内容可以根据用户的输入、状态、权限等不同情况来生成不同的响应。例如，根据用户的搜索查询生成的搜索结果页面、用户个人资料页面等都是动态内容。</p><pre><code>          HTML</code></pre><p>  ​<br>  ​<br>  ​<br>  ​<br>  ​<br>  ​</p></li></ul><p>➡️ 在电子商务网站中，通常会有一些页面和资源是相对不变的，例如公司的标志、产品图片、网站样式表等，这些属于静态内容。而用户的购物车、订单历史、产品库存状态等可能因用户请求或时间变化而产生不同的数据，这些属于动态内容。​</p></li></ol><h2 id="CloudFront的运作过程："><a href="#CloudFront的运作过程：" class="headerlink" title="CloudFront的运作过程："></a><strong>CloudFront的运作过程：</strong></h2><ol><li><strong>内容上传：</strong> 首先，网站的所有内容（如图片、视频、CSS样式、JavaScript脚本等）都需要上传到亚马逊S3（Simple Storage Service）存储桶、Elastic Load Balancer、EC2（Elastic Compute Cloud）实例或其他支持的<strong>源服务器</strong>上。这些服务器被称为源服务器，它们存储着网站的原始内容。</li><li><strong>内容缓存：</strong> 一旦内容上传到源服务器，CloudFront 会将这些内容复制到全球各地的边缘节点（Edge Locations）。这些边缘节点通常位于不同的城市和国家，离用户更近，从而减少了用户与源服务器之间的距离和网络延迟。</li><li><strong>用户请求：</strong> 当有用户想要访问网站时，他们的请求会被发送到离他们最近的 CloudFront 边缘节点。</li><li><strong>边缘节点响应：</strong> 边缘节点会检查用户请求所需的内容是否已经缓存在本地。如果缓存中有，它会立即将内容返回给用户，不需要再向源服务器发送请求。这就大大加快了网站内容的加载速度。</li><li><strong>源服务器请求：</strong> 如果边缘节点上没有所需的内容（或者内容过期了），边缘节点会代表用户向源服务器发送请求，从源服务器获取内容。</li><li><strong>内容更新：</strong> 如果网站的内容在源服务器上发生了更改，CloudFront 会自动检测到并更新边缘节点上的缓存，以确保用户获取到最新的内容。</li></ol><h2 id="CloudFront-Geo-Restriction地理限制"><a href="#CloudFront-Geo-Restriction地理限制" class="headerlink" title="CloudFront Geo Restriction地理限制"></a><strong>CloudFront Geo Restriction地理限制</strong></h2><ul><li>您可以通过白名单或黑名单限制用户从哪个国家访问您的分发</li><li>用例：版权法律</li></ul><h2 id="Cache-Invalidation缓存失效"><a href="#Cache-Invalidation缓存失效" class="headerlink" title="Cache Invalidation缓存失效"></a><strong>Cache Invalidation缓存失效</strong></h2><ul><li>当您更新原始内容并希望刷新全球边缘位置中的所有缓存内容时</li><li>您可以强制刷新整个或部分缓存</li><li>您可以使所有文件 (<em>) 或特殊路径（&#x2F;images&#x2F;</em>）失效</li></ul><h2 id="Lambda-Edge"><a href="#Lambda-Edge" class="headerlink" title="Lambda@Edge:"></a><strong>Lambda@Edge:</strong></h2><p> Lambda@Edge 是在 CloudFront 边缘节点上运行的 AWS Lambda 函数，用于在请求和响应的不同阶段执行自定义逻辑。</p><h2 id="origin-servers-源服务器"><a href="#origin-servers-源服务器" class="headerlink" title="origin servers-源服务器"></a>origin servers-源服务器</h2><ol><li><strong>Amazon S3 bucket：</strong> 您可以将 Amazon S3 存储桶作为 CloudFront 的源服务器，以将静态内容（如图片、CSS、JavaScript 等）分发到全球边缘位置。</li><li><strong>（Custom Origins）：</strong> 这包括多种类型的自定义源服务器，可以通过 CloudFront 配置将内容从这些源分发到边缘位置。自定义源类型包括：<ul><li><strong>Amazon EC2 实例：</strong> 您可以将运行在 Amazon EC2 上的应用程序作为源服务器，将动态内容分发到全球边缘位置。</li><li><strong>Amazon Elastic Load Balancer（ELB）：</strong> 将位于 Elastic Load Balancer 后面的应用程序作为源服务器，以实现负载均衡和高可用性。</li><li><strong>Amazon API Gateway：</strong> 将托管在 API Gateway 上的 RESTful API 作为源服务器，以加速 API 请求的响应速度。</li><li><strong>非 AWS 源服务器：</strong> 您还可以将位于其他云提供商或自己托管的服务器作为 CloudFront 的源服务器。</li></ul></li></ol><h2 id="价格类别"><a href="#价格类别" class="headerlink" title="价格类别"></a><strong>价格类别</strong></h2><ul><li>全部价格类别：所有地区-最佳性能</li><li>价格类200：大多数地区，但不包括最昂贵的地区</li><li>价格类100：仅最便宜的地区</li></ul><p>![Untitled](D:&#x2F;hexo&#x2F;source&#x2F;_posts&#x2F;&#x2F;images&#x2F;Untitled 2.png)</p><h2 id="CloudFront-V-S-S3-Cross-Region-Replication"><a href="#CloudFront-V-S-S3-Cross-Region-Replication" class="headerlink" title="CloudFront V.S. S3 Cross Region Replication"></a>CloudFront V.S. S3 Cross Region Replication</h2><ul><li><p>CloudFront</p><ul><li>CloudFront uses global edge network</li><li>files are cached for a TTL(like a day)</li><li>greate for static content that must be available everywhere</li></ul></li><li><p>S3 Cross Region Replication</p><ul><li>must be setup for each region you want replication</li><li>files are updated in near real-time</li><li>read only</li><li>great for dynamic content that needs to be available at low-latency regions</li></ul><p>CloudFront V.S. S3跨区域复制</p><ul><li>CloudFront<ul><li>CloudFront使用全球边缘网络</li><li>文件被缓存TTL（如一天）</li><li>适用于必须在任何地方提供的静态内容</li></ul></li><li>S3跨区域复制<ul><li>必须为您想要复制的每个区域设置</li><li>文件实时更新</li><li>只读</li><li>适用于需要在低延迟区域提供的动态内容</li></ul></li></ul></li></ul><h2 id="AWS-Global-Accelerator-V-S-CloudFront"><a href="#AWS-Global-Accelerator-V-S-CloudFront" class="headerlink" title="AWS Global Accelerator V.S.  CloudFront"></a>AWS Global Accelerator V.S.  CloudFront</h2><p>它们都使用AWS全球网络和世界各地的<strong>边缘位置（Edge Locations）</strong>。<br>这两项服务都与AWS Shield集成，提供DDoS防护。</p><p>CloudFront：</p><ul><li>优化<strong>缓存</strong>内容（如图像和视频）和动态内容（如API加速和动态网站交付）的性能。</li><li>内容在边缘位置（Edge Locations）上提供服务。</li></ul><p>Global Accelerator：</p><ul><li><strong>适用于需要确定性、快速区域故障转移的HTTP用例</strong>。</li><li><strong>适用于非HTTP用例，例如游戏（UDP）、物联网（MQTT）或VoIP（Voice over IP）。</strong></li><li>适用于<strong>需要静态IP地址的HTTP用例</strong>。</li><li>提升在TCP或UDP上运行的广泛应用程序的性能。</li><li>在边缘位置代理数据包到运行在一个或多个AWS区域的应用程序。</li></ul><p>简而言之，AWS Global Accelerator 主要用于提高广泛应用程序的性能，包括非HTTP用例，而 CloudFront 则主要用于优化缓存和动态内容的性能，以及适用于 HTTP 用例的加速和交付。</p><ul><li><p>They both use the AWS global network and its edge locations around the world</p></li><li><p>Both services integrate with AWS Shield for DDoS protection</p></li><li><p>CloudFront</p><ul><li>Improves performance for both cacheable content (such as images and videos)</li><li>Dynamic content (such as API acceleration and dynamic site delivery)</li><li>Content is served at the edge</li></ul></li><li><p>Global Accelerator</p><ul><li><p>Improves performance for a wide range of applications over TCP or UDP</p></li><li><p>Proxying packets at the edge to applications running in one or more AWS Regions</p></li><li><p>Good fit for non-HTTP use cases, such as gaming (UDP), IoT (MQTT), or Voice over IP</p></li><li><p>Good for HTTP use cases that require static IP addresses</p></li><li><p>Good for HTTP use cases that required deterministic, fast regional failover</p><h1 id="concepts-you-need-to-know"><a href="#concepts-you-need-to-know" class="headerlink" title="concepts you need to know"></a>concepts you need to know</h1><h5 id="AMI-Amazon-Machine-Image"><a href="#AMI-Amazon-Machine-Image" class="headerlink" title="AMI (Amazon Machine Image)"></a>AMI (Amazon Machine Image)</h5><ol><li>AMI是一种EC2 instance的snapshot</li><li>AMI是一种包含软件配置的模板。</li><li>AMI 包括以下内容：<ul><li>一个或多个 Amazon Elastic Block Store (Amazon EBS) 快照；对于由实例存储支持的 AMI，包括一个用于实例（例如，操作系统、应用程序服务器和应用程序）根卷的模板。</li><li>控制可以使用 AMI 启动实例的 AWS 账户的启动许可。</li><li>数据块设备映射，指定在实例启动时要附加到实例的卷</li></ul></li></ol><p>通过 AMI，您可以<em><strong>启动实例</strong></em>，实例是作为云中虚拟服务器运行的 AMI 的副本。</p><ul><li>AMI are a <strong>customization</strong> of an EC2 instance<ul><li>You add your own software, configuration, operating system, monitoring…</li><li>Faster boot &#x2F; configuration time ，因为所有软件都是预打包的</li></ul></li><li>AMI are built for a <strong>specific region</strong> (and can be copied across regions)</li><li>您可以从以下位置启动 EC2 实例：<ul><li><strong>公共 AMI</strong>：由 AWS 提供。</li><li><strong>您自己的 AMI</strong>：您自己创建和维护的 AMI。</li><li><strong>AWS Marketplace AMI</strong>：其他人创建（并有可能销售）的 AMI。</li></ul></li></ul><h5 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h5><p>**Uniform Resource Locator（**统一资源定位符）</p><p>用于在网络上标识和定位资源的地址。</p><p>通常，一个URL由以下几个部分组成：</p><ol><li><strong>协议（Protocol）：</strong> URL的协议部分指定了用于访问资源的协议或协议方案，如HTTP、HTTPS、FTP等。例如，在”<a href="http://www.example.com/">http://www.example.com</a>“中，”http”就是协议。</li><li><strong>域名（Domain Name）：</strong> URL的域名部分是用于标识网络上资源所在的主机名。域名是由一系列标签和点号组成，例如”<a href="http://www.example.com/">www.example.com</a>“就是一个域名。</li><li><strong>端口号（Port）：</strong> URL的端口号部分是可选的，它指定了要访问资源的目标端口。如果未指定端口号，则使用协议的默认端口。例如，在”<a href="http://www.example.com/">http://www.example.com:80</a>“中，”:80”是端口号，表示要使用HTTP协议的默认端口80。</li><li><strong>路径（Path）：</strong> URL的路径部分指定了资源在服务器上的位置和名称。路径由斜杠”&#x2F;“分隔的字符串组成，用于标识资源在服务器文件系统中的位置。例如，在”<a href="http://www.example.com/index.html%22%E4%B8%AD%EF%BC%8C%22/index.html">http://www.example.com/index.html&quot;中，&quot;/index.html</a>“就是路径。</li><li><strong>查询字符串（Query String）：</strong> URL的查询字符串部分是可选的，用于向服务器传递参数。查询字符串由问号”?”开始，后面跟着一系列用”&amp;”连接的参数键值对。例如，在”<a href="http://www.example.com/search?query=apple%22%E4%B8%AD%EF%BC%8C%22?query=apple%22%E5%B0%B1%E6%98%AF%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%A1%A8%E7%A4%BA%E6%90%9C%E7%B4%A2%E5%8F%82%E6%95%B0%22query%22%E7%9A%84%E5%80%BC%E6%98%AF%22apple">http://www.example.com/search?query=apple&quot;中，&quot;?query=apple&quot;就是查询字符串，表示搜索参数&quot;query&quot;的值是&quot;apple</a>“。</li></ol><h5 id="“Redirect”（重定向）"><a href="#“Redirect”（重定向）" class="headerlink" title="“Redirect”（重定向）"></a>“Redirect”（重定向）</h5><p>将一个请求从一个URL地址重定向到另一个URL地址的操作。</p><p>重定向通常是在应用层（Layer 7）处理的</p><p> 常见的应用场景包括：</p><ul><li>强制使用HTTPS：将HTTP请求重定向到相应的HTTPS地址，以确保通信的安全性。</li><li>域名变更：将旧域名重定向到新域名，确保用户访问的是最新的域名。</li><li>路径重定向：根据URL路径将请求重定向到不同的资源或页面上。</li><li>主机名重定向：根据URL中的主机名将请求重定向到不同的主机或子域名上。</li><li>移动设备重定向：根据用户设备类型将请求重定向到适合其设备的移动版本或桌面版本的网站。</li><li>广告跟踪重定向：通过重定向用户点击的广告，进行广告效果跟踪和转化追踪。</li></ul><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>数据信息，类型为“<strong>小型文本文件</strong>”，存储于电脑上的文本文件中。</p><p>客户端请求服务器，如果服务器需要记录该用户状态就使用response向客户端浏览器颁发一个Cookie。客户端游览器就会把Cookie保存起来。当浏览器在请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态，服务器还可以根据需要修改Cookie的内容。</p><h5 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL &#x2F; TLS"></a>SSL &#x2F; TLS</h5><p>安全套接层（Secure Sockets Layer），它是一种用于确保网络通信安全的加密协议。</p><p>SSL通常被称为传输层安全性协议（TLS，Transport Layer Security）</p><p>SSL协议旨在通过在客户端和服务器之间建立加密连接来保护敏感数据的传输。它使用公钥加密和对称加密算法来确保数据的机密性、完整性和身份验证。</p><p>SSL位于<strong>传输层和应用层</strong>之间的协议。</p><p>SSL&#x2F;TLS协议通过在传输层建立一个安全的通信通道来保护数据的安全性，以确保在应用程序之间传输的数据在传输过程中受到保护。因此，SSL&#x2F;TLS协议在传输层和应用层之间发挥了重要的作用。</p><h5 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h5><ol><li><p><strong>可用性（Availability）</strong>：指系统或应用程序持续可用的程度，通常以百分比来衡量。在AWS中，服务级别协议（SLA）是一个衡量可用性的重要指标。常见的目标是“99.99%可用性”或更高。</p></li><li><p><strong>可扩展性（Scalability）</strong>：指系统或应用程序可以在需要时进行扩展，以满足不断增长的需求。AWS提供了自动扩展功能，如Auto Scaling，可以根据负载情况自动增加或减少资源。</p></li><li><p><strong>弹性（Elasticity）</strong>：与可扩展性类似，但更强调系统可以快速适应变化，并且可以自动调整资源以满足需求。弹性系统能够根据负载情况自动调整容量。</p></li><li><p><strong>持久性（Durability）</strong>：指数据的持久性和不易丢失。AWS存储服务（如S3）提供了高持久性，确保数据不会轻易丢失。</p></li><li><p><strong>安全性（Security）</strong>：指保护系统和数据免受未经授权访问、攻击和泄漏的能力。AWS提供多种安全性功能和服务，如身份和访问管理（IAM）、虚拟专用云（VPC）等。</p></li><li><p><strong>成本效益（Cost Efficiency）</strong>：指在满足需求的同时，最大限度地降低成本。AWS提供计算、存储和其他资源的付费方式，使用户只需支付实际使用的资源。</p></li><li><p><strong>可管理性（Manageability）</strong>：指系统的易管理性和监控性能。AWS提供云监控、自动化和管理工具，以帮助用户管理和监控他们的资源。</p></li><li><p><strong>灵活性（Flexibility）</strong>：指能够选择不同的计算、存储和网络选项，以满足不同需求。AWS提供多种服务和配置选项，以适应各种应用场景。</p><pre><code>         HTML</code></pre><p> ​<br> ​<br> ​<br> ​<br> ​<br> ​</p></li></ol><p>🍋 “Decoupling applications” 是一种架构设计的概念，它指的是将应用程序的各个组件解耦，使它们之间的交互变得灵活、松散，从而提高应用程序的可伸缩性、可靠性和可维护性。​</p><h5 id="NoSQL-数据库-Not-Only-SQL"><a href="#NoSQL-数据库-Not-Only-SQL" class="headerlink" title="NoSQL 数据库-Not Only SQL"></a>NoSQL 数据库-<strong>Not Only SQL</strong></h5><p>是一类非关系型数据库，与传统的关系型数据库（SQL 数据库）相对应。</p><p><strong>NoSQL 是 “Not Only SQL” 的缩写</strong>，强调它们不仅仅是 SQL 数据库的替代品，而是一组使用不同数据模型和查询语言的数据库技术。</p><p>NoSQL 数据库的主要特点包括：</p><ol><li><strong>非关系型数据模型：</strong> NoSQL 数据库使用不同的数据模型来存储和组织数据，而不是传统的表格结构。常见的 NoSQL 数据模型包括键值对、文档、列族（列存储）和图形模型。</li><li><strong>灵活的模式：</strong> NoSQL 数据库通常没有固定的模式（schema），这意味着您可以在数据库中存储不同结构和格式的数据，而无需预先定义表结构。</li><li><strong>水平扩展性：</strong> NoSQL 数据库通常设计为可以无缝水平扩展，即通过添加更多的节点和服务器来处理大规模数据和负载，而无需单一的昂贵服务器。</li><li><strong>高性能和低延迟：</strong> NoSQL 数据库的设计目标之一是提供高吞吐量和低延迟的读写操作，使其适用于大量实时应用和高并发环境。</li><li><strong>去中心化分布式架构：</strong> 许多 NoSQL 数据库是分布式的，数据可以复制和存储在多个节点上，提高数据的可用性和容错性。</li><li><strong>CAP 定理：</strong> NoSQL 数据库通常遵循 CAP 定理原则，即在分布式系统中，无法同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition Tolerance）这三个特性，需要在这三者之间做出权衡。</li></ol><p>NoSQL 数据库适用于许多不同类型的应用场景，特别是对于需要大规模数据存储和处理的现代应用程序。由于其灵活的模式和分布式架构，NoSQL 数据库在 Web 应用程序、移动应用程序、实时分析、物联网（IoT）和大数据等领域得到广泛应用。一些著名的 NoSQL 数据库包括 MongoDB、Cassandra、DynamoDB、Couchbase 和 Redis 等。</p><h5 id="Application-Programming-Interface-API"><a href="#Application-Programming-Interface-API" class="headerlink" title="Application Programming Interface-API"></a>Application Programming Interface-API</h5><p>API可以被看作是一个桥梁，它允许开发人员使用已有的代码、服务或功能，而无需重新编写或重新创建这些内容。通过API，开发人员可以访问和操作其他软件组件的功能，就像使用构建块一样，从而加快开发过程并提高代码的可重用性。</p><p>API可以有不同的形式，包括：</p><ul><li><strong>Web API：</strong> 基于HTTP协议的API，通常通过URL进行访问，返回数据以JSON或XML等格式。</li><li><strong>库（Library）API：</strong> 提供编程语言特定的函数和方法，以供开发人员在自己的代码中使用。</li><li><strong>操作系统API：</strong> 允许应用程序与操作系统进行交互，访问底层功能。</li><li><strong>硬件API：</strong> 允许软件与硬件设备进行交互，如打印机、摄像头等。</li></ul><h5 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h5><p>是一个开源的关系型数据库管理系统（RDBMS），它提供了高度可靠性、可扩展性和丰富的功能集。以下是一些关于PostgreSQL的重要信息：</p><ol><li><strong>关系型数据库管理系统（RDBMS）：</strong> PostgreSQL是一种关系型数据库，它使用表格来存储数据，并支持SQL（Structured Query Language）查询语言。</li><li><strong>开源：</strong> PostgreSQL是一个开源项目，这意味着它的源代码是公开的并且可以被任何人查看、使用和修改。</li><li><strong>高度可靠性：</strong> PostgreSQL被设计为具有高度可靠性和稳定性。它支持事务、ACID（原子性、一致性、隔离性、持久性）属性，确保数据的完整性和可靠性。</li><li><strong>可扩展性：</strong> PostgreSQL具有良好的可扩展性，它可以处理大量的数据和高并发访问。通过分区、复制、集群等方式，可以将系统的性能和容量扩展到更高的水平。</li><li><strong>丰富的功能：</strong> PostgreSQL提供了丰富的功能集，包括复杂的数据类型、外键约束、触发器、视图、存储过程、全文搜索、地理空间支持等。它也支持JSON和其他非结构化数据类型。</li><li><strong>扩展性：</strong> PostgreSQL支持扩展，允许用户添加自定义的扩展模块来增加数据库功能。</li><li><strong>多种操作系统支持：</strong> PostgreSQL可以在多种操作系统上运行，包括Linux、Windows、macOS等。</li><li><strong>社区支持：</strong> PostgreSQL拥有一个活跃的全球社区，提供支持、文档、教程和插件，帮助用户更好地使用和管理数据库。</li><li><strong>安全性：</strong> PostgreSQL提供了强大的安全功能，包括用户认证、访问控制、数据加密等，以保护数据库中的敏感信息。</li></ol><p>总之，PostgreSQL是一个功能强大且可靠的开源关系型数据库管理系统，适用于各种规模的应用程序和项目。它在企业和开发者社区中都享有广泛的使用和认可。</p><pre><code>            HTML</code></pre><p>​<br>​<br>​<br>​<br>​<br>​<br>➡️ unicast IP-每个设备有唯一的IP地址，数据包从源设备直接传输到目标设备。​</p><pre><code>            HTML</code></pre><p>​<br>​<br>​<br>​<br>​<br>​<br>🐳 anycast IP-多个设备共享相同IP地址，数据包将传输到最近的设备​</p><h5 id="OLTP"><a href="#OLTP" class="headerlink" title="OLTP"></a>OLTP</h5><p><strong>Online Transaction Processing”（在线事务处理）</strong></p><p>它是一种数据库处理方式，用于处理实时交易和事务。OLTP系统旨在支持并发的数据库操作，通常用于处理大量短期和频繁的交易请求，例如在线购买、银行交易、航班预订等。</p><p>OLTP系统通常具有以下特点：</p><ul><li>快速的读写操作：用于处理实时交易，需要快速响应和处理数据库记录的插入、更新和查询操作。</li><li>事务支持：OLTP系统必须支持ACID属性（原子性、一致性、隔离性和持久性），确保数据库的完整性和一致性。</li><li>高并发性：OLTP系统通常面对许多用户同时进行交易，需要能够处理高并发的请求。</li><li>精细的数据模型：OLTP系统的数据模型通常是规范化的，以减少数据冗余并提高查询性能。</li><li>实时数据访问：OLTP系统提供实时数据访问，允许用户即时获取最新的交易信息。</li></ul><h5 id="适用于OLTP的AWS服务："><a href="#适用于OLTP的AWS服务：" class="headerlink" title="适用于OLTP的AWS服务："></a>适用于OLTP的AWS服务：</h5><ol><li><strong>Amazon RDS</strong>（Relational Database Service）：支持多种关系型数据库引擎，适用于在线交易处理和实时事务。</li><li><strong>Amazon Aurora</strong>：是RDS的一个变种，专为OLTP工作负载而设计，具有高性能和高可用性。</li><li><strong>Amazon DynamoDB</strong>：全托管的NoSQL数据库，适用于高度可扩展的实时交易处理和高并发操作。</li><li><strong>Amazon ElastiCache</strong>：提供托管的内存缓存服务，加速读取操作，适用于缓存频繁读取的交易数据。</li></ol><h5 id="OLAP"><a href="#OLAP" class="headerlink" title="OLAP"></a>OLAP</h5><p><strong>“Online Analytical Processing”（在线分析处理）</strong></p><p>它是一种数据库处理方式，用于支持复杂的数据分析和查询。OLAP系统旨在帮助用户从大量数据中获取洞察力和业务智能，进行决策支持和战略规划。</p><p>OLAP系统具有以下特点：</p><ol><li>多维数据模型：OLAP系统使用多维数据模型，通常称为立方体（cube），将数据组织成多个维度和度量，方便进行多维度的数据分析。</li><li>高性能查询：OLAP系统优化了查询性能，能够快速处理复杂的数据查询，包括聚合、切片、切块、钻取等操作。</li><li>聚合功能：OLAP系统支持对数据进行聚合计算，能够快速计算汇总数据，例如总和、平均值、最大值、最小值等。</li><li>决策支持：OLAP系统帮助用户发现数据中的模式和趋势，用于决策支持和业务智能。</li><li>历史数据：OLAP系统通常存储历史数据，可以进行时间序列分析和回顾性分析。</li></ol><p>OLAP系统通常用于商业智能（BI）应用程序，帮助企业管理层和决策者从大量数据中获取洞察力，了解业务情况，并做出基于数据的决策。与OLAP相对的是OLTP（Online Transaction Processing），后者用于处理实时交易和事务。两者分别优化了不同类型的数据库处理，以满足不同的应用场景和需求。</p><h5 id="适用于OLAP的AWS服务："><a href="#适用于OLAP的AWS服务：" class="headerlink" title="适用于OLAP的AWS服务："></a>适用于OLAP的AWS服务：</h5><ol><li>Amazon Redshift：完全托管的数据仓库服务，专为大规模数据分析和查询而设计，适用于复杂的多维度分析。</li><li>Amazon Athena：用于查询存储在S3中的大规模数据集的无服务器查询服务，适用于交互式数据分析。</li><li>Amazon EMR（Elastic MapReduce）：大数据处理服务，用于在分布式环境中进行复杂的数据分析和计算。</li><li>Amazon Quicksight：商业智能工具，用于可视化和分析数据，适用于OLAP数据的交互式分析和报表制作。</li></ol><h5 id="DNS-域名解析系统：域名解析为IPudp53"><a href="#DNS-域名解析系统：域名解析为IPudp53" class="headerlink" title="DNS 域名解析系统：域名解析为IPudp53"></a>DNS 域名解析系统：域名解析为IP<code>udp53</code></h5><p>Domain Name System，将域名解析为IP地址</p><p>UDP 53</p><table><thead><tr><th>A</th><th>域名解析为IP地址</th></tr></thead><tbody><tr><td>PTR</td><td>解析IP地址到主机名   反向查询</td></tr><tr><td>CNAME</td><td>允许多名称对应同一主机</td></tr><tr><td>MX</td><td>指定邮件服务器优先级</td></tr><tr><td>NS</td><td>指明域名由哪一台服务器来解析</td></tr></tbody></table><ul><li><p><strong>DNS命名</strong></p><p>主机…+三级域名+二级域名+顶级域名</p><p>主机名：www,ftp,mail</p><p>域名：com,cn,edu</p></li></ul><p>客户端进行DNS查询步骤</p><p>DNS缓存——（找不到）——host文件 or  DNS服务器</p><p>没有得到解析结果，则使用NETBIOS名字解析</p><p>DNS术语解释</p><ul><li><strong>域名注册商</strong>：Amazon Route 53、GoDaddy等公司。</li><li><strong>DNS记录</strong>：A记录、AAAA记录、CNAME记录、NS记录等。</li><li><strong>区域文件</strong>：包含DNS记录的文件。</li><li><strong>root domain</strong></li><li><strong>顶级域名（TLD）</strong></li><li><strong>二级域名（SLD</strong></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 云原生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
