<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>docker | The Fountainhead</title><meta name="author" content="niki,zn40489@gmail.com"><meta name="copyright" content="niki"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#BBEC6C"><meta name="description" content="docker 一：Docker基础、什么是Docker？Docker是什么？开源的容器化平台，用于构建、打包和运行应用程序和服务 架构：client-server Docker的优势和用途 轻量级容器： Docker容器相对于传统虚拟机更轻量，因为它们共享操作系统内核，而不是运行完整的操作系统。这使得容器更快速启动、更节省资源，并提高了可扩展性。  一致性和可移植性： Docker容器封装了应用程">
<meta property="og:type" content="article">
<meta property="og:title" content="docker">
<meta property="og:url" content="https://sosocrown.github.io/2023/10/20/docker/index.html">
<meta property="og:site_name" content="The Fountainhead">
<meta property="og:description" content="docker 一：Docker基础、什么是Docker？Docker是什么？开源的容器化平台，用于构建、打包和运行应用程序和服务 架构：client-server Docker的优势和用途 轻量级容器： Docker容器相对于传统虚拟机更轻量，因为它们共享操作系统内核，而不是运行完整的操作系统。这使得容器更快速启动、更节省资源，并提高了可扩展性。  一致性和可移植性： Docker容器封装了应用程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sosocrown.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2023-10-20T06:47:12.000Z">
<meta property="article:modified_time" content="2025-02-12T07:11:01.127Z">
<meta property="article:author" content="niki">
<meta property="article:tag" content="容器">
<meta property="article:tag" content="运维">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sosocrown.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "docker",
  "url": "https://sosocrown.github.io/2023/10/20/docker/",
  "image": "https://sosocrown.github.io/img/butterfly-icon.png",
  "datePublished": "2023-10-20T06:47:12.000Z",
  "dateModified": "2025-02-12T07:11:01.127Z",
  "author": [
    {
      "@type": "Person",
      "name": "niki",
      "url": "https://sosocrown.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sosocrown.github.io/2023/10/20/docker/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#2E3B30')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#BBEC6C')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'docker',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/mycss.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-color: #efefef;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">The Fountainhead</span></a><a class="nav-page-title" href="/"><span class="site-name">docker</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">docker</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-20T06:47:12.000Z" title="发表于 2023-10-20 14:47:12">2023-10-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-12T07:11:01.127Z" title="更新于 2025-02-12 15:11:01">2025-02-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p><img src="/(/images/U1" alt="Untitled"></p>
<h2 id="一：Docker基础、"><a href="#一：Docker基础、" class="headerlink" title="一：Docker基础、"></a>一：Docker基础、</h2><h3 id="什么是Docker？"><a href="#什么是Docker？" class="headerlink" title="什么是Docker？"></a>什么是Docker？</h3><h3 id="Docker是什么？"><a href="#Docker是什么？" class="headerlink" title="Docker是什么？"></a><strong>Docker是什么？</strong></h3><p><strong>开源的容器化平台，用于构建、打包和运行应用程序和服务</strong></p>
<h3 id="架构：client-server"><a href="#架构：client-server" class="headerlink" title="架构：client-server"></a>架构：<strong>client-server</strong></h3><p><img src="/(/images/U2" alt="Untitled"></p>
<h3 id="Docker的优势和用途"><a href="#Docker的优势和用途" class="headerlink" title="Docker的优势和用途"></a>Docker的优势和用途</h3><ol>
<li><p><strong>轻量级容器：</strong> Docker容器相对于传统虚拟机更轻量，因为它们共享操作系统内核，而不是运行完整的操作系统。这使得容器更快速启动、更节省资源，并提高了可扩展性。</p>
</li>
<li><p><strong>一致性和可移植性：</strong> Docker容器封装了应用程序及其依赖，确保在不同环境中运行一致。这意味着你可以在开发、测试和生产环境之间轻松迁移应用程序。</p>
</li>
<li><p><strong>快速部署：</strong> Docker容器可以迅速启动和停止，因此可以更快速地部署和更新应用程序，有助于实现持续集成和持续交付（CI&#x2F;CD）。</p>
</li>
<li><p><strong>隔离性：</strong> Docker提供了强大的容器隔离，确保容器内的应用程序不会相互干扰，并提供了一定程度的安全性。</p>
</li>
<li><p><strong>生态系统和社区支持：</strong> Docker拥有广泛的生态系统和强大的社区支持，有大量的官方和第三方容器镜像，以及丰富的工具和插件，使得它更容易集成到不同的应用和基础架构中。</p>
</li>
</ol>
<p>​</p>
<p>📌 用途</p>
<p>​</p>


<ol start="6">
<li><p><strong>微服务架构：</strong> Docker容器可用于构建和管理微服务，使每个微服务都运行在独立的容器中，有助于系统的模块化和可伸缩性。</p>
</li>
<li><p><strong>持续集成和持续交付（CI&#x2F;CD）：</strong> Docker容器在CI&#x2F;CD流程中扮演重要角色，帮助自动化构建、测试和部署过程，提高交付速度和可靠性。</p>
</li>
<li><p><strong>多云环境部署：</strong> Docker容器的可移植性使得在不同云服务提供商之间迁移应用程序变得更加容易，同时也有助于混合云和多云战略的实施。</p>
</li>
<li><p><strong>资源隔离和多租户环境：</strong> Docker容器可用于隔离不同租户或应用程序，确保资源分配和安全性。</p>
</li>
</ol>
<h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>​</p>
<p>📌 Linux基础</p>
<p>​</p>


<p>​</p>
<p>📌 CentOS 7</p>
<p>​</p>
<p>基于开源 Linux 发行版 Red Hat Enterprise Linux (RHEL) 的免费、企业级操作系统。它采用了稳定性和可靠性为主要目标，适用于服务器环境和企业级应用程序。</p>


<p>​</p>
<p>📌 Xshell连接远程服务器进行操作</p>
<p>​</p>


<ol start="10">
<li>环境查看：</li>
</ol>
<p>#系统内核<br> [root@iZ2vcet9lnxw7ajh08wb59Z ~]# uname -r<br> 4.18.0-305.3.1.el8.x86_64</p>
<p>#系统版本<br> <br> [root@iZ2vcet9lnxw7ajh08wb59Z ~]# cat &#x2F;etc&#x2F;os-release<br> NAME&#x3D;”CentOS Linux”<br> VERSION&#x3D;”8”<br> ID&#x3D;”centos”<br> ID_LIKE&#x3D;”rhel fedora”<br> VERSION_ID&#x3D;”8”<br> PLATFORM_ID&#x3D;”platform:el8”<br> PRETTY_NAME&#x3D;”CentOS Linux 8”<br> ANSI_COLOR&#x3D;”0;31”<br> CPE_NAME&#x3D;”cpe:&#x2F;o:centos:centos:8”<br> HOME_URL&#x3D;”<a target="_blank" rel="noopener" href="https://centos.org/">https://centos.org/</a>“<br> BUG_REPORT_URL&#x3D;”<a target="_blank" rel="noopener" href="https://bugs.centos.org/">https://bugs.centos.org/</a>“<br> CENTOS_MANTISBT_PROJECT&#x3D;”CentOS-8”<br> CENTOS_MANTISBT_PROJECT_VERSION&#x3D;”8”  
 </p>
<ol start="11">
<li>安装</li>
</ol>
<p> # 1、卸载旧的版本<br> sudo yum remove docker \<br>                   docker-client \<br>                   docker-client-latest \<br>                   docker-common \<br>                   docker-latest \<br>                   docker-latest-logrotate \<br>                   docker-logrotate \<br>                   docker-engine<br>​<br> # 2、需要的安装包<br> sudo yum install -y yum-utils<br> <br> # 3、设置镜像的仓库<br> yum-config-manager –add-repo <a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a><br> <br> # 更新yum软件包索引<br> yum makecache fast<br> <br> # 4、安装docker相关的源 docker-ce 社区 ee 企业版<br> yum install docker-ce docker-ce-cli containerd.io<br> <br> # 5、启动docker<br> systemctl start docker<br> <br> # 6、使用docker version 查看是否安装成功<br> <br> # 7、docker run hello-world<br> <br> # 8、查看下载的这个 hello-world 镜像  
 </p>
<h3 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h3><p>​</p>
<p>🪞 image-镜像</p>
<p>​</p>


<p>Docker 镜像是容器的模板</p>
<p>它包含了运行容器所需的文件系统、库和配置等。</p>
<p>tomat镜像—–&gt;run—–&gt;Tomcat01 容器（提供服务器）</p>
<p>​</p>
<p>🧂 container-容器</p>
<p>​</p>


<p>Docker 容器是基于 Docker 镜像创建的运行<strong>实例</strong></p>
<ul>
<li>容器可以看做简易的Linux系统</li>
</ul>
<p>​</p>
<p>🈁 repository-仓库</p>
<p>​</p>


<p>存放镜像的地方</p>
<p>分为公有仓库和私有仓库</p>
<h3 id="镜像（Images）和容器（Containers）的区别"><a href="#镜像（Images）和容器（Containers）的区别" class="headerlink" title="镜像（Images）和容器（Containers）的区别"></a>镜像（Images）和容器（Containers）的区别</h3><p>镜像（Images）和容器（Containers）是Docker中两个关键的概念，它们在Docker生态系统中有不同的角色和用途。以下是镜像和容器之间的主要区别：</p>
<p><strong>1. 定义和用途：</strong></p>
<ul>
<li><p><strong>镜像（Images）：</strong> 镜像是一个只读的文件，其中包含了应用程序、运行时环境、系统工具和库等的静态快照。镜像可以看作是应用程序的构建模块，它包含了所有启动容器所需的文件系统和配置信息。镜像通常用于创建容器。</p>
</li>
<li><p><strong>容器（Containers）：</strong> 容器是基于镜像运行的实例。它是镜像的一个运行时环境，包括正在运行的应用程序和其依赖的进程。容器是可读写的，并且可以与主机系统和其他容器进行交互。容器是实际运行和执行应用程序的实体。</p>
</li>
</ul>
<p><strong>2. 可变性：</strong></p>
<ul>
<li><p><strong>镜像（Images）：</strong> 镜像是不可变的，一旦创建，其内容不会改变。如果需要对应用程序进行更新或修改，通常需要创建一个新的镜像。</p>
</li>
<li><p><strong>容器（Containers）：</strong> 容器是可变的，可以在容器内部运行应用程序，进行文件操作、修改配置等。容器的状态可以随着应用程序的运行而改变。</p>
</li>
</ul>
<p><strong>3. 生命周期：</strong></p>
<ul>
<li><p><strong>镜像（Images）：</strong> 镜像的生命周期是静态的，它存在于Docker主机上，可以被多个容器实例引用。镜像通常是持久的，直到手动删除。</p>
</li>
<li><p><strong>容器（Containers）：</strong> 容器的生命周期是动态的，它可以被创建、启动、停止和删除。容器是短暂的，存在于需要运行应用程序的时候，然后可以被销毁。</p>
</li>
</ul>
<p><strong>4.资源消耗：</strong></p>
<ul>
<li><p><strong>镜像（Images）：</strong> 镜像通常占用较大的磁盘空间，因为它包含了应用程序的完整静态快照。</p>
</li>
<li><p><strong>容器（Containers）：</strong> 容器通常比镜像占用更少的磁盘空间，因为容器只包含运行应用程序所需的可写层，并且可以共享底层镜像的内容。</p>
</li>
</ul>
<p>总之，镜像是Docker中的静态构建块，用于创建容器的基础，而容器是运行时实体，代表一个应用程序的运行实例。理解镜像和容器之间的区别对于有效使用Docker和容器化应用程序非常重要。容器化技术使得应用程序更容易管理、部署和扩展。</p>
<p>DockerFile : 构建文件，定义了一切的步骤，源代码</p>
<p>DockerImages ： 通过DokerFile构建生成的镜像，是最终发布和运行的产品</p>
<p>Docker容器：容器就是镜像运行起来提供服务器</p>
<p><img src="/(/images/U3" alt="Untitled"></p>
<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a><strong>镜像命令</strong></h3><ul>
<li><p>查看所有本地主机上的镜像：<code>docker images</code></p>
<blockquote>
<p>REPOSITORY：镜像的仓库源TAG：镜像的标签IMAGE ID：镜像的IDCREATED：镜像的创建时间</p>
</blockquote>
</li>
<li><p>搜索镜像：<code>docker search 镜像名</code></p>
<blockquote>
<p>–filter, -f：根据提供的条件筛选输出</p>
</blockquote>
</li>
<li><p>下载镜像：<code>docker pull 镜像名[:tag]</code></p>
<blockquote>
<p>docker pull mysql:5.7</p>
</blockquote>
</li>
<li><p>删除镜像：<code>docker rmi</code></p>
<ul>
<li><p>删除指定的容器：<code>docker rmi -f 容器id</code></p>
</li>
<li><p>删除多个容器：<code>docker rmi -f 容器id1 容器id2 ...</code></p>
</li>
<li><p>删除全部容器：<code>docker rmi -f $(docker images -aq)</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a><strong>容器命令</strong></h3><ul>
<li><p><strong>新建容器并启动：</strong><code>docker run 镜像名</code></p>
<table>
<thead>
<tr>
<th>可选参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-p</td>
<td>设置端口映射，宿主机端口:容器端口</td>
</tr>
<tr>
<td>-P</td>
<td>随机分配端口</td>
</tr>
<tr>
<td>-i</td>
<td>前台交互式启动，通常与 -t 配合使用</td>
</tr>
<tr>
<td>-t</td>
<td>启动容器内的伪终端，通常与 -i 配合使用</td>
</tr>
<tr>
<td>-d</td>
<td>后台守护式启动</td>
</tr>
<tr>
<td>–name</td>
<td>为容器命名</td>
</tr>
</tbody></table>
<blockquote>
<p>-可选参数：</p>
<ul>
<li><p>name&#x3D;”Name”：容器名字，用于区分容器</p>
</li>
<li><p>d：后台方式运行</p>
</li>
<li><p>it：使用交互方式运行</p>
</li>
<li><p>p：指定容器的端口映射&lt;主机端口&gt;:&lt;容器内部端口&gt;</p>
</li>
<li><p>v：挂载数据卷</p>
</li>
</ul>
</blockquote>
<hr>
<p>  注意 -d后台方式运行<br>  docker run -d centos<br>  ​<br>  #但docker ps后发现 centos 停止了<br>  ​  </p>
<h1 id="docker容器使用后台运行，就必须要有一个前台进程，"><a href="#docker容器使用后台运行，就必须要有一个前台进程，" class="headerlink" title="docker容器使用后台运行，就必须要有一个前台进程，"></a>docker容器使用后台运行，就必须要有一个前台进程，</h1><p>  docker发现没有应用，就会自动停止<br>  nginx,容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</p>
<hr>
</li>
<li><p><strong>列出所有运行中的容器：<code>docker ps</code></strong></p>
<blockquote>
<p>可选项：</p>
<ul>
<li><p>a：列出所有容器（包括历史运行过的）</p>
</li>
<li><p>n&#x3D;?：显示最近创建的容器</p>
</li>
<li><p>q：只显示容器的编号</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>进入一个正在运行的Docker容器:<code>docker exec</code></p>
</li>
<li><p><strong>docker exec -it &lt;容器名称或容器ID&gt; &lt;shell命令&gt;</strong></p>
<blockquote>
<p>-it：这是两个选项的组合，</p>
<p><code>-i</code>表示交互式</p>
<p><code>-t</code>表示分配一个终端（TTY）。这允许您与容器进行交互，就像您在本地计算机上使用终端一样。</p>
<p><code>&lt;shell命令&gt;</code>：这是您要在容器内执行的shell命令。通常，您可以使用<code>/bin/bash</code>或<code>/bin/sh</code>来启动一个shell会话。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>退出容器：exit</strong></p>
<blockquote>
<p>直接容器停止并退出：exit</p>
<p>容器不停止退出：<code>Ctrl + P + Q</code></p>
</blockquote>
</li>
<li><p>**删除容器：**docker rm 容器id</p>
<blockquote>
<p>删除指定容器：docker rm 容器id</p>
<p>删除所有容器：<code>docker rm -f $(docker ps -aq)</code> 或 <code>docker ps -aq | xargs docker rm</code></p>
</blockquote>
</li>
<li><p><strong>启动、重启和停止容器：</strong></p>
<blockquote>
<p>启动容器：docker start 容器id</p>
<p>重启容器：<code>docker restart 容器id</code></p>
<p>停止容器：<code>docker stop 容器id</code></p>
<p>强制停止容器：<code>docker kill 容器id</code></p>
</blockquote>
</li>
</ul>
<h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a><strong>其他常用命令</strong></h3><ul>
<li><p>后台启动容器：<code>docker run -d 镜像名</code></p>
</li>
<li><p>查看容器日志：<code>docker logs -f -t --tail 容器id</code></p>
</li>
<li><p>查看容器中的进程信息：<code>docker top 容器id</code></p>
</li>
<li><p>查看容器源数据：<code>docker inspect 容器id</code></p>
</li>
<li><p>进入当前正在运行的容器：<code>docker exec -it 容器id 命令</code></p>
</li>
<li><p><code>docker run</code>：运行容器</p>
</li>
<li><p><code>docker pull</code>：拉取镜像</p>
</li>
<li><p><code>docker ps</code>：查看运行中的容器</p>
</li>
<li><p><code>docker images</code>：查看镜像列表</p>
</li>
<li><p><code>docker stop</code> 和 <code>docker rm</code>：停止和删除容器</p>
</li>
</ul>
<h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a><strong>帮助命令</strong></h3><ul>
<li><p>显示Docker版本信息：<code>docker version</code></p>
</li>
<li><p>显示Docker系统信息，包括镜像和容器的数量：<code>docker info</code></p>
</li>
<li><p>获取Docker命令的帮助：<code>docker 命令 --help</code></p>
</li>
<li><p>帮助文档地址：<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/">Docker官方文档</a></p>
</li>
<li><p>重启docker服务<code>systemctl restart docker</code></p>
</li>
</ul>
<h1 id="dickerfile-创建自定义镜像"><a href="#dickerfile-创建自定义镜像" class="headerlink" title="dickerfile-创建自定义镜像"></a>dickerfile-创建自定义镜像</h1><p><strong>Docker image由只读层组成，每个层代表一条 Dockerfile 指令。这些层是堆叠在一起的，每一层都是与前一层的变化的增量</strong></p>
<p><strong>dockerfile—&gt;文本文件</strong>，用于定义Docker镜像的构建过程。它包含一系列的指令和参数，这些指令告诉Docker引擎如何从一个基础镜像构建一个新的镜像，包括如何添加应用程序代码、依赖项、配置文件等。</p>
<ul>
<li><input disabled type="checkbox"> <strong>注意事项</strong><ul>
<li><input disabled type="checkbox"> 保留关键字都必须大写！</li>
<li><input disabled type="checkbox"> 执行顺序：从上到下</li>
<li><input disabled type="checkbox"> 每个指令都创建提交一个新的镜像层</li>
<li><input disabled type="checkbox"> dockerfile是面向开发的</li>
</ul>
</li>
</ul>
<h3 id="dockerfile的指令"><a href="#dockerfile的指令" class="headerlink" title="dockerfile的指令"></a>dockerfile的指令</h3><p><strong>FROM</strong>         #指定基础镜像<br><strong>MAINTAINER</strong>   #指定维护者信息：姓名+邮箱<br><strong>RUN         #每执行一条RUN命令,镜像添加新的一层.  <br>ADD</strong>          #将文件或目录复制到容器中，自动解压<br><strong>WORKDIR</strong>      #工作目录，类似于 cd 命令，即切换目录<br>通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、 COPY等命令都会在该目录下执行。<br> <br>​<br><strong>VOLUNME</strong>      #创建一个挂载点，<br><strong>EXPOSE</strong>       #指定容器监听的端口<br>ENV # 构建的时候设置环境变量！<br>VOLUME [“volume01”,”volume02”]   # 定义一个挂载点,用于持久化数据</p>
<p><strong>CMD :设置容器启动后默认执行的命令和参数ENTRYPOINT :设置容器启动时运行的命令</strong></p>
<p>ADD带有自动解压功能 COPY没有自动解压功能</p>
<p>构建镜像</p>
<h1 id="命令-docker-build-f-文件路径-t-镜像名-tag"><a href="#命令-docker-build-f-文件路径-t-镜像名-tag" class="headerlink" title="命令 docker build -f 文件路径 -t 镜像名:[tag]"></a>命令 docker build -f 文件路径 -t 镜像名:[tag]</h1><p><code>docker buildx build -t nikicentos:1.0 -f mydockerfile</code> <em>#用于构建一个名为 nikicentos，标签为 1.0 的 Docker 镜像 #使用名为 mydockerfile 的 Dockerfile，并且<strong>构建上下文路径是当前目录（.）</strong>。</em></p>
<h3 id="docker-history"><a href="#docker-history" class="headerlink" title="docker history &lt;镜像ID或名称&gt;-"></a><code>docker history &lt;镜像ID或名称&gt;</code>-</h3><p><strong>查看 Docker 镜像的构建历史</strong></p>
<p><code>CMD</code><em>指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。</em></p>
<p><code>ENTRYPOINT</code> <em>指定这个容器启动的时候要运行的命令，可以追加命令</em></p>
<ul>
<li><p>如果你只关心容器的默认命令，使用 <strong><code>CMD</code></strong> 即可。</p>
</li>
<li><p>如果你希望容器的默认命令可以接受参数，使用 <strong><code>ENTRYPOINT</code></strong>。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.notion.so/test-centOS-e15001a2ff8944258855e5d810b7cd16?pvs=21">test-构建自己的centOS</a></p>
<p><a target="_blank" rel="noopener" href="https://www.notion.so/test2-Tomcat-dfabe04415fa4501934d91f827a00469?pvs=21">test2-Tomcat镜像</a></p>
<h3 id="1-容器数据卷（Container-Volumes）："><a href="#1-容器数据卷（Container-Volumes）：" class="headerlink" title="1. 容器数据卷（Container Volumes）："></a><strong>1. 容器数据卷（Container Volumes）：</strong></h3><h3 id="容器之间共享和持久化数据的机制"><a href="#容器之间共享和持久化数据的机制" class="headerlink" title="容器之间共享和持久化数据的机制"></a>容器之间共享和持久化数据的机制</h3><ul>
<li><p>容器数据卷是Docker容器内部的目录或文件，它们映射到宿主机的文件系统目录，或者可以共享给其他容器使用。</p>
</li>
<li><p>容器数据卷可以包含应用程序数据、配置文件、日志文件等。这些数据卷可以在容器之间传递信息，以及在容器的生命周期内保持数据的一致性。</p>
</li>
<li><p>创建容器数据卷的方法包括在容器启动命令中使用<code>v</code>或<code>-volume</code>选项，或在Docker Compose文件中定义<code>volumes</code>部分。</p>
</li>
<li><p>示例：创建一个容器并将它的<code>/data</code>目录映射到宿主机的<code>/var/data</code>目录，以实现数据持久化和共享。</p>
<p>  docker run -v &#x2F;var&#x2F;data:&#x2F;data my-container<br>  ​</p>
</li>
</ul>
<h3 id="具名挂载-匿名挂载"><a href="#具名挂载-匿名挂载" class="headerlink" title="具名挂载 &amp; 匿名挂载"></a>具名挂载 &amp; 匿名挂载</h3><p>在Docker中，有两种主要的数据卷挂载方式：具名挂载（named volumes）和匿名挂载（anonymous volumes）。这些挂载方式允许容器与主机之间共享数据，但它们在用法和管理上有一些区别。</p>
<p><strong>1. 具名挂载（Named Volumes）：</strong></p>
<ul>
<li><p>具名挂载是通过为数据卷指定名称来创建的。</p>
</li>
<li><p>这些数据卷的名称对用户可见，可以随时引用和管理。</p>
</li>
<li><p>具名挂载通常用于保存应用程序的数据，例如数据库数据、配置文件等。</p>
</li>
<li><p>创建具名挂载可以使用<code>docker volume create</code>命令，或者在容器运行时通过<code>v</code>标志来指定。</p>
</li>
<li><p>例子：<code>docker run -v mydata:/app/data myapp</code>，其中<code>mydata</code>是具名挂载的名称。</p>
</li>
</ul>
<p><strong>2. 匿名挂载（Anonymous Volumes）：</strong></p>
<ul>
<li><p>匿名挂载是未命名的，不需要为其指定名称。</p>
</li>
<li><p>这些数据卷的名称由Docker自动生成，用户通常不需要直接操作它们。</p>
</li>
<li><p>匿名挂载通常用于容器内部的临时数据，例如日志文件或运行时状态。</p>
</li>
<li><p>匿名挂载通常在容器运行时通过<code>v</code>标志来创建，但不指定具体的卷名称。</p>
</li>
<li><p>例子：<code>docker run -v /app/data myapp</code>，其中<code>/app/data</code>是匿名挂载。</p>
</li>
</ul>
<p>无论使用具名挂载还是匿名挂载，数据卷都允许容器之间或容器与主机之间共享数据，并且在容器之间启动、停止和删除时，数据都会得到保留。这使得容器可以更灵活地管理和存储数据，而不受容器生命周期的限制。</p>
<p> # 匿名挂载<br> -v 容器内路径!<br> docker run -d -P –name nginx01 -v &#x2F;etc&#x2F;nginx nginx<br> <br> # 查看所有的volume的情况<br> ➜  ~ docker volume ls<br> DRIVER              VOLUME NAME<br> local               33ae588fae6d34f511a769948f0d3d123c9d45c442ac7728cb85599c2657e50d<br> local<br> # 这里发现，这种就是匿名挂载，我们在 -v只写了容器内的路径，没有写容器外的路劲！<br> <br> # 具名挂载<br> ➜  ~ docker run -d -P –name nginx02 -v juming-nginx:&#x2F;etc&#x2F;nginx nginx<br> ➜  ~ docker volume ls<br> DRIVER              VOLUME NAME<br> local               juming-nginx<br> <br> # 通过 -v 卷名：容器内路径<br> # 查看一下这个卷  
 </p>
<h3 id="2-数据卷容器（Data-Volume-Containers）："><a href="#2-数据卷容器（Data-Volume-Containers）：" class="headerlink" title="2. 数据卷容器（Data Volume Containers）："></a><strong>2. 数据卷容器（Data Volume Containers）：</strong></h3><h3 id="管理和存储数据卷的特殊容器"><a href="#管理和存储数据卷的特殊容器" class="headerlink" title="管理和存储数据卷的特殊容器"></a>管理和存储数据卷的特殊容器</h3><ul>
<li><p>数据卷容器是一种特殊类型的<strong>Docker容器</strong>，其主要目的是提供数据卷的存储和管理。它不运行应用程序，而只包含数据卷。</p>
</li>
<li><p>你可以创建一个数据卷容器，然后在其他容器中使用<code>-volumes-from</code>选项来共享这个数据卷容器的数据卷。</p>
</li>
<li><p>数据卷容器可以用于集中管理多个容器之间共享的数据，使得备份、恢复和数据共享更加方便。</p>
</li>
<li><p>示例：创建一个数据卷容器，然后在另一个容器中使用它的数据卷。</p>
<p>  docker create -v &#x2F;data –name my-data-container my-data-image<br>  docker run –volumes-from my-data-container my-app-container<br>  ​</p>
</li>
</ul>
<h3 id="docker-网络"><a href="#docker-网络" class="headerlink" title="docker 网络"></a>docker 网络</h3><h3 id="Docker网络是Docker容器之间通信的一种方式。"><a href="#Docker网络是Docker容器之间通信的一种方式。" class="headerlink" title="Docker网络是Docker容器之间通信的一种方式。"></a>Docker网络是Docker容器之间通信的一种方式。</h3><p><img src="/(/images/U4" alt="Untitled"></p>
<ol start="12">
<li><p><strong>lo (回环接口)</strong>:</p>
<ul>
<li>IP地址：<code>127.0.0.1/8</code> -</li>
</ul>
</li>
<li><p><strong>eth0(阿里云内网地址）</strong></p>
<ul>
<li>IP地址：<code>172.23.91.165/20</code></li>
</ul>
</li>
<li><p><strong>docker0</strong>:</p>
<ul>
<li><p>用于在同一主机上的Docker容器之间进行通信。</p>
</li>
<li><p>IP地址：<code>172.17.0.1/16</code></p>
</li>
</ul>
<h3 id="veth-pair"><a href="#veth-pair" class="headerlink" title="veth-pair"></a>veth-pair</h3><p><code>veth</code> 是 Linux 中的虚拟以太网设备。它通常以对成对出现，每对之间存在一个虚拟的连接。这种连接一端被连接到宿主机的网络命名空间中，另一端被连接到一个容器的网络命名空间中。</p>
<p>具体来说：</p>
<ul>
<li><p>一端的 <code>veth</code> 设备（通常以 <code>vethXXXXXX</code> 的形式命名）会被放置在宿主机的网络命名空间中。</p>
</li>
<li><p>另一端会被分配给容器，并以另一个名称（通常是 <code>ethX</code>）存在于容器的网络命名空间中。</p>
</li>
</ul>
<p>这两端的 <code>veth</code> 设备相互连接，形成一个虚拟的以太网链路。这样，宿主机和容器就可以通过这个虚拟链路进行通信。</p>
</li>
</ol>
<p>Docker提供了多种网络模式，可以根据需要选择适合的网络配置。以下是一些常用的Docker网络概念和操作：</p>
<ol start="15">
<li><p><strong>默认网络（bridge）</strong>:</p>
<ul>
<li><p>这是Docker的默认网络模式。在这种模式下，Docker容器可以相互通信，但通常不能直接从主机外部访问。默认情况下，容器会通过NAT方式连接到宿主机的网络。</p>
</li>
<li><p>创建一个容器并且默认会连接到这个网络：</p>
</li>
</ul>
<p>docker run -d –name my_container nginx<br>​</p>
<ul>
<li>默认网络的子网和网关可以通过以下命令查看：</li>
</ul>
<p>docker network inspect bridge<br>​</p>
</li>
<li><p><strong>主机网络（host）</strong>:</p>
<ul>
<li><p>使用主机网络模式，容器将直接共享主机的网络命名空间，这意味着容器将可以使用宿主机的网络接口，并且不会进行端口映射。</p>
</li>
<li><p>使用主机网络模式启动容器：</p>
</li>
</ul>
<p>docker run -d –network host nginx<br>​</p>
</li>
<li><p><strong>用户定义网络</strong>:</p>
<ul>
<li><p>用户可以创建自己的自定义网络，可以在这个网络上创建容器，并且容器可以相互通信。</p>
</li>
<li><p>创建一个自定义网络：</p>
</li>
</ul>
<p>docker network create my_network<br>​</p>
<ul>
<li>在自定义网络上运行容器：</li>
</ul>
<p>docker run -d –network my_network –name container1 nginx<br>docker run -d –network my_network –name container2 nginx<br>​</p>
</li>
<li><p><strong>覆盖网络（overlay）</strong>:</p>
<ul>
<li><p>覆盖网络允许在不同主机上的Docker守护程序之间创建跨主机的容器通信。这在Docker集群中很有用。</p>
</li>
<li><p>创建覆盖网络：</p>
</li>
</ul>
<p>docker network create –driver overlay my_overlay_network<br>​</p>
<ul>
<li>在覆盖网络上启动容器：</li>
</ul>
<p>docker service create –network my_overlay_network –name my_service nginx<br>​</p>
</li>
<li><p><strong>Macvlan网络</strong>:</p>
<ul>
<li><p>Macvlan网络允许将容器直接连接到物理网络，每个容器都有自己的MAC地址。</p>
</li>
<li><p>创建Macvlan网络：</p>
</li>
</ul>
<p>docker network create -d macvlan –subnet&#x3D;192.168.1.0&#x2F;24 –gateway&#x3D;192.168.1.1 -o parent&#x3D;eth0 my_macvlan_network<br>​</p>
<ul>
<li>在Macvlan网络上运行容器：</li>
</ul>
<p>docker run -d –network my_macvlan_network –name container1 nginx<br>​</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://sosocrown.github.io">niki</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://sosocrown.github.io/2023/10/20/docker/">https://sosocrown.github.io/2023/10/20/docker/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://sosocrown.github.io" target="_blank">The Fountainhead</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AE%B9%E5%99%A8/">容器</a><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>buy me a coffee</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/02/08/Linux%20%E5%86%85%E6%A0%B8--Cgroup%E4%B8%8Enamespace/" title="Linux 内核--Cgroup与namespace"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-08</div><div class="info-item-2">Linux 内核--Cgroup与namespace</div></div><div class="info-2"><div class="info-item-1">容器 &#x3D; cgroup + namespace + rootfs + 容器引擎容器的核心技术是 Cgroup + Namespace  ​	Cgroup： 资源控制  ​	namespace： 访问隔离 ​	rootfs：文件系统隔离。镜像的本质就是一个rootfs文件 ​	容器引擎：生命周期控制  cgroup（控制组）和namespace（命名空间） 是 Linux 内核中的两个核心技术，主要用于实现资源管理和环境隔离，它们是容器技术（如 Docker）的底层基础。  cgroup（控制组）：核心作用：限制、分配和监控进程的资源使用，比如 CPU、内存、磁盘 I&#x2F;O 等。  作用： 通过cgroup，系统管理员可以为一组进程分配资源，并限制它们对系统资源的使用。这对于实现资源隔离和管理是很有用的，特别是在容器化环境中，可以确保容器之间不会相互干扰，同时允许对资源进行有效的分配和控制。  namespace（命名空间）：命名空间是 Linux 内核提供的一种隔离机制，用于隔离容器的进程和文件系统等。  作用：...</div></div></div></a><a class="pagination-related" href="/2025/01/21/SElinux/" title="SElinux-安全上下文"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-21</div><div class="info-item-2">SElinux-安全上下文</div></div><div class="info-2"><div class="info-item-1">SElinux-Security-Enhanced Linux 安全增强型 linuxLinux系统安全的强制访问控制体系 三种配置模式 selinux的配置文件：&#x2F;etc&#x2F;sysconfig&#x2F;selinux     状态 含义    enforcing 级别为强制   permissive 级别为警告   disable 关闭    模式管理  1234567891011121314151617#查看当前工作模式[root@server ~]# getenforce[root@server ~]# getenforceEnforcing# 临时关闭进入宽容模式[root@server ~]# setenforce  0  [root@server ~]# getenforcePermissive # 临时开启[root@server ~]# setenforce  1 [root@server ~]# getenforceEnforcing#永久性关闭[root@server ~]# vim  /etc/selinux/config...</div></div></div></a><a class="pagination-related" href="/2024/10/30/ansible/" title="ansible"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-30</div><div class="info-item-2">ansible</div></div><div class="info-2"><div class="info-item-1">一、安装与配置1.安装1234567#yum安装yum install epel-release -yyum install ansible –y#查看ansible版本ansible --version  2.管理节点与被管理节点建⽴SSH信任关系2.1.生成私钥 	[root@server ~]# ssh-keygen    2.2.向主机分发私钥 	[root@server ~]# ssh-copy-id root@192.168.37.122 	[root@server ~]# ssh-copy-id root@192.168.37.133  3. ansible配置文件修改配置文件，创建主机清单文件 ：写在[]里的是组名，[ ]下面的是组内的主机名	[root@server ~]# vim &#x2F;etc&#x2F;ansible&#x2F;hosts		[web]		192.168.37.122		192.168.37.133 二、核心组件主机清单（Inventory）模块（Modules）任务（Tasks）和剧本（Playbooks）角色（Roles） ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">niki</div><div class="author-info-description">You must learn not to be afraid of the world. Never to be hurt by it as you were in that courtroom.You'll win, because you've chosen the hardest way of fighting for your freedom from the world.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sosocrown"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/sosocrown" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/zn40489@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://www.douban.com/people/yourprofile" target="_blank" title="Douban"><i class="fab fa-douban" style="color: #007722;"></i></a><a class="social-icon" href="/your_wechat_id" target="_blank" title="WeChat"><i class="fas fa-weixin" style="color: #07c160;"></i></a><a class="social-icon" href="https://www.linkedin.com/in/yourprofile" target="_blank" title="LinkedIn"><i class="fab fa-linkedin" style="color: #0077b5;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">恭喜，进入了一个空虚的数字世界。如果你遇到技术问题，你可能会在这儿找到一些答案，或者完全没有。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#docker"><span class="toc-number">1.</span> <span class="toc-text">docker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%9ADocker%E5%9F%BA%E7%A1%80%E3%80%81"><span class="toc-number">1.1.</span> <span class="toc-text">一：Docker基础、</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDocker%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是Docker？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">Docker是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%EF%BC%9Aclient-server"><span class="toc-number">1.1.3.</span> <span class="toc-text">架构：client-server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E7%94%A8%E9%80%94"><span class="toc-number">1.1.4.</span> <span class="toc-text">Docker的优势和用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Docker"><span class="toc-number">1.1.5.</span> <span class="toc-text">安装Docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.6.</span> <span class="toc-text">Docker基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%EF%BC%88Images%EF%BC%89%E5%92%8C%E5%AE%B9%E5%99%A8%EF%BC%88Containers%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.7.</span> <span class="toc-text">镜像（Images）和容器（Containers）的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">基本命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">2.0.1.</span> <span class="toc-text">镜像命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.0.2.</span> <span class="toc-text">容器命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%EF%BC%8C%E5%B0%B1%E5%BF%85%E9%A1%BB%E8%A6%81%E6%9C%89%E4%B8%80%E4%B8%AA%E5%89%8D%E5%8F%B0%E8%BF%9B%E7%A8%8B%EF%BC%8C"><span class="toc-number">3.</span> <span class="toc-text">docker容器使用后台运行，就必须要有一个前台进程，</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.0.1.</span> <span class="toc-text">其他常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4"><span class="toc-number">3.0.2.</span> <span class="toc-text">帮助命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dickerfile-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F"><span class="toc-number">4.</span> <span class="toc-text">dickerfile-创建自定义镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dockerfile%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">4.0.1.</span> <span class="toc-text">dockerfile的指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4-docker-build-f-%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84-t-%E9%95%9C%E5%83%8F%E5%90%8D-tag"><span class="toc-number">5.</span> <span class="toc-text">命令 docker build -f 文件路径 -t 镜像名:[tag]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-history"><span class="toc-number">5.0.1.</span> <span class="toc-text">docker history &lt;镜像ID或名称&gt;-</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7%EF%BC%88Container-Volumes%EF%BC%89%EF%BC%9A"><span class="toc-number">5.0.2.</span> <span class="toc-text">1. 容器数据卷（Container Volumes）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E5%92%8C%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-number">5.0.3.</span> <span class="toc-text">容器之间共享和持久化数据的机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E6%8C%82%E8%BD%BD-%E5%8C%BF%E5%90%8D%E6%8C%82%E8%BD%BD"><span class="toc-number">5.0.4.</span> <span class="toc-text">具名挂载 &amp; 匿名挂载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8%EF%BC%88Data-Volume-Containers%EF%BC%89%EF%BC%9A"><span class="toc-number">5.0.5.</span> <span class="toc-text">2. 数据卷容器（Data Volume Containers）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%92%8C%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AE%B9%E5%99%A8"><span class="toc-number">5.0.6.</span> <span class="toc-text">管理和存储数据卷的特殊容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E7%BD%91%E7%BB%9C"><span class="toc-number">5.0.7.</span> <span class="toc-text">docker 网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E7%BD%91%E7%BB%9C%E6%98%AFDocker%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%E3%80%82"><span class="toc-number">5.0.8.</span> <span class="toc-text">Docker网络是Docker容器之间通信的一种方式。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#veth-pair"><span class="toc-number">5.0.9.</span> <span class="toc-text">veth-pair</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/08/git-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/" title="git">git</a><time datetime="2025-02-08T07:48:57.013Z" title="发表于 2025-02-08 15:48:57">2025-02-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/08/Linux%20%E5%86%85%E6%A0%B8--Cgroup%E4%B8%8Enamespace/" title="Linux 内核--Cgroup与namespace">Linux 内核--Cgroup与namespace</a><time datetime="2025-02-08T07:43:55.000Z" title="发表于 2025-02-08 15:43:55">2025-02-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/21/SElinux/" title="SElinux-安全上下文">SElinux-安全上下文</a><time datetime="2025-01-21T08:59:08.643Z" title="发表于 2025-01-21 16:59:08">2025-01-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/21/linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/" title="文件系统与磁盘管理">文件系统与磁盘管理</a><time datetime="2025-01-21T08:59:08.631Z" title="发表于 2025-01-21 16:59:08">2025-01-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/21/%E6%96%87%E4%BB%B6%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8facl/" title="linux-文件的访问控制列表facl">linux-文件的访问控制列表facl</a><time datetime="2025-01-21T08:59:08.627Z" title="发表于 2025-01-21 16:59:08">2025-01-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By niki</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to the <a href="https://sosocrown.github.io//">fountainhead</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索内容..." type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>